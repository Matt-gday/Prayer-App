<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Prayer Companion</title>
  
  <!-- PWA / Add to Home Screen support for iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Prayer">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#EDE4D8">
  
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    html, body, #root {
      height: 100%;
      width: 100%;
      /* Match app gradient everywhere to avoid white edges */
      background: linear-gradient(160deg, #F5EEE4 0%, #E8DECE 50%, #EDE4D8 100%);
      background-attachment: fixed;
    }
    body {
      font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      /* Safe areas for notched phones and Safari bars */
      padding-top: env(safe-area-inset-top);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      padding-bottom: env(safe-area-inset-bottom);
    }
    input, textarea, select, button {
      font-family: inherit;
    }
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    ::-webkit-scrollbar-thumb {
      background: rgba(128,128,128,0.3);
      border-radius: 3px;
    }
    
    /* Home page circular buttons - unified style */
    .home-circle-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(250,247,242,0.95);
      border: 1.5px solid #D4C8B8;
      border-radius: 50%;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      font-style: italic;
      font-family: Georgia, serif;
      color: #6B5D4F;
      box-shadow: 0 2px 6px rgba(90,70,50,0.1);
      transition: all 0.2s ease;
    }
    .home-circle-btn:hover {
      background: #FAF7F2;
      border-color: #B87A4A;
      color: #B87A4A;
    }
    .home-circle-btn.active {
      background: linear-gradient(135deg, #D49A5A 0%, #A66830 100%);
      color: white;
      border-color: #A66830;
      box-shadow: 0 2px 8px rgba(184,122,74,0.3);
    }
    /* Symbol buttons don't need italic, lighter weight */
    .home-circle-btn.symbol {
      font-style: normal;
      font-family: inherit;
      font-weight: 400;
    }
    
    /* Onboarding screen */
    .onboarding-overlay {
      position: fixed;
      inset: 0;
      background: linear-gradient(160deg, #F5EEE4 0%, #E8DECE 50%, #EDE4D8 100%);
      z-index: 2000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px;
      text-align: center;
    }
    .onboarding-card {
      background: linear-gradient(145deg, #FFFFFF 0%, #F5F0E8 100%);
      border-radius: 24px;
      padding: 32px 28px;
      max-width: 360px;
      width: 100%;
      box-shadow: 0 8px 40px rgba(90,70,50,0.15), 0 2px 8px rgba(90,70,50,0.1);
      border: 1px solid #D4C8B8;
    }
    .onboarding-title {
      font-size: 24px;
      font-weight: 700;
      color: #3D352C;
      margin-bottom: 12px;
    }
    .onboarding-text {
      font-size: 15px;
      color: #6B5D4F;
      line-height: 1.6;
      margin-bottom: 24px;
    }
    .onboarding-input {
      width: 100%;
      padding: 16px 18px;
      font-size: 18px;
      text-align: center;
      background: #FAF7F2;
      border: 1.5px solid #D4C8B8;
      border-radius: 14px;
      color: #3D352C;
      margin-bottom: 20px;
      box-sizing: border-box;
      font-family: inherit;
      outline: none;
      text-transform: capitalize;
      transition: border-color 0.2s ease;
    }
    .onboarding-input:focus {
      border-color: #B87A4A;
    }
    .onboarding-input::placeholder {
      text-transform: none;
      color: #8C7B6A;
    }
    .onboarding-btn {
      width: 100%;
      padding: 16px 24px;
      font-size: 17px;
      font-weight: 600;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.2s ease;
      margin-bottom: 12px;
    }
    .onboarding-btn-primary {
      background: linear-gradient(135deg, #D49A5A 0%, #A66830 100%);
      color: white;
      box-shadow: 0 4px 16px rgba(184,122,74,0.35);
    }
    .onboarding-btn-secondary {
      background: linear-gradient(135deg, #EDE4D6 0%, #D9CDBF 100%);
      color: #4A3F34;
      border: 1px solid #D4C8B8;
    }
    .onboarding-hint {
      font-size: 13px;
      color: #8C7B6A;
      margin-top: 16px;
      font-style: italic;
    }
    
    /* Edit name button */
    .edit-name-btn {
      background: none;
      border: none;
      padding: 4px;
      margin-left: 6px;
      cursor: pointer;
      color: #8C7B6A;
      font-size: 12px;
      opacity: 0.6;
      transition: opacity 0.2s ease;
      vertical-align: middle;
    }
    .edit-name-btn:hover {
      opacity: 1;
      color: #B87A4A;
    }
    
    /* Data modal */
    .data-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      z-index: 1500;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .data-modal {
      background: linear-gradient(145deg, #FFFFFF 0%, #F5F0E8 100%);
      border-radius: 20px;
      padding: 24px;
      max-width: 360px;
      width: 100%;
      box-shadow: 0 8px 40px rgba(0,0,0,0.2);
      border: 1px solid #D4C8B8;
    }
    .data-modal h3 {
      font-size: 18px;
      font-weight: 600;
      color: #3D352C;
      margin-bottom: 8px;
      text-align: center;
    }
    .data-modal-desc {
      font-size: 14px;
      color: #6B5D4F;
      text-align: center;
      margin-bottom: 20px;
      line-height: 1.5;
    }
    .data-modal-btn {
      width: 100%;
      padding: 14px 20px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.2s ease;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    .data-modal-btn-download {
      background: linear-gradient(135deg, #6DB88A 0%, #4A8862 100%);
      color: white;
      box-shadow: 0 4px 16px rgba(90,158,120,0.3);
    }
    .data-modal-btn-upload {
      background: linear-gradient(135deg, #EDE4D6 0%, #D9CDBF 100%);
      color: #4A3F34;
      border: 1px solid #D4C8B8;
    }
    .data-modal-btn-cancel {
      background: transparent;
      color: #8C7B6A;
      margin-top: 8px;
      margin-bottom: 0;
    }
    .data-modal-warning {
      background: rgba(196,99,94,0.1);
      border: 1px solid rgba(196,99,94,0.3);
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 16px;
      font-size: 13px;
      color: #8B4513;
      text-align: center;
      line-height: 1.5;
    }
    
    /* Edit name modal */
    .edit-name-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      z-index: 1500;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .edit-name-modal {
      background: linear-gradient(145deg, #FFFFFF 0%, #F5F0E8 100%);
      border-radius: 20px;
      padding: 24px;
      max-width: 320px;
      width: 100%;
      box-shadow: 0 8px 40px rgba(0,0,0,0.2);
      border: 1px solid #D4C8B8;
    }
    .edit-name-modal h3 {
      font-size: 18px;
      font-weight: 600;
      color: #3D352C;
      margin-bottom: 16px;
      text-align: center;
    }
    
    /* Card scroll indicator */
    .scroll-indicator {
      position: absolute;
      bottom: 8px;
      right: 12px;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #8C7B6A;
      font-size: 14px;
      opacity: 0.7;
      transition: opacity 0.3s ease, transform 0.3s ease;
      pointer-events: none;
    }
    .scroll-indicator.hidden {
      opacity: 0;
    }
    
    /* Help/Manual accordion */
    .help-section {
      margin-bottom: 8px;
    }
    .help-accordion {
      background: linear-gradient(145deg, #FFFFFF 0%, #F5F0E8 100%);
      border: 1px solid #D4C8B8;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(90,70,50,0.08);
    }
    .help-accordion-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s ease;
    }
    .help-accordion-header:hover {
      background: rgba(184,122,74,0.05);
    }
    .help-accordion-title {
      font-size: 15px;
      font-weight: 600;
      color: #3D352C;
    }
    .help-accordion-icon {
      color: #8C7B6A;
      font-size: 14px;
      transition: transform 0.3s ease;
    }
    .help-accordion-icon.open {
      transform: rotate(180deg);
    }
    .help-accordion-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .help-accordion-content.open {
      max-height: 500px;
    }
    .help-accordion-body {
      padding: 0 16px 16px;
      font-size: 14px;
      color: #6B5D4F;
      line-height: 1.6;
    }
    .help-accordion-body p {
      margin-bottom: 8px;
    }
    .help-accordion-body ul {
      margin-left: 16px;
      margin-bottom: 8px;
    }
    .help-accordion-body li {
      margin-bottom: 4px;
    }
    .help-tip {
      background: rgba(184,122,74,0.1);
      padding: 10px 12px;
      border-radius: 8px;
      font-style: italic;
      margin-top: 8px;
    }
    
    /* App container - full width on mobile/tablet, constrained only on desktop */
    .app-container {
      max-width: none;
      width: 100%;
    }
    /* Desktop only - constrained width with seamless background */
    @media (min-width: 1200px) {
      .app-container {
        max-width: 540px;
        background: transparent !important;
      }
    }
    @media (min-width: 1400px) {
      .app-container {
        max-width: 600px;
      }
    }
    /* Bottom nav - match container width */
    .bottom-nav {
      max-width: none;
      width: 100%;
    }
    @media (min-width: 1200px) {
      .bottom-nav {
        max-width: 540px;
      }
    }
    @media (min-width: 1400px) {
      .bottom-nav {
        max-width: 600px;
      }
    }
    
    /* Tablet-specific adjustments - scale up everything (exclude landscape phones by requiring min-height) */
    @media (min-width: 768px) and (max-width: 1199px) and (min-height: 600px) {
      .app-container {
        padding-left: 32px;
        padding-right: 32px;
        padding-top: 24px;
      }
      /* Scale up buttons */
      .home-start-btn {
        width: clamp(200px, 28vw, 280px) !important;
        height: clamp(200px, 28vw, 280px) !important;
        font-size: clamp(24px, 3.5vw, 34px) !important;
      }
      .home-start-wrapper {
        padding: 60px 0 !important;
        margin-bottom: 60px !important;
      }
      .home-action-btn {
        padding: 18px 36px !important;
        font-size: 18px !important;
        min-width: 240px !important;
        width: auto !important;
      }
      /* Scale up text */
      .home-welcome {
        font-size: clamp(32px, 5vw, 44px) !important;
      }
      .home-subtext {
        font-size: clamp(18px, 2.5vw, 24px) !important;
        margin-top: 4px !important;
      }
      .home-prayers-heading {
        font-size: 15px !important;
        margin-bottom: 20px !important;
        letter-spacing: 1.5px !important;
      }
      .home-prayers-list {
        font-size: clamp(17px, 2.5vw, 22px) !important;
        line-height: 2.4 !important;
      }
      /* More spacing */
      .home-actions-portrait {
        gap: 20px !important;
      }
      .home-portrait-divider {
        margin-top: 56px !important;
        margin-bottom: 40px !important;
        max-width: 360px !important;
      }
      .home-greeting {
        padding-top: 24px !important;
        margin-bottom: 16px !important;
      }
    }
    
    /* Large tablet landscape */
    @media (min-width: 1024px) and (max-width: 1199px) and (orientation: landscape) {
      .home-start-btn {
        width: clamp(140px, 16vw, 180px) !important;
        height: clamp(140px, 16vw, 180px) !important;
        font-size: clamp(18px, 2.2vw, 24px) !important;
      }
    }
    
    /* Prayer view - fit within viewport with scrollable card area */
    .prayer-view-container {
      display: flex;
      flex-direction: column;
      height: 100dvh; /* Dynamic viewport height - accounts for mobile browser UI */
      height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      max-height: 100dvh;
      padding: 16px;
      padding-top: max(12px, env(safe-area-inset-top));
      padding-bottom: max(16px, env(safe-area-inset-bottom));
      box-sizing: border-box;
      overflow: hidden;
    }
    .prayer-card-area {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      display: flex;
      flex-direction: column;
    }
    .prayer-card-area > div:first-child {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .prayer-nav-area {
      flex-shrink: 0;
      padding-top: 8px;
    }
    /* Desktop - constrain prayer view width */
    @media (min-width: 1200px) {
      .prayer-view-container {
        max-width: 540px;
      }
    }
    @media (min-width: 1400px) {
      .prayer-view-container {
        max-width: 600px;
      }
    }
    
    /* Home page landscape layout */
    .home-content {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }
    .home-left {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .home-right {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }
    .home-right-content {
      display: flex;
      flex-direction: column;
    }
    .home-separator {
      display: none;
    }
    .home-actions-portrait {
      display: flex;
    }
    .home-header-row {
      display: none;
    }
    /* Landscape mode - two columns */
    @media (orientation: landscape) and (max-width: 1023px) {
      .home-content {
        flex-direction: row;
        gap: 0;
      }
      .home-left {
        flex: 0 0 auto;
        width: calc(50% - 1px);
        justify-content: center;
        align-items: center;
        padding-right: 24px;
      }
      .home-right {
        flex: 1;
        padding-left: 24px;
        justify-content: center;
        align-items: center;
        padding-top: 0;
      }
      .home-right-content {
        width: 100%;
        max-width: 100%;
      }
      .home-actions-portrait {
        display: flex !important;
        flex-direction: row !important;
        gap: 10px;
        margin-bottom: 0 !important;
        margin-top: 36px !important;
      }
      .home-start-btn-wrapper {
        padding: 0 !important;
        margin-bottom: 0 !important;
      }
      .home-separator {
        display: block;
        width: 1px;
        background: linear-gradient(180deg, transparent 0%, rgba(180,160,140,0.4) 20%, rgba(180,160,140,0.4) 80%, transparent 100%);
        align-self: stretch;
      }
      .home-header-row {
        display: flex !important;
        flex-direction: row !important;
        justify-content: space-between !important;
        align-items: center !important;
        text-align: left !important;
        padding-top: 4px !important;
        margin-bottom: 8px !important;
      }
      .home-header-row .home-greeting-text {
        display: flex;
        align-items: baseline;
        gap: 12px;
      }
      .home-greeting {
        display: none !important;
      }
      .home-start-btn-wrapper {
        padding: 0 !important;
      }
.home-spacer-top, .home-spacer-bottom, .home-portrait-divider {
         display: none;
       }
       .home-header-row {
         display: flex !important;
       }
     }
     
     /* Generic landscape 2-column layout for other screens */
     .landscape-layout {
       display: flex;
       flex-direction: column;
       flex: 1;
       min-height: 0;
     }
     .landscape-left {
       display: flex;
       flex-direction: column;
     }
     .landscape-right {
       flex: 1;
       min-height: 0;
       display: flex;
       flex-direction: column;
       overflow-y: auto;
     }
     .landscape-separator {
       display: none;
     }
     @media (orientation: landscape) and (max-width: 1023px) {
       .landscape-layout {
         flex-direction: row;
         gap: 0;
       }
       .landscape-left {
         flex: 0 0 auto;
         width: calc(50% - 1px);
         padding-right: 24px;
         overflow-y: auto;
       }
       .landscape-right {
         flex: 1;
         padding-left: 24px;
       }
       .landscape-separator {
         display: block;
         width: 1px;
         background: linear-gradient(180deg, transparent 0%, rgba(180,160,140,0.4) 20%, rgba(180,160,140,0.4) 80%, transparent 100%);
         align-self: stretch;
         flex-shrink: 0;
       }
     }
     
     /* 2-column grid for lists in landscape */
     .two-column-grid {
       display: grid !important;
       grid-template-columns: 1fr;
       gap: 6px;
     }
     @media (orientation: landscape) and (max-width: 1023px) {
       .two-column-grid {
         grid-template-columns: 1fr 1fr !important;
         gap: 8px 16px !important;
       }
     }
     
/* Reduce header spacing in landscape */
    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      min-height: 28px;
    }
    .page-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 8px;
      text-align: center;
    }
     @media (orientation: landscape) and (max-width: 1023px) {
       .app-header {
         margin-bottom: 6px;
         min-height: 36px;
       }
       .app-container {
         padding-top: 8px !important;
       }
     }
     
     /* 3-column grid for group cards in prayer view */
     .three-column-grid {
       display: grid !important;
       grid-template-columns: repeat(3, 1fr);
       gap: 8px 12px;
     }
     
     /* Portrait/Landscape only visibility */
     .portrait-only { display: block !important; }
     .landscape-only { display: none !important; }
     @media (orientation: landscape) and (max-width: 1023px) {
       .portrait-only { display: none !important; }
       .landscape-only { display: block !important; }
       .card-header-row { margin-bottom: 4px !important; }
       .sort-row { width: auto !important; justify-content: flex-start !important; gap: 8px !important; }
     }
     /* Ensure desktop shows portrait layout */
     @media (min-width: 1024px) {
       .portrait-only { display: block !important; }
       .landscape-only { display: none !important; }
     }
     
     /* Card slide animations */
     @keyframes slideInFromRight {
       from { transform: translateX(100%); opacity: 0; }
       to { transform: translateX(0); opacity: 1; }
     }
     @keyframes slideInFromLeft {
       from { transform: translateX(-100%); opacity: 0; }
       to { transform: translateX(0); opacity: 1; }
     }
     .card-slide-right {
       animation: slideInFromRight 0.25s ease-out;
     }
     .card-slide-left {
       animation: slideInFromLeft 0.25s ease-out;
     }
   </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useCallback } = React;

    const generateId = () => Math.random().toString(36).substr(2, 9);
    const formatDate = (date) => {
      const d = new Date(date);
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    };
    const getToday = () => formatDate(new Date());

    const getGreeting = (name = 'Friend') => {
      const hour = new Date().getHours();
      if (hour < 12) return `Good morning, ${name}`;
      if (hour < 17) return `Good afternoon, ${name}`;
      return `Good evening, ${name}`;
    };

    // Hash function to consistently assign cards to time slots for even distribution
    const getSlotFromId = (id, numSlots) => {
      let hash = 0;
      for (let i = 0; i < id.length; i++) {
        hash = ((hash << 5) - hash) + id.charCodeAt(i);
        hash = hash & hash;
      }
      return Math.abs(hash) % numSlots;
    };

    const generatePrayerHistory = (frequency, weeksBack = 8) => {
      const history = [];
      const today = new Date();
      for (let i = 0; i < weeksBack * 7; i++) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        let shouldAdd = false;
        if (frequency === 'daily') shouldAdd = Math.random() > 0.15;
        else if (frequency === 'every-2-3-days') shouldAdd = i % 2 === 0 && Math.random() > 0.2;
        else if (frequency === 'weekly') shouldAdd = i % 7 === 0 && Math.random() > 0.1;
        else if (frequency === 'monthly') shouldAdd = i % 28 === 0;
        if (shouldAdd) history.push(formatDate(date));
      }
      return history;
    };

    const generateDemoData = () => {
      const today = new Date();
      const demoPeople = [
        { id: 'p1', firstName: 'Sarah', lastName: 'Mitchell', organisation: '', prayerPoint: 'Healing from surgery\nPeace during recovery', isChild: false, individualCheckbox: true },
        { id: 'p2', firstName: 'James', lastName: 'Mitchell', organisation: '', prayerPoint: 'Job interview this week\nWisdom in career decisions', isChild: false, individualCheckbox: true },
        { id: 'p3', firstName: 'Emma', lastName: 'Mitchell', organisation: '', prayerPoint: '', isChild: true, individualCheckbox: false },
        { id: 'p4', firstName: 'Liam', lastName: 'Mitchell', organisation: '', prayerPoint: '', isChild: true, individualCheckbox: false },
        { id: 'p5', firstName: 'Victoria', lastName: 'Greene', organisation: '', prayerPoint: 'Confidence at school', isChild: false, individualCheckbox: true },
        { id: 'p6', firstName: 'David', lastName: 'Chen', organisation: 'Christ Central Church', prayerPoint: 'Wisdom for church direction', isChild: false, individualCheckbox: true },
        { id: 'p7', firstName: 'Scott', lastName: 'Reynolds', organisation: '', prayerPoint: '', isChild: false, individualCheckbox: true },
        { id: 'p8', firstName: 'Craig', lastName: 'Thompson', organisation: '', prayerPoint: 'Marriage restoration', isChild: false, individualCheckbox: true },
        { id: 'p9', firstName: 'Ben', lastName: 'Parker', organisation: '', prayerPoint: '', isChild: false, individualCheckbox: true },
        { id: 'p10', firstName: 'Estelle', lastName: 'Warren', organisation: '', prayerPoint: 'Peace and direction', isChild: false, individualCheckbox: true },
        { id: 'p11', firstName: 'Jessica', lastName: 'Martin', organisation: '', prayerPoint: 'Music ministry growth', isChild: false, individualCheckbox: true },
        { id: 'p12', firstName: 'Michael', lastName: 'Torres', organisation: '', prayerPoint: 'Financial breakthrough', isChild: false, individualCheckbox: true },
        { id: 'p13', firstName: 'Rachel', lastName: 'Torres', organisation: '', prayerPoint: '', isChild: false, individualCheckbox: true },
        { id: 'p14', firstName: 'Sophie', lastName: 'Torres', organisation: '', prayerPoint: '', isChild: true, individualCheckbox: false },
        { id: 'p15', firstName: 'Mark', lastName: 'Stevens', organisation: 'OMF Thailand', prayerPoint: 'Protection and provision', isChild: false, individualCheckbox: true },
        { id: 'p16', firstName: '', lastName: '', organisation: 'City Youth Outreach', prayerPoint: 'Volunteer recruitment', isChild: false, individualCheckbox: true },
      ];

      const generateHistoryForFrequency = (frequency, personId, prayerPoint) => {
        const history = [];
        const today = new Date();
        
        // Sample historical prayer points that vary over time
        const historicalPoints = {
          p1: ['Healing from surgery\nPeace during recovery', 'Pre-surgery preparations\nStrength and courage', 'Recovery going well\nPhysical therapy progress'],
          p2: ['Job interview this week\nWisdom in career decisions', 'Waiting on job offer\nPatience and trust', 'Starting new role\nSmooth transition'],
          p5: ['Confidence at school', 'Upcoming exams\nFocus and clarity', 'Friendships at school'],
          p6: ['Wisdom for church direction', 'Building leadership team', 'Vision for 2026'],
          p8: ['Marriage restoration', 'Communication with spouse\nHealing past hurts', 'Counselling sessions'],
          p10: ['Peace and direction', 'New opportunities arising\nDiscernment needed', 'Grateful for clarity'],
          p11: ['Music ministry growth', 'New worship songs\nTeam development', 'Leading Sunday worship'],
          p12: ['Financial breakthrough', 'Business decisions\nProvision for family', 'Debt reduction progress'],
          p15: ['Protection and provision', 'Team health in Thailand\nLocal partnerships', 'Visa renewal process'],
          p16: ['Volunteer recruitment', 'Youth camp planning\nFunding needs', 'New youth leaders']
        };
        
        const cardPoints = {
          c1: ['Family unity and health', 'Holiday time together\nSafe travels', 'School year starting well'],
          c4: ['Gaming group connections\nOpportunities to share faith', 'Tuesday meetups\nDeeper friendships', ''],
          c7: ['Torres family provision\nKids schooling', 'Family health', '']
        };
        
        let startDay;
        if (frequency === 'daily') startDay = 1;
        else if (frequency === 'every-2-3-days') startDay = 3;
        else if (frequency === 'weekly') startDay = 7;
        else startDay = 30;
        
        for (let i = startDay; i < 8 * 7; i++) {
          const date = new Date(today);
          date.setDate(date.getDate() - i);
          
          let shouldAdd = false;
          if (frequency === 'daily') shouldAdd = Math.random() > 0.15;
          else if (frequency === 'every-2-3-days') shouldAdd = i % 2 === 0 && Math.random() > 0.2;
          else if (frequency === 'weekly') shouldAdd = i % 7 === 0 && Math.random() > 0.1;
          else if (frequency === 'monthly') shouldAdd = i % 28 === 0;
          
          if (shouldAdd) {
            const pointsArray = historicalPoints[personId] || [prayerPoint || ''];
            const pointIndex = Math.floor(i / 14) % pointsArray.length; // Change points every ~2 weeks
            const personPrayerPoint = pointsArray[pointIndex] || prayerPoint || '';
            
            // Determine which card this person belongs to for card prayer points
            let cardPrayerPoint = '';
            let cardName = '';
            if (['p1', 'p2', 'p3', 'p4'].includes(personId)) {
              const cPoints = cardPoints['c1'] || [''];
              cardPrayerPoint = cPoints[pointIndex % cPoints.length] || '';
              cardName = 'Mitchells';
            } else if (['p7', 'p8', 'p9'].includes(personId)) {
              const cPoints = cardPoints['c4'] || [''];
              cardPrayerPoint = cPoints[pointIndex % cPoints.length] || '';
              cardName = 'Tuesday Gaming';
            } else if (['p12', 'p13', 'p14'].includes(personId)) {
              const cPoints = cardPoints['c7'] || [''];
              cardPrayerPoint = cPoints[pointIndex % cPoints.length] || '';
              cardName = 'Torres Family';
            }
            
            history.push({
              date: formatDate(date),
              personPrayerPoint,
              cardPrayerPoint,
              cardName
            });
          }
        }
        return history;
      };

      const frequencies = { 
        p1: 'every-2-3-days', p2: 'every-2-3-days', p3: 'every-2-3-days', p4: 'every-2-3-days', 
        p5: 'daily', p6: 'weekly', 
        p7: 'every-2-3-days', p8: 'every-2-3-days', p9: 'every-2-3-days', 
        p10: 'daily', p11: 'daily', 
        p12: 'weekly', p13: 'weekly', p14: 'weekly', 
        p15: 'monthly',
        p16: 'weekly'
      };

      const peopleWithHistory = demoPeople.map(p => ({
        ...p,
        prayerHistory: generateHistoryForFrequency(frequencies[p.id], p.id, p.prayerPoint),
        dateAdded: '2024-10-01',
        firstPrayerCompleted: true
      }));

      const demoCards = [
        { id: 'c1', name: 'Mitchells', peopleIds: ['p1', 'p2', 'p3', 'p4'], frequency: 'daily', prayerPoint: 'Family unity and health', includeUnnamedChildren: false, isGroup: true, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        { id: 'c2', name: 'Victoria Greene', peopleIds: ['p5'], frequency: 'daily', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        { id: 'c3', name: 'David Chen', peopleIds: ['p6'], frequency: 'weekly', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        { id: 'c4', name: 'Tuesday Gaming', peopleIds: ['p7', 'p8', 'p9'], frequency: 'every-2-3-days', prayerPoint: '', includeUnnamedChildren: false, isGroup: true, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        { id: 'c5', name: 'Estelle Warren', peopleIds: ['p10'], frequency: 'daily', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        { id: 'c6', name: 'Jessica Martin', peopleIds: ['p11'], frequency: 'daily', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        { id: 'c7', name: 'Torres Family', peopleIds: ['p12', 'p13', 'p14'], frequency: 'weekly', prayerPoint: '', includeUnnamedChildren: true, isGroup: true, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        { id: 'c8', name: 'Mark Stevens', peopleIds: ['p15'], frequency: 'monthly', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        { id: 'c9', name: 'City Youth Outreach', peopleIds: ['p16'], frequency: 'weekly', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
      ];

      return { people: peopleWithHistory, cards: demoCards };
    };

    const getStored = (key, fallback) => { 
      try { 
        const s = localStorage.getItem(key); 
        return s ? JSON.parse(s) : fallback; 
      } catch { 
        return fallback; 
      } 
    };
    

    function PrayerCompanion() {
      const [people, setPeople] = useState(() => getStored('prayerApp_people', []));
      const [cards, setCards] = useState(() => getStored('prayerApp_cards', []));
      const [session, setSession] = useState(() => getStored('prayerApp_session', null));
      const [screen, setScreen] = useState('home');
      const [currentCardIndex, setCurrentCardIndex] = useState(0);
      const [touchStart, setTouchStart] = useState(null);
      const [slideDirection, setSlideDirection] = useState(null);
      const [selectedPeopleForGroup, setSelectedPeopleForGroup] = useState([]);
      const [editingPerson, setEditingPerson] = useState(null);
      const [editingCard, setEditingCard] = useState(null);
      const [viewingStats, setViewingStats] = useState(null);
      const [statsMonth, setStatsMonth] = useState(new Date());
      const [sortBy, setSortBy] = useState('firstName');
      const [sortReversed, setSortReversed] = useState(false);
      const [cardSortBy, setCardSortBy] = useState('name');
      const [manageTab, setManageTab] = useState('people');
      const [historyTab, setHistoryTab] = useState('people');
      const [selectedHistoryDate, setSelectedHistoryDate] = useState(null);
      const [sortDropdownOpen, setSortDropdownOpen] = useState(false);
      const [freqDropdownOpen, setFreqDropdownOpen] = useState(false);
      const [personForm, setPersonForm] = useState({ firstName: '', lastName: '', organisation: '', prayerPoint: '', frequency: 'daily', isChild: false, individualCheckbox: true });
      const [cardForm, setCardForm] = useState({ name: '', frequency: 'daily', prayerPoint: '', includeUnnamedChildren: false });
      const [groupForm, setGroupForm] = useState({ name: '', frequency: 'weekly', prayerPoint: '', includeUnnamedChildren: false });
      const [groupStep, setGroupStep] = useState(1);
      const [checkboxOverrides, setCheckboxOverrides] = useState({});
      const [modal, setModal] = useState(null);
      const [demoMode, setDemoMode] = useState(() => getStored('prayerApp_demoMode', false));
      const [helpOpen, setHelpOpen] = useState(false);
      const [openAccordions, setOpenAccordions] = useState({});
      const [userName, setUserName] = useState(() => getStored('prayerApp_userName', ''));
      const [onboardingComplete, setOnboardingComplete] = useState(() => getStored('prayerApp_onboardingComplete', false));
      const [onboardingStep, setOnboardingStep] = useState(1);
      const [nameInput, setNameInput] = useState('');
      const [editingName, setEditingName] = useState(false);
      const [editNameInput, setEditNameInput] = useState('');
      const [dataModalOpen, setDataModalOpen] = useState(false);
      const [dataModalStep, setDataModalStep] = useState('main'); // 'main', 'confirmUpload'
      const [pendingUploadData, setPendingUploadData] = useState(null);
      
      // Data version for future migrations
      const DATA_VERSION = 1;
      const [cardScrollState, setCardScrollState] = useState({ canScrollDown: false, canScrollUp: false });
      const cardScrollRef = React.useRef(null);

      // "Morning Prayer" - warm parchment, golden hour glow
      const colors = {
        bg: '#EDE4D8', 
        bgGradient: 'linear-gradient(160deg, #F5EEE4 0%, #E8DECE 50%, #EDE4D8 100%)', 
        cardBg: '#FAF7F2', 
        cardBgGradient: 'linear-gradient(145deg, #FFFFFF 0%, #F5F0E8 100%)',
        text: '#3D352C', 
        textSecondary: '#6B5D4F', 
        textTertiary: '#8C7B6A',
        primary: '#B87A4A', 
        primaryGradient: 'linear-gradient(135deg, #D49A5A 0%, #A66830 100%)', 
        primaryText: '#FFFFFF',
        secondary: '#E4D9CA', 
        secondaryGradient: 'linear-gradient(135deg, #EDE4D6 0%, #D9CDBF 100%)',
        secondaryText: '#4A3F34', 
        accent: '#5A9E78', 
        accentGradient: 'linear-gradient(135deg, #6DB88A 0%, #4A8862 100%)',
        danger: '#C4635E', 
        dangerGradient: 'linear-gradient(135deg, #D4736D 0%, #A8504B 100%)', 
        border: '#D4C8B8', 
        checkboxBg: '#DED4C6', 
        checkboxChecked: '#B87A4A',
        cardShadow: '0 4px 20px rgba(90,70,50,0.12), 0 1px 3px rgba(90,70,50,0.08)', 
        inputBg: '#FAF7F2',
        inputBorder: '#D4C8B8'
      };

      const baseBtn = { border: 'none', borderRadius: '14px', cursor: 'pointer', fontWeight: '600', transition: 'all 0.2s ease', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', fontFamily: 'inherit' };
      const styles = {
        container: { fontFamily: "'Open Sans', -apple-system, BlinkMacSystemFont, sans-serif", background: colors.bgGradient, color: colors.text, minHeight: '100vh', padding: '16px', paddingTop: '12px', boxSizing: 'border-box', margin: '0 auto' },
        header: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px', minHeight: '44px' },
        btnPrimary: { ...baseBtn, width: '100%', padding: '18px 24px', fontSize: '17px', background: colors.primaryGradient, color: colors.primaryText, boxShadow: '0 6px 24px rgba(184,122,74,0.35), 0 2px 8px rgba(184,122,74,0.25)' },
        btnSecondary: { ...baseBtn, padding: '14px 20px', fontSize: '15px', background: colors.secondaryGradient, color: colors.secondaryText, flex: 1, border: `1px solid ${colors.border}` },
        btnText: { background: 'none', border: 'none', color: colors.primary, fontSize: '17px', fontWeight: '500', cursor: 'pointer', padding: '8px 0', fontFamily: 'inherit' },
        btnDanger: { ...baseBtn, width: '100%', padding: '16px 20px', fontSize: '16px', background: colors.dangerGradient, color: '#FFF', marginTop: '16px' },
        btnSmall: { ...baseBtn, padding: '8px 14px', fontSize: '13px', background: colors.secondaryGradient, color: colors.textSecondary, borderRadius: '10px', border: `1px solid ${colors.border}` },
        buttonRow: { display: 'flex', gap: '12px', marginBottom: '12px' },
        card: { background: colors.cardBgGradient || colors.cardBg, borderRadius: '20px', padding: '20px', marginBottom: '12px', boxShadow: colors.cardShadow, border: `1px solid ${colors.border}` },
        cardFullScreen: { flex: 1, display: 'flex', flexDirection: 'column', marginBottom: '0', minHeight: 0 },
        listItem: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '12px 14px', background: colors.cardBgGradient || colors.cardBg, borderRadius: '12px', marginBottom: '6px', cursor: 'pointer', boxShadow: colors.cardShadow, border: `1px solid ${colors.border}` },
        listItemName: { fontSize: '16px', fontWeight: '500' },
        listItemMeta: { fontSize: '15px', color: colors.textSecondary, fontWeight: '500' },
        input: { width: '100%', padding: '12px 16px', fontSize: '16px', backgroundColor: colors.inputBg, border: `1px solid ${colors.inputBorder || colors.border}`, borderRadius: '12px', color: colors.text, marginBottom: '12px', boxSizing: 'border-box', fontFamily: 'inherit', outline: 'none' },
        label: { display: 'block', fontSize: '12px', fontWeight: '600', color: colors.textSecondary, marginBottom: '6px', textTransform: 'uppercase', letterSpacing: '0.5px' },
        select: { width: '100%', padding: '12px 16px', fontSize: '16px', backgroundColor: colors.inputBg, border: `1px solid ${colors.inputBorder || colors.border}`, borderRadius: '12px', color: colors.text, marginBottom: '12px', boxSizing: 'border-box', fontFamily: 'inherit', appearance: 'none' },
        toggle: { display: 'flex', gap: '8px', marginBottom: '12px', background: colors.secondaryGradient, borderRadius: '12px', padding: '4px', border: `1px solid ${colors.border}` },
        toggleOption: { flex: 1, padding: '10px', textAlign: 'center', borderRadius: '10px', cursor: 'pointer', fontSize: '14px', fontWeight: '500', transition: 'all 0.2s ease' },
        toggleActive: { background: colors.primaryGradient, color: colors.primaryText, boxShadow: '0 2px 12px rgba(184,122,74,0.3)' },
        toggleInactive: { backgroundColor: 'transparent', color: colors.textSecondary },
        tabs: { display: 'flex', marginBottom: '12px', background: colors.secondaryGradient, borderRadius: '12px', padding: '4px', border: `1px solid ${colors.border}` },
        tab: { flex: 1, padding: '10px', textAlign: 'center', borderRadius: '10px', cursor: 'pointer', fontSize: '14px', fontWeight: '500', border: 'none', fontFamily: 'inherit' },
        cardHeaderRow: { display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '12px' },
        cardTitle: { fontSize: '15px', fontWeight: '600', color: colors.textSecondary, textTransform: 'uppercase', letterSpacing: '0.5px' },
        cardFrequency: { fontSize: '13px', color: colors.textSecondary, background: colors.secondaryGradient, padding: '4px 10px', borderRadius: '8px', fontWeight: '500', border: `1px solid ${colors.border}` },
        cardPrayerPoint: { fontSize: '15px', color: colors.textSecondary, marginBottom: '16px', fontStyle: 'italic', lineHeight: '1.5', textAlign: 'center' },
        nameRowContainer: { display: 'flex', flexDirection: 'column', marginBottom: '4px' },
        nameRow: { display: 'flex', alignItems: 'center', cursor: 'pointer', padding: '8px 0' },
        nameCheckbox: { borderRadius: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center', fontWeight: '700', color: '#FFF', flexShrink: 0, transition: 'all 0.2s ease' },
        namePrayerPoint: { fontSize: '14px', color: colors.textSecondary, fontStyle: 'italic', marginTop: '2px', lineHeight: '1.4' },
        singlePersonContent: { flex: 1, display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', padding: '20px 0' },
        singleNameRow: { display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', padding: '12px' },
        singlePrayerPoint: { fontSize: '16px', color: colors.textSecondary, textAlign: 'center', marginTop: '20px', fontStyle: 'italic', maxWidth: '85%', lineHeight: '1.5' },
        groupNamesContainer: { display: 'flex', flexDirection: 'column', padding: '12px 0' },
        adultsSection: { display: 'flex', flexDirection: 'column', gap: '4px' },
        childrenDivider: { height: '1px', backgroundColor: colors.border, margin: '16px 0' },
        childrenNamesSection: { display: 'flex', flexDirection: 'column', gap: '4px' },
        swipeButtons: { display: 'flex', justifyContent: 'center', gap: '24px', marginTop: '16px' },
        swipeButton: { width: '56px', height: '56px', borderRadius: '28px', background: colors.cardBgGradient || colors.cardBg, border: `1px solid ${colors.border}`, fontSize: '22px', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', color: colors.text, boxShadow: colors.cardShadow },
        swipeHint: { textAlign: 'center', color: colors.textTertiary, fontSize: '14px', marginTop: '12px', fontWeight: '500' },
        calendar: { background: colors.cardBgGradient || colors.cardBg, borderRadius: '20px', padding: '20px', boxShadow: colors.cardShadow, border: `1px solid ${colors.border}` },
        calendarHeader: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' },
        calendarGrid: { display: 'grid', gridTemplateColumns: 'repeat(7, 1fr)', gap: '6px', textAlign: 'center' },
        calendarDay: { padding: '10px 4px', fontSize: '15px', borderRadius: '10px', fontWeight: '500' },
        calendarDayHeader: { fontSize: '12px', color: colors.textTertiary, fontWeight: '600', padding: '8px 4px', textTransform: 'uppercase' },
        prayedDay: { background: colors.accentGradient, color: '#FFF', fontWeight: '600' },
        navButton: { background: 'none', border: 'none', fontSize: '20px', cursor: 'pointer', padding: '8px 12px', color: colors.primary, fontWeight: '600' },
        greeting: { fontSize: '28px', fontWeight: '700', textAlign: 'center', marginTop: '32px', marginBottom: '8px', letterSpacing: '-0.5px' },
        subGreeting: { fontSize: '16px', color: colors.textSecondary, textAlign: 'center', marginBottom: '32px' },
        emptyState: { textAlign: 'center', color: colors.textSecondary, padding: '60px 20px', fontSize: '16px', lineHeight: '1.6' },
        sortRow: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', width: '100%', marginBottom: '12px' },
        sortDropdown: { position: 'relative', marginBottom: '12px' },
        sortTrigger: { padding: '10px 14px', paddingRight: '32px', fontSize: '14px', background: colors.secondary, border: `1px solid ${colors.border}`, borderRadius: '10px', color: colors.text, fontWeight: '500', fontFamily: 'inherit', outline: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '8px' },
        sortMenu: { position: 'absolute', top: '100%', left: 0, marginTop: '4px', background: colors.cardBg, border: `1px solid ${colors.border}`, borderRadius: '12px', boxShadow: colors.cardShadow, overflow: 'hidden', zIndex: 100, minWidth: '160px' },
        sortOption: { padding: '12px 16px', fontSize: '14px', color: colors.text, cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '10px', transition: 'background 0.15s ease' },
        sortOptionActive: { background: colors.primary + '20', color: colors.primary, fontWeight: '600' },
        reverseBtn: { width: '42px', height: '42px', fontSize: '16px', background: colors.secondary, border: `1px solid ${colors.border}`, borderRadius: '10px', color: colors.text, fontWeight: '500', fontFamily: 'inherit', outline: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center' },
        frequencyHeading: { fontSize: '11px', fontWeight: '700', color: colors.textTertiary, textTransform: 'uppercase', letterSpacing: '1px', padding: '16px 0 8px 4px' },
        modalOverlay: { position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000, padding: '20px', boxSizing: 'border-box' },
        modalContent: { background: colors.cardBgGradient || colors.cardBg, borderRadius: '20px', padding: '24px', maxWidth: '340px', width: '100%', boxShadow: '0 8px 40px rgba(0,0,0,0.4)', border: `1px solid ${colors.border}` },
        modalTitle: { fontSize: '18px', fontWeight: '700', marginBottom: '12px', textAlign: 'center', color: colors.text },
        modalMessage: { fontSize: '15px', color: colors.textSecondary, lineHeight: '1.5', marginBottom: '24px', textAlign: 'center' },
        modalButtons: { display: 'flex', gap: '12px' }
      };

      useEffect(() => { localStorage.setItem('prayerApp_people', JSON.stringify(people)); }, [people]);
      useEffect(() => { localStorage.setItem('prayerApp_cards', JSON.stringify(cards)); }, [cards]);
      useEffect(() => { if (session) localStorage.setItem('prayerApp_session', JSON.stringify(session)); }, [session]);

      // Update session rotation when cards are edited (e.g., frequency changed to daily)
      useEffect(() => {
        if (!session || session.dateStarted !== getToday()) return;
        
        // Find cards that are due today but not in the current rotation
        const currentRotation = session.cardsInRotation || [];
        const currentTodaysList = session.todaysList || [];
        
        // Check each active card to see if it should be added
        const cardsToAdd = cards.filter(c => {
          if (!c.active) return false;
          if (currentRotation.includes(c.id)) return false; // Already in rotation
          
          // Check if card is due today (simplified check for daily cards or new cards)
          if (c.frequency === 'daily') return true;
          if (!c.firstPrayerCompleted) return true; // New card never prayed for
          
          return false;
        }).map(c => c.id);
        
        if (cardsToAdd.length > 0) {
          setSession(prev => ({
            ...prev,
            cardsInRotation: [...prev.cardsInRotation, ...cardsToAdd],
            todaysList: [...prev.todaysList, ...cardsToAdd]
          }));
        }
      }, [cards, session?.dateStarted]);

      const loadDemoData = () => {
        const { people: dp, cards: dc } = generateDemoData();
        setPeople(dp); setCards(dc); setSession(null);
        localStorage.removeItem('prayerApp_session');
      };
      
      const toggleDemoMode = () => {
        if (demoMode) {
          // Turn off demo mode - clear data
          setPeople([]);
          setCards([]);
          setSession(null);
          setDemoMode(false);
          localStorage.setItem('prayerApp_demoMode', 'false');
        } else {
          // Turn on demo mode - load demo data
          loadDemoData();
          setDemoMode(true);
          localStorage.setItem('prayerApp_demoMode', 'true');
        }
      };
      
      const toggleAccordion = (id) => {
        setOpenAccordions(prev => ({ ...prev, [id]: !prev[id] }));
      };
      
      const capitalizeFirstLetter = (str) => {
        return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
      };
      
      const handleNameSubmit = () => {
        if (nameInput.trim()) {
          const capitalizedName = capitalizeFirstLetter(nameInput.trim());
          setUserName(capitalizedName);
          localStorage.setItem('prayerApp_userName', JSON.stringify(capitalizedName));
          setOnboardingStep(2);
        }
      };
      
      const completeOnboarding = (enableDemo) => {
        setOnboardingComplete(true);
        localStorage.setItem('prayerApp_onboardingComplete', 'true');
        if (enableDemo) {
          loadDemoData();
          setDemoMode(true);
          localStorage.setItem('prayerApp_demoMode', 'true');
        }
      };
      
      const openEditName = () => {
        setEditNameInput(userName);
        setEditingName(true);
      };
      
      const saveEditedName = () => {
        if (editNameInput.trim()) {
          const capitalizedName = capitalizeFirstLetter(editNameInput.trim());
          setUserName(capitalizedName);
          localStorage.setItem('prayerApp_userName', JSON.stringify(capitalizedName));
          setEditingName(false);
        }
      };
      
      const downloadData = () => {
        const exportData = {
          version: DATA_VERSION,
          exportDate: new Date().toISOString(),
          userName,
          people,
          cards,
          demoMode
        };
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `prayer-companion-backup-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        setDataModalOpen(false);
        setDataModalStep('main');
      };
      
      const handleFileUpload = (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            if (!data.version || !data.people || !data.cards) {
              alert('Invalid backup file. Please select a valid Prayer Companion backup.');
              return;
            }
            setPendingUploadData(data);
            setDataModalStep('confirmUpload');
          } catch (err) {
            alert('Could not read file. Please select a valid JSON backup file.');
          }
        };
        reader.readAsText(file);
        event.target.value = ''; // Reset file input
      };
      
      const confirmUpload = () => {
        if (!pendingUploadData) return;
        
        // Restore data
        setPeople(pendingUploadData.people || []);
        setCards(pendingUploadData.cards || []);
        setUserName(pendingUploadData.userName || '');
        setDemoMode(pendingUploadData.demoMode || false);
        setSession(null);
        
        // Save to localStorage
        localStorage.setItem('prayerApp_people', JSON.stringify(pendingUploadData.people || []));
        localStorage.setItem('prayerApp_cards', JSON.stringify(pendingUploadData.cards || []));
        localStorage.setItem('prayerApp_userName', JSON.stringify(pendingUploadData.userName || ''));
        localStorage.setItem('prayerApp_demoMode', pendingUploadData.demoMode ? 'true' : 'false');
        localStorage.removeItem('prayerApp_session');
        
        setPendingUploadData(null);
        setDataModalStep('main');
        setDataModalOpen(false);
      };
      
      const checkCardScroll = () => {
        const el = cardScrollRef.current;
        if (!el) return;
        const canScrollDown = el.scrollHeight > el.clientHeight && el.scrollTop < el.scrollHeight - el.clientHeight - 5;
        const canScrollUp = el.scrollTop > 5;
        setCardScrollState({ canScrollDown, canScrollUp });
      };
      
      React.useEffect(() => {
        checkCardScroll();
      }, [currentCardIndex, screen]);

      const isNewDay = useCallback(() => !session || session.dateStarted !== getToday(), [session]);
      const getLastPrayedDate = useCallback((card) => {
        const cp = card.peopleIds.map(id => people.find(p => p.id === id)).filter(Boolean);
        if (!cp.length) return null;
        const dates = cp.flatMap(p => p.prayerHistory || []);
        return dates.length ? dates.sort().reverse()[0] : null;
      }, [people]);
      const daysSinceLastPrayer = useCallback((card) => {
        const last = getLastPrayedDate(card);
        if (!last) return Infinity;
        return Math.floor((new Date(getToday()) - new Date(last)) / (1000 * 60 * 60 * 24));
      }, [getLastPrayedDate]);
      const isCardDueToday = useCallback((card) => {
        if (!card.active) return false;
        if (!card.firstPrayerCompleted) return true;
        
        const today = new Date();
        const dayOfWeek = today.getDay(); // 0-6 (Sun-Sat)
        const dayOfMonth = today.getDate(); // 1-31
        const days = daysSinceLastPrayer(card);
        
        if (card.frequency === 'daily') return true;
        
        if (card.frequency === 'every-2-3-days') {
          // Spread across 3-day cycles based on card ID
          const slot = getSlotFromId(card.id, 3);
          const todaySlot = dayOfMonth % 3;
          // Due on their slot day, or overdue (4+ days)
          return todaySlot === slot || days >= 4;
        }
        
        if (card.frequency === 'weekly') {
          // Each card assigned to a specific day of week
          const slot = getSlotFromId(card.id, 7);
          // Due on their assigned day, or overdue (9+ days as safety net)
          return dayOfWeek === slot || days >= 9;
        }
        
        if (card.frequency === 'monthly') {
          // Each card assigned to a specific day of month (1-28)
          const slot = getSlotFromId(card.id, 28) + 1; // 1-28
          const last = getLastPrayedDate(card);
          if (!last) return true;
          const lastDate = new Date(last);
          const prayedThisMonth = lastDate.getMonth() === today.getMonth() && lastDate.getFullYear() === today.getFullYear();
          // Due on their assigned day if not prayed this month, or if we've passed their day and still not prayed
          if (prayedThisMonth) return false;
          return dayOfMonth >= slot;
        }
        
        return true;
      }, [daysSinceLastPrayer, getLastPrayedDate]);
      const isPriorityCard = useCallback((card) => {
        if (!card.firstPrayerCompleted) return true;
        const days = daysSinceLastPrayer(card);
        // Priority = overdue past their normal window
        if (card.frequency === 'daily') return days >= 1;
        if (card.frequency === 'every-2-3-days') return days >= 4;
        if (card.frequency === 'weekly') return days >= 9;
        if (card.frequency === 'monthly') {
          // Priority if we're past day 28 and haven't prayed this month
          const today = new Date();
          const last = getLastPrayedDate(card);
          if (!last) return true;
          const lastDate = new Date(last);
          const prayedThisMonth = lastDate.getMonth() === today.getMonth() && lastDate.getFullYear() === today.getFullYear();
          return !prayedThisMonth && today.getDate() > 28;
        }
        return false;
      }, [daysSinceLastPrayer, getLastPrayedDate]);
      const buildTodaysList = useCallback(() => {
        const due = cards.filter(c => c.active && isCardDueToday(c));
        const shuffle = arr => { const a = [...arr]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; };
        return [...shuffle(due.filter(isPriorityCard)), ...shuffle(due.filter(c => !isPriorityCard(c)))].map(c => c.id);
      }, [cards, isCardDueToday, isPriorityCard]);

      const startPraying = () => {
        if (!cards.filter(c => c.active).length) { alert('Add some people first!'); return; }
        const list = buildTodaysList();
        if (!list.length) { alert('No prayers due today!'); return; }
        const checked = {};
        list.forEach(cid => {
          const card = cards.find(c => c.id === cid);
          if (card) {
            checked[cid] = {};
            card.peopleIds.forEach(pid => { const p = people.find(x => x.id === pid); if (p?.individualCheckbox) checked[cid][pid] = false; });
            checked[cid]['_group'] = false;
          }
        });
        setSession({ dateStarted: getToday(), todaysList: list, checkedStatus: checked, currentView: 'flashcard', cardsInRotation: [...list] });
        setCurrentCardIndex(0);
        setScreen('prayer');
      };

      // Helper to get dates from prayer history (handles both old string[] and new object[] formats)
      const getHistoryDates = (history) => {
        if (!history) return [];
        return history.map(h => typeof h === 'string' ? h : h.date);
      };
      
      // Helper to check if a date exists in history
      const hasDateInHistory = (history, date) => getHistoryDates(history).includes(date);
      
      // Helper to get history entry for a specific date
      const getHistoryForDate = (history, date) => {
        if (!history) return null;
        const entry = history.find(h => (typeof h === 'string' ? h : h.date) === date);
        return typeof entry === 'string' ? { date: entry } : entry;
      };

      const toggleCheckbox = (cardId, key) => {
        if (!session) return;
        const newChecked = { ...session.checkedStatus };
        if (!newChecked[cardId]) newChecked[cardId] = {};
        const was = newChecked[cardId][key];
        newChecked[cardId][key] = !was;
        if (!was) {
          const card = cards.find(c => c.id === cardId);
          if (card) {
            const today = getToday();
            const toUpdate = key === '_group' ? card.peopleIds.filter(pid => { const p = people.find(x => x.id === pid); return p && !p.individualCheckbox; }) : [key];
            
            // Create prayer history snapshot with prayer points
            setPeople(prev => prev.map(p => {
              if (!toUpdate.includes(p.id)) return p;
              if (hasDateInHistory(p.prayerHistory, today)) return p;
              
              const historyEntry = {
                date: today,
                personPrayerPoint: p.prayerPoint || '',
                cardPrayerPoint: card.prayerPoint || '',
                cardName: card.name,
                cardId: card.id
              };
              
              return { ...p, prayerHistory: [...(p.prayerHistory || []), historyEntry] };
            }));
            
            if (!card.firstPrayerCompleted) setCards(prev => prev.map(c => c.id === cardId ? { ...c, firstPrayerCompleted: true } : c));
          }
        }
        const newSession = { ...session, checkedStatus: newChecked };
        setSession(newSession);
      };

      const isCardFullyChecked = (cardId, checked = session?.checkedStatus) => {
        if (!checked?.[cardId]) return false;
        const card = cards.find(c => c.id === cardId);
        if (!card) return false;
        
        for (const pid of card.peopleIds) { 
          const p = people.find(x => x.id === pid); 
          if (p?.individualCheckbox && !checked[cardId][pid]) return false; 
        }
        
        const hasGroupedPeople = card.peopleIds.some(pid => { 
          const p = people.find(x => x.id === pid); 
          return p && !p.individualCheckbox; 
        });
        
        if ((hasGroupedPeople || card.includeUnnamedChildren) && !checked[cardId]['_group']) return false;
        
        return true;
      };

      // Get all cards in rotation (including completed ones for display)
      const getAllCardsInRotation = () => session?.cardsInRotation || [];
      // Get only incomplete cards for counting
      const getIncompleteCards = () => (session?.cardsInRotation || []).filter(cid => !isCardFullyChecked(cid));
      const getIncompleteCount = () => getIncompleteCards().length;
      
      // Find the next incomplete card index, starting from a given index
      const findNextIncompleteIndex = (startIndex, direction = 1) => {
        const all = getAllCardsInRotation();
        if (all.length === 0) return -1;
        
        // Check all cards in the given direction
        for (let i = 1; i <= all.length; i++) {
          const idx = (startIndex + (i * direction) + all.length) % all.length;
          if (!isCardFullyChecked(all[idx])) {
            return idx;
          }
        }
        return -1; // All cards are complete
      };
      
      const swipeNext = () => { 
        const nextIdx = findNextIncompleteIndex(currentCardIndex, 1);
        if (nextIdx === -1) {
          // All done - switch to list view
          setSession(s => ({ ...s, currentView: 'list' }));
          return;
        }
        setSlideDirection('right');
        setCurrentCardIndex(nextIdx);
        setTimeout(() => setSlideDirection(null), 250);
      };
      
      const swipePrev = () => { 
        const prevIdx = findNextIncompleteIndex(currentCardIndex, -1);
        if (prevIdx === -1) {
          // All done - switch to list view
          setSession(s => ({ ...s, currentView: 'list' }));
          return;
        }
        setSlideDirection('left');
        setTimeout(() => setSlideDirection(null), 250);
        setCurrentCardIndex(prevIdx); 
      };

      // Touch/swipe handlers for mobile
      const handleTouchStart = (e) => {
        setTouchStart(e.touches[0].clientX);
      };
      
      const handleTouchEnd = (e) => {
        if (touchStart === null) return;
        const touchEnd = e.changedTouches[0].clientX;
        const diff = touchStart - touchEnd;
        const minSwipeDistance = 50; // minimum px to trigger swipe
        
        if (Math.abs(diff) > minSwipeDistance) {
          if (diff > 0) {
            swipeNext(); // swiped left = next
          } else {
            swipePrev(); // swiped right = prev
          }
        }
        setTouchStart(null);
      };

      // Keyboard navigation for desktop
      const handleKeyDown = useCallback((e) => {
        if (screen !== 'prayer' || session?.currentView === 'list') return;
        if (e.key === 'ArrowRight' || e.key === ' ') {
          e.preventDefault();
          swipeNext();
        } else if (e.key === 'ArrowLeft') {
          e.preventDefault();
          swipePrev();
        }
      }, [screen, session?.currentView]);
      
      useEffect(() => {
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [handleKeyDown]);
      
      // Keep card index in bounds
      useEffect(() => {
        const allCards = getAllCardsInRotation();
        if (allCards.length > 0 && currentCardIndex >= allCards.length) {
          setCurrentCardIndex(0);
        }
      }, [session?.cardsInRotation]);

      const addPerson = (data) => {
        const isOrg = !data.firstName && !data.lastName && data.organisation;
        const displayName = isOrg ? data.organisation : `${data.firstName} ${data.lastName}`.trim();
        const np = { id: generateId(), firstName: data.firstName, lastName: data.lastName, organisation: data.organisation || '', prayerPoint: data.prayerPoint || '', isChild: data.isChild || false, individualCheckbox: data.individualCheckbox !== false, prayerHistory: [], dateAdded: getToday(), firstPrayerCompleted: false };
        const nc = { id: generateId(), name: displayName, peopleIds: [np.id], frequency: data.frequency || 'daily', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: getToday(), firstPrayerCompleted: false };
        setPeople(prev => [...prev, np]); setCards(prev => [...prev, nc]);
      };
      const updatePerson = (pid, data) => {
        setPeople(prev => prev.map(p => p.id === pid ? { ...p, ...data } : p));
        const solo = cards.find(c => c.peopleIds.length === 1 && c.peopleIds[0] === pid && !c.isGroup);
        if (solo) {
          const isOrg = !data.firstName && !data.lastName && data.organisation;
          const displayName = isOrg ? data.organisation : `${data.firstName} ${data.lastName}`.trim();
          setCards(prev => prev.map(c => c.id === solo.id ? { ...c, name: displayName, frequency: data.frequency || c.frequency } : c));
        }
      };
      const deletePerson = (pid) => {
        setCards(prev => prev.map(c => ({ ...c, peopleIds: c.peopleIds.filter(id => id !== pid) })).filter(c => c.peopleIds.length || c.includeUnnamedChildren));
        setPeople(prev => prev.filter(p => p.id !== pid));
      };
      const createGroup = (data) => {
        if (data.checkboxOverrides) setPeople(prev => prev.map(p => data.checkboxOverrides[p.id] !== undefined ? { ...p, individualCheckbox: data.checkboxOverrides[p.id] } : p));
        setCards(prev => prev.filter(c => c.isGroup || !c.peopleIds.some(id => data.peopleIds.includes(id))));
        setCards(prev => [...prev, { id: generateId(), name: data.name, peopleIds: data.peopleIds, frequency: data.frequency, prayerPoint: data.prayerPoint || '', includeUnnamedChildren: data.includeUnnamedChildren || false, isGroup: true, active: true, dateCreated: getToday(), firstPrayerCompleted: false }]);
        setSelectedPeopleForGroup([]);
      };
      const updateCard = (cid, data) => setCards(prev => prev.map(c => c.id === cid ? { ...c, ...data } : c));
      const dissolveGroup = (cid) => {
        const card = cards.find(c => c.id === cid);
        if (!card?.isGroup) return;
        card.peopleIds.forEach(pid => { const p = people.find(x => x.id === pid); if (p) setCards(prev => [...prev, { id: generateId(), name: `${p.firstName} ${p.lastName}`.trim() || p.organisation, peopleIds: [pid], frequency: card.frequency, prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: getToday(), firstPrayerCompleted: true }]); });
        setCards(prev => prev.filter(c => c.id !== cid));
      };
      
      const removeFromGroup = (cardId, personId) => {
        const card = cards.find(c => c.id === cardId);
        if (!card) return;
        const person = people.find(p => p.id === personId);
        if (!person) return;
        
        const newCard = {
          id: generateId(),
          name: `${person.firstName} ${person.lastName}`.trim() || person.organisation,
          peopleIds: [personId],
          frequency: card.frequency,
          prayerPoint: '',
          includeUnnamedChildren: false,
          isGroup: false,
          active: true,
          dateCreated: getToday(),
          firstPrayerCompleted: true
        };
        
        const updatedPeopleIds = card.peopleIds.filter(id => id !== personId);
        
        if (updatedPeopleIds.length <= 1) {
          setCards(prev => {
            const withoutOld = prev.filter(c => c.id !== cardId);
            const remainingPersonId = updatedPeopleIds[0];
            const remainingPerson = people.find(p => p.id === remainingPersonId);
            if (remainingPerson) {
              return [...withoutOld, newCard, {
                id: generateId(),
                name: `${remainingPerson.firstName} ${remainingPerson.lastName}`.trim() || remainingPerson.organisation,
                peopleIds: [remainingPersonId],
                frequency: card.frequency,
                prayerPoint: card.prayerPoint,
                includeUnnamedChildren: false,
                isGroup: false,
                active: true,
                dateCreated: getToday(),
                firstPrayerCompleted: true
              }];
            }
            return [...withoutOld, newCard];
          });
          setEditingCard(null);
        } else {
          setCards(prev => prev.map(c => c.id === cardId ? { ...c, peopleIds: updatedPeopleIds } : c).concat(newCard));
          setEditingCard(prev => prev ? { ...prev, peopleIds: updatedPeopleIds } : null);
        }
      };
      const deleteCard = (cid) => {
        const card = cards.find(c => c.id === cid);
        if (!card) return;
        if (!card.isGroup) card.peopleIds.forEach(deletePerson);
        else dissolveGroup(cid);
        setCards(prev => prev.filter(c => c.id !== cid));
      };

      const frequencyOrder = ['daily', 'every-2-3-days', 'weekly', 'monthly'];
      const getPersonFrequency = (p) => { const c = cards.find(x => x.peopleIds.includes(p.id)); return c?.frequency || 'daily'; };
      const getSortedPeople = () => {
        let sorted = [...people].sort((a, b) => {
          if (sortBy === 'firstName') return a.firstName.localeCompare(b.firstName);
          if (sortBy === 'lastName') return (a.lastName || '').localeCompare(b.lastName || '');
          if (sortBy === 'frequency') {
            const freqA = frequencyOrder.indexOf(getPersonFrequency(a));
            const freqB = frequencyOrder.indexOf(getPersonFrequency(b));
            if (freqA !== freqB) return freqA - freqB;
            return a.firstName.localeCompare(b.firstName);
          }
          return 0;
        });
        return sortReversed ? sorted.reverse() : sorted;
      };
      const getSortedCards = () => [...cards].filter(c => c.isGroup).sort((a, b) => cardSortBy === 'name' ? a.name.localeCompare(b.name) : 0);
      const getPrayerCountThisMonth = (pid) => { 
        const p = people.find(x => x.id === pid); 
        if (!p) return 0; 
        const m = new Date().getMonth(), y = new Date().getFullYear(); 
        return getHistoryDates(p.prayerHistory).filter(d => { 
          const x = new Date(d); 
          return x.getMonth() === m && x.getFullYear() === y; 
        }).length; 
      };
      const formatFrequency = (f) => ({ daily: 'Daily', 'every-2-3-days': '2-3 days', weekly: 'Weekly', monthly: 'Monthly' }[f] || f);

      useEffect(() => { if (editingPerson) { const card = editingPerson.id ? cards.find(c => c.peopleIds.includes(editingPerson.id)) : null; setPersonForm({ firstName: editingPerson.firstName || '', lastName: editingPerson.lastName || '', organisation: editingPerson.organisation || '', prayerPoint: editingPerson.prayerPoint || '', frequency: card?.frequency || 'daily', isChild: editingPerson.isChild || false, individualCheckbox: editingPerson.individualCheckbox !== false }); } }, [editingPerson, cards]);
      useEffect(() => { if (editingCard) setCardForm({ name: editingCard.name || '', frequency: editingCard.frequency || 'daily', prayerPoint: editingCard.prayerPoint || '', includeUnnamedChildren: editingCard.includeUnnamedChildren || false }); }, [editingCard]);
      useEffect(() => { if (screen === 'createGroup') { setGroupStep(1); setGroupForm({ name: '', frequency: 'weekly', prayerPoint: '', includeUnnamedChildren: false }); setCheckboxOverrides({}); } }, [screen]);
      useEffect(() => { if (selectedPeopleForGroup.length) { const sel = people.filter(p => selectedPeopleForGroup.includes(p.id)); const surnames = [...new Set(sel.map(p => p.lastName).filter(Boolean))]; setGroupForm(f => ({ ...f, name: surnames.length === 1 && surnames[0] ? surnames[0] + 's' : '' })); } }, [selectedPeopleForGroup, people]);

      const renderPrayerCard = (cardId, isFullScreen = false) => {
        const card = cards.find(c => c.id === cardId);
        if (!card) return null;
        const cardPeople = card.peopleIds.map(id => people.find(p => p.id === id)).filter(Boolean);
        const adults = cardPeople.filter(p => !p.isChild), children = cardPeople.filter(p => p.isChild);
        const isSingle = cardPeople.length === 1 && !card.isGroup;
        const freq = formatFrequency(card.frequency);
        const checked = session?.checkedStatus?.[cardId] || {};
        
        const renderPrayerPoints = (text, centered = false) => {
          if (!text) return null;
          const points = text.split('\n').filter(p => p.trim());
          if (points.length === 0) return null;
          return (
            <div style={{ fontSize: '14px', color: colors.textSecondary, fontStyle: 'italic', textAlign: 'left', marginTop: '4px' }}>
              {points.map((point, i) => (
                <div key={i} style={{ display: 'flex', gap: '8px', marginBottom: '2px', justifyContent: centered ? 'center' : 'flex-start' }}>
                  <span style={{ color: colors.textTertiary }}></span>
                  <span>{point}</span>
                </div>
              ))}
            </div>
          );
        };
        
        if (!isFullScreen) {
          const allChecked = isCardFullyChecked(cardId);
          
          const individualPeople = cardPeople.filter(p => p.individualCheckbox);
          const groupedPeople = cardPeople.filter(p => !p.individualCheckbox);
          const hasGroupedItems = groupedPeople.length > 0 || card.includeUnnamedChildren;
          
          return (
            <div style={{ ...styles.card, padding: '12px 14px', marginBottom: '6px', opacity: allChecked ? 0.5 : 1 }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                <div style={{ flex: 1 }}>
                  {/* Adults / Individual checkboxes row */}
                  <div style={{ display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap' }}>
                    {individualPeople.map(p => {
                      const isChecked = checked[p.id] || false;
                      const isOrg = !p.firstName && !p.lastName && p.organisation;
                      const displayName = isOrg ? p.organisation : p.firstName;
                      return (
                        <div key={p.id} style={{ display: 'flex', alignItems: 'center', gap: '6px', cursor: 'pointer' }} onClick={() => toggleCheckbox(cardId, p.id)}>
                          <span style={{ width: '22px', height: '22px', borderRadius: '6px', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '12px', fontWeight: '700', color: '#FFF', background: isChecked ? colors.accentGradient : colors.checkboxBg }}>{isChecked && ''}</span>
                          <span style={{ fontSize: '15px', fontWeight: '500', fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</span>
                        </div>
                      );
                    })}
                  </div>
                  {/* Grouped children row */}
                  {hasGroupedItems && (
                    <div style={{ display: 'flex', alignItems: 'center', gap: '6px', cursor: 'pointer', marginTop: '6px' }} onClick={() => toggleCheckbox(cardId, '_group')}>
                      <span style={{ width: '20px', height: '20px', borderRadius: '5px', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '11px', fontWeight: '700', color: '#FFF', background: checked['_group'] ? colors.accentGradient : colors.checkboxBg }}>{checked['_group'] && ''}</span>
                      <span style={{ fontSize: '14px', fontWeight: '500', color: colors.textSecondary }}>
                        {groupedPeople.map(p => p.firstName).join(', ')}
                        {groupedPeople.length > 0 && card.includeUnnamedChildren ? ' and others' : ''}
                        {card.includeUnnamedChildren && groupedPeople.length === 0 ? 'Children' : ''}
                      </span>
                    </div>
                  )}
                </div>
                <div style={{ fontSize: '11px', color: colors.textTertiary, marginLeft: '8px', flexShrink: 0 }}>{freq}</div>
              </div>
            </div>
          );
        }
        
        const cardStyle = { ...styles.card, ...styles.cardFullScreen, paddingLeft: '12px', paddingRight: '12px' };
        const nameAlign = isSingle ? 'center' : 'flex-start';
        
        // Fixed sizes that work in both portrait and landscape
        const adultCheckboxSize = '36px';
        const childCheckboxSize = '28px';
        const adultFontSize = 'clamp(20px, 6vw, 28px)';
        const childFontSize = 'clamp(16px, 5vw, 22px)';
        const adultIndent = '52px'; // 36px checkbox + 16px margin
        const childIndent = '44px'; // 28px checkbox + 16px margin
        
        const renderName = (person, isChild = false) => {
          const isOrg = !person.firstName && !person.lastName && person.organisation;
          const name = isOrg ? person.organisation : (isChild ? person.firstName : `${person.firstName} ${person.lastName}`.trim());
          const isChecked = person.individualCheckbox ? (checked[person.id] || false) : (checked['_group'] || false);
          const nameFontSize = isChild ? childFontSize : adultFontSize;
          const checkboxSize = isChild ? childCheckboxSize : adultCheckboxSize;
          const checkFontSize = isChild ? '14px' : '18px';
          const contentIndent = isChild ? childIndent : adultIndent;
          return (
            <div key={person.id} style={{ marginBottom: '8px' }}>
              <div style={{ ...styles.nameRow, justifyContent: nameAlign }} onClick={() => toggleCheckbox(cardId, person.individualCheckbox ? person.id : '_group')}>
                <span style={{ ...styles.nameCheckbox, width: checkboxSize, height: checkboxSize, minWidth: checkboxSize, minHeight: checkboxSize, fontSize: checkFontSize, background: isChecked ? colors.accentGradient : colors.checkboxBg, boxShadow: isChecked ? '0 2px 10px rgba(110,196,159,0.5)' : 'none' }}>{isChecked && ''}</span>
                <span style={{ fontSize: nameFontSize, fontWeight: '600', marginLeft: '16px', fontStyle: isOrg ? 'italic' : 'normal', whiteSpace: 'nowrap' }}>{name}</span>
              </div>
              {person.organisation && !isOrg && <div style={{ fontSize: '14px', color: colors.textSecondary, fontStyle: 'italic', marginTop: '-2px', marginBottom: '2px', marginLeft: contentIndent, textAlign: 'left' }}>{person.organisation}</div>}
              {person.prayerPoint && <div style={{ marginLeft: contentIndent }}>{renderPrayerPoints(person.prayerPoint, false)}</div>}
            </div>
          );
        };

        if (isSingle) {
          const p = cardPeople[0];
          const isOrg = !p.firstName && !p.lastName && p.organisation;
          const name = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim();
          const isChecked = checked[p.id] || checked['_group'] || false;
          const prayerText = card.prayerPoint || p.prayerPoint;
          const singleCheckboxSize = '48px';
          const singleNameIndent = '66px'; // checkbox + 18px margin
          
          // Only reduce font size for long names (>18 chars), otherwise use default
          const isLongName = name.length > 18;
          const nameFontSize = isLongName ? 'clamp(16px, 5vw, 22px)' : 'clamp(24px, 8vw, 36px)';
          
          return (
            <div style={cardStyle}>
              <div style={styles.cardHeaderRow}><div></div><div style={styles.cardFrequency}>{freq}</div></div>
              <div style={styles.singlePersonContent}>
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start' }}>
                  <div style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }} onClick={() => toggleCheckbox(cardId, p.individualCheckbox ? p.id : '_group')}>
                    <span style={{ ...styles.nameCheckbox, width: singleCheckboxSize, height: singleCheckboxSize, minWidth: singleCheckboxSize, minHeight: singleCheckboxSize, fontSize: '24px', background: isChecked ? colors.accentGradient : colors.checkboxBg, boxShadow: isChecked ? '0 3px 12px rgba(110,196,159,0.5)' : 'none' }}>{isChecked && ''}</span>
                    <span style={{ fontSize: nameFontSize, fontWeight: '600', marginLeft: '18px', fontStyle: isOrg ? 'italic' : 'normal', whiteSpace: 'nowrap' }}>{name}</span>
                  </div>
                  {p.organisation && !isOrg && <div style={{ fontSize: '16px', color: colors.textSecondary, fontStyle: 'italic', marginTop: '4px', marginLeft: singleNameIndent }}>{p.organisation}</div>}
                  {prayerText && <div style={{ marginTop: '12px', marginLeft: singleNameIndent }}>{renderPrayerPoints(prayerText, false)}</div>}
                </div>
              </div>
            </div>
          );
        }

        // Separate individual vs grouped people
        const individualAdults = adults.filter(p => p.individualCheckbox);
        const individualChildren = children.filter(p => p.individualCheckbox);
        const groupedPeople = cardPeople.filter(p => !p.individualCheckbox);
        const hasGroupedRow = groupedPeople.length > 0 || card.includeUnnamedChildren;

        const renderGroupedRow = () => {
          const isChecked = checked['_group'] || false;
          const names = groupedPeople.map(p => p.firstName).filter(Boolean);
          let label = names.join(', ');
          if (card.includeUnnamedChildren) {
            label = label ? `${label} and others` : 'And children';
          }
          return (
            <div style={{ marginBottom: '8px' }}>
              <div style={{ ...styles.nameRow, justifyContent: nameAlign }} onClick={() => toggleCheckbox(cardId, '_group')}>
                <span style={{ ...styles.nameCheckbox, width: childCheckboxSize, height: childCheckboxSize, minWidth: childCheckboxSize, minHeight: childCheckboxSize, fontSize: '14px', background: isChecked ? colors.accentGradient : colors.checkboxBg, boxShadow: isChecked ? '0 2px 10px rgba(110,196,159,0.5)' : 'none' }}>{isChecked && ''}</span>
                <span style={{ fontSize: childFontSize, fontWeight: '600', marginLeft: '16px', color: colors.textSecondary, whiteSpace: 'nowrap' }}>{label}</span>
              </div>
            </div>
          );
        };

        // Compact 3-column name rendering for landscape (with prayer points under each name)
        const renderCompactName = (person, isChild = false) => {
          const isOrg = !person.firstName && !person.lastName && person.organisation;
          const name = isOrg ? person.organisation : (isChild ? person.firstName : `${person.firstName} ${person.lastName}`.trim());
          const isChecked = person.individualCheckbox ? (checked[person.id] || false) : (checked['_group'] || false);
          const compactCheckboxSize = isChild ? '22px' : '26px';
          const compactFontSize = isChild ? '14px' : '16px';
          const checkFontSize = isChild ? '11px' : '13px';
          return (
            <div key={person.id} style={{ marginBottom: '8px' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }} onClick={() => toggleCheckbox(cardId, person.individualCheckbox ? person.id : '_group')}>
                <span style={{ ...styles.nameCheckbox, width: compactCheckboxSize, height: compactCheckboxSize, minWidth: compactCheckboxSize, minHeight: compactCheckboxSize, fontSize: checkFontSize, background: isChecked ? colors.accentGradient : colors.checkboxBg, boxShadow: isChecked ? '0 2px 8px rgba(110,196,159,0.4)' : 'none' }}>{isChecked && ''}</span>
                <div style={{ display: 'flex', flexDirection: 'column' }}>
                  <span style={{ fontSize: compactFontSize, fontWeight: '600', fontStyle: isOrg ? 'italic' : 'normal', whiteSpace: 'nowrap' }}>{name}</span>
                  {person.organisation && !isOrg && <span style={{ fontSize: '11px', color: colors.textSecondary, fontStyle: 'italic' }}>{person.organisation}</span>}
                </div>
              </div>
              {person.prayerPoint && (
                <div style={{ fontSize: '12px', color: colors.textSecondary, fontStyle: 'italic', marginTop: '2px', marginLeft: `calc(${compactCheckboxSize} + 8px)` }}>
                  {person.prayerPoint.split('\n').filter(p => p.trim()).map((point, i) => (
                    <div key={i} style={{ display: 'flex', gap: '4px' }}>
                      <span style={{ color: colors.textTertiary }}></span>
                      <span>{point}</span>
                    </div>
                  ))}
                </div>
              )}
            </div>
          );
        };

        const renderCompactGroupedRow = () => {
          const isChecked = checked['_group'] || false;
          const names = groupedPeople.map(p => p.firstName).filter(Boolean);
          let label = names.join(', ');
          if (card.includeUnnamedChildren) {
            label = label ? `${label} and others` : 'And children';
          }
          return (
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', marginBottom: '6px' }} onClick={() => toggleCheckbox(cardId, '_group')}>
              <span style={{ ...styles.nameCheckbox, width: '22px', height: '22px', minWidth: '22px', minHeight: '22px', fontSize: '11px', background: isChecked ? colors.accentGradient : colors.checkboxBg, boxShadow: isChecked ? '0 2px 8px rgba(110,196,159,0.4)' : 'none' }}>{isChecked && ''}</span>
              <span style={{ fontSize: '14px', fontWeight: '600', color: colors.textSecondary, whiteSpace: 'nowrap' }}>{label}</span>
            </div>
          );
        };

        // Show children section if there are any children (individual or grouped) or includeUnnamedChildren
        const hasChildrenSection = individualChildren.length > 0 || children.length > 0 || card.includeUnnamedChildren;

        return (
          <div style={cardStyle}>
            <div className="card-header-row" style={styles.cardHeaderRow}><div style={styles.cardTitle}>{card.name}</div><div style={styles.cardFrequency}>{freq}</div></div>
            
            {/* Portrait layout - original with prayer points under each name */}
            <div className="portrait-only" style={{ flexDirection: 'column', padding: '12px 0', flex: 1, justifyContent: 'center' }}>
              {card.prayerPoint && <div style={{ marginBottom: '12px', marginLeft: adultIndent }}>{renderPrayerPoints(card.prayerPoint, false)}</div>}
              <div>
                {individualAdults.map(p => renderName(p, false))}
              </div>
              {hasChildrenSection && (
                <>
                  <div style={styles.childrenDivider}></div>
                  <div>
                    {individualChildren.map(c => renderName(c, true))}
                    {hasGroupedRow && renderGroupedRow()}
                  </div>
                </>
              )}
              {hasGroupedRow && !hasChildrenSection && renderGroupedRow()}
            </div>
            
            {/* Landscape layout - 3 columns with prayer points under each name */}
            <div className="landscape-only" style={{ flexDirection: 'column', paddingBottom: '12px', flex: 1, justifyContent: 'center' }}>
              {card.prayerPoint && <div style={{ marginBottom: '6px', fontSize: '12px', color: colors.textSecondary, fontStyle: 'italic' }}>{renderPrayerPoints(card.prayerPoint, false)}</div>}
              <div className="three-column-grid">
                {individualAdults.map(p => renderCompactName(p, false))}
              </div>
              {(individualChildren.length > 0 || (hasGroupedRow && children.length > 0) || card.includeUnnamedChildren) && (
                <>
                  <div style={styles.childrenDivider}></div>
                  <div className="three-column-grid">
                    {individualChildren.map(c => renderCompactName(c, true))}
                    {hasGroupedRow && renderCompactGroupedRow()}
                  </div>
                </>
              )}
              {hasGroupedRow && !hasChildrenSection && !children.length && !card.includeUnnamedChildren && renderCompactGroupedRow()}
            </div>
          </div>
        );
      };

      const renderModal = () => {
        if (!modal) return null;
        return (
          <div style={styles.modalOverlay} onClick={() => setModal(null)}>
            <div style={styles.modalContent} onClick={e => e.stopPropagation()}>
              <div style={styles.modalTitle}>{modal.title}</div>
              <div style={styles.modalMessage}>{modal.message}</div>
              <div style={styles.modalButtons}>
                <button style={{ ...styles.btnSecondary, flex: 1 }} onClick={() => setModal(null)}>Cancel</button>
                <button style={{ ...styles.btnPrimary, flex: 1, background: modal.danger ? colors.dangerGradient : colors.primaryGradient }} onClick={() => { modal.onConfirm(); setModal(null); }}>
                  {modal.confirmText || 'Confirm'}
                </button>
              </div>
            </div>
          </div>
        );
      };
      
      const renderOnboarding = () => {
        if (onboardingStep === 1) {
          return (
            <div className="onboarding-overlay">
              <div className="onboarding-card">
                <div className="onboarding-title">Welcome to Prayer Companion</div>
                <div className="onboarding-text">
                  A simple way to remember and organize your daily prayers for the people you care about.
                </div>
                <input
                  className="onboarding-input"
                  type="text"
                  placeholder="Enter your first name"
                  value={nameInput}
                  onChange={(e) => setNameInput(e.target.value)}
                  onKeyDown={(e) => e.key === 'Enter' && handleNameSubmit()}
                  autoFocus
                />
                <button 
                  className="onboarding-btn onboarding-btn-primary"
                  onClick={handleNameSubmit}
                  disabled={!nameInput.trim()}
                  style={{ opacity: nameInput.trim() ? 1 : 0.5 }}
                >
                  Continue
                </button>
                <div className="onboarding-hint">
                  You can change your name anytime by tapping the edit icon next to your greeting.
                </div>
              </div>
            </div>
          );
        }
        
        return (
          <div className="onboarding-overlay">
            <div className="onboarding-card">
              <div className="onboarding-title">Hi, {userName}!</div>
              <div className="onboarding-text">
                Would you like to start with some demo content? This will add sample people and prayer groups so you can explore how the app works.
              </div>
              <button 
                className="onboarding-btn onboarding-btn-primary"
                onClick={() => completeOnboarding(true)}
              >
                Yes, show me a demo
              </button>
              <button 
                className="onboarding-btn onboarding-btn-secondary"
                onClick={() => completeOnboarding(false)}
              >
                No, I'll start fresh
              </button>
              <div className="onboarding-hint">
                You can toggle demo mode anytime using the "D" button on the home screen.
              </div>
            </div>
          </div>
        );
      };
      
      const renderHelp = () => {
        const helpSections = [
          {
            id: 'getting-started',
            title: 'Getting Started',
            content: (
              <>
                <p>Welcome to Prayer Companion! This app helps you organize and track your daily prayers for the people you care about.</p>
                <ul>
                  <li><strong>Add people</strong> you want to pray for</li>
                  <li><strong>Create groups</strong> for families or communities</li>
                  <li><strong>Set prayer frequencies</strong> (daily, weekly, monthly)</li>
                  <li><strong>Track your prayers</strong> with checkboxes and history</li>
                </ul>
                <div className="help-tip">Tip: Use Demo Mode from the menu to explore the app with sample data!</div>
              </>
            )
          },
          {
            id: 'adding-people',
            title: 'Adding People',
            content: (
              <>
                <p>Tap <strong>"Add Person"</strong> on the home screen to add someone to your prayer list.</p>
                <ul>
                  <li><strong>Name:</strong> Enter their first and last name</li>
                  <li><strong>Organisation:</strong> Optional - their church, workplace, etc.</li>
                  <li><strong>Prayer Points:</strong> Specific things to pray for (one per line)</li>
                  <li><strong>Frequency:</strong> How often to pray for them</li>
                  <li><strong>Is Child:</strong> Mark if they're a child (affects display)</li>
                </ul>
              </>
            )
          },
          {
            id: 'creating-groups',
            title: 'Creating Groups',
            content: (
              <>
                <p>Groups let you pray for multiple people together, like a family.</p>
                <ul>
                  <li>Tap <strong>"Create Group"</strong> and give it a name</li>
                  <li>Select the people to include</li>
                  <li>Choose if each person has an individual checkbox or one for all</li>
                  <li><strong>"Include unnamed children"</strong> adds a catch-all for kids you haven't added individually</li>
                </ul>
                <div className="help-tip">Tip: People in a group won't appear as separate cards - they'll only show in the group.</div>
              </>
            )
          },
          {
            id: 'prayer-frequencies',
            title: 'Prayer Frequencies',
            content: (
              <>
                <p>Choose how often someone appears in your prayers:</p>
                <ul>
                  <li><strong>Daily:</strong> Every day</li>
                  <li><strong>Semi-daily:</strong> Every other day</li>
                  <li><strong>Every 2-3 days:</strong> Spreads out evenly across the week</li>
                  <li><strong>Weekly:</strong> Once a week, distributed evenly</li>
                  <li><strong>Monthly:</strong> Once a month, spread across the month</li>
                </ul>
                <p>Weekly and monthly people are automatically distributed so you don't have everyone on the same day.</p>
              </>
            )
          },
          {
            id: 'praying',
            title: 'Daily Prayer Time',
            content: (
              <>
                <p>Tap <strong>"Start Praying"</strong> to begin your daily prayer session.</p>
                <ul>
                  <li><strong>Swipe left/right</strong> or use arrow buttons to navigate cards</li>
                  <li><strong>Tap checkboxes</strong> to mark prayers as complete</li>
                  <li>Completed cards are removed from rotation when you swipe away</li>
                  <li>Tap <strong>"List"</strong> to see all today's prayers at once</li>
                </ul>
                <div className="help-tip">Tip: Your progress is saved automatically - you can close and return anytime!</div>
              </>
            )
          },
          {
            id: 'managing',
            title: 'Managing & History',
            content: (
              <>
                <p>Use the bottom navigation to access:</p>
                <ul>
                  <li><strong>Manage:</strong> Edit, delete, or deactivate people and groups</li>
                  <li><strong>History:</strong> View your prayer history by person or group</li>
                </ul>
                <p>Tap any person or group to see details. In History, you can view a calendar showing which days you prayed and what prayer points were used.</p>
              </>
            )
          },
          {
            id: 'backup',
            title: 'Backup & Restore',
            content: (
              <>
                <p>Your prayer data is stored on your device. To keep it safe:</p>
                <ul>
                  <li>Tap the <strong> button</strong> at the top of the home screen</li>
                  <li><strong>Download Backup</strong> saves a file to your device</li>
                  <li><strong>Restore from Backup</strong> loads a previously saved file</li>
                </ul>
                <p><strong>When to backup:</strong></p>
                <ul>
                  <li>Before clearing your browser cache or data</li>
                  <li>Before switching devices</li>
                  <li>Periodically, to protect against data loss</li>
                </ul>
                <div className="help-tip">Tip: Store your backup file in cloud storage (iCloud, Google Drive) for extra safety.</div>
              </>
            )
          }
        ];
        
        return (
          <div className="app-container" style={styles.container}>
            <div className="app-header">
              <button style={styles.btnText} onClick={() => setHelpOpen(false)}> Back</button>
            </div>
            <div className="page-title">How to Use</div>
            <div style={{ maxHeight: 'calc(100vh - 140px)', overflowY: 'auto', paddingBottom: '20px' }}>
              {helpSections.map(section => (
                <div key={section.id} className="help-section">
                  <div className="help-accordion">
                    <div className="help-accordion-header" onClick={() => toggleAccordion(section.id)}>
                      <span className="help-accordion-title">{section.title}</span>
                      <span className={`help-accordion-icon ${openAccordions[section.id] ? 'open' : ''}`}></span>
                    </div>
                    <div className={`help-accordion-content ${openAccordions[section.id] ? 'open' : ''}`}>
                      <div className="help-accordion-body">
                        {section.content}
                      </div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        );
      };

      const renderHome = () => {
        const showContinue = session && !isNewDay();
        const todaysCards = cards.filter(c => c.active && isCardDueToday(c));
        const count = todaysCards.length;
        return (
          <div className="app-container" style={{ ...styles.container, position: 'relative', display: 'flex', flexDirection: 'column', height: '100vh', paddingBottom: '60px', overflow: 'hidden' }}>
            
            {/* Top row with info, sync, and demo buttons */}
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
              <button className="home-circle-btn" onClick={() => setHelpOpen(true)} title="How to Use">i</button>
              <button className="home-circle-btn symbol" onClick={() => { setDataModalOpen(true); setDataModalStep('main'); }} title="Backup & Restore"></button>
              <button className={`home-circle-btn ${demoMode ? 'active' : ''}`} onClick={toggleDemoMode} title="Demo Mode">D</button>
            </div>
            
            {/* Greeting - now below buttons */}
            {(() => {
              const greetingText = showContinue ? 'Welcome back' : getGreeting(userName || 'Friend');
              // Adjust font size based on text length to prevent line breaks
              const greetingLength = greetingText.length;
              const greetingFontSize = greetingLength > 24 ? '18px' : greetingLength > 20 ? '20px' : greetingLength > 16 ? '22px' : '24px';
              const landscapeFontSize = greetingLength > 24 ? '16px' : greetingLength > 20 ? '17px' : greetingLength > 16 ? '18px' : '20px';
              return (
                <>
                  <div className="home-greeting" style={{ textAlign: 'center', marginBottom: '8px' }}>
                    <div className="home-welcome" style={{ ...styles.greeting, fontSize: greetingFontSize, marginTop: 0, marginBottom: '2px', whiteSpace: 'nowrap' }}>
                      {greetingText}
                      <button className="edit-name-btn" onClick={openEditName} title="Edit name"></button>
                    </div>
                    <div className="home-subtext" style={{ ...styles.subGreeting, fontSize: '14px', marginBottom: '0' }}>{count ? `${count} prayer${count !== 1 ? 's' : ''} for today` : 'No prayers scheduled'}</div>
                  </div>
                  
                  {/* Header row for landscape - greeting */}
                  <div className="home-header-row" style={{ display: 'none', paddingTop: '4px', marginBottom: '8px' }}>
                    <div className="home-greeting-text">
                      <span style={{ fontSize: landscapeFontSize, fontWeight: '700', color: colors.text, whiteSpace: 'nowrap' }}>
                        {greetingText}
                        <button className="edit-name-btn" onClick={openEditName} title="Edit name"></button>
                      </span>
                      <span style={{ fontSize: '14px', color: colors.textSecondary }}>{count ? `${count} prayer${count !== 1 ? 's' : ''} for today` : 'No prayers scheduled'}</span>
                    </div>
                  </div>
                </>
              );
            })()}
            
            {/* Main content - two columns in landscape */}
            <div className="home-content">
              {/* Left column: Start button only in landscape */}
              <div className="home-left">
                {/* Spacer to push content down (portrait only) */}
                <div className="home-spacer-top" style={{ flex: '0 0 auto', minHeight: '8px', maxHeight: '20px' }} />
                
{/* Circular Start Praying button */}
                 <div className="home-start-btn-wrapper home-start-wrapper" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', padding: '16px 0', marginBottom: '16px' }}>
                   <button 
                     className="home-start-btn"
                     style={{
                       width: '130px',
                       height: '130px',
                       borderRadius: '50%',
                       background: colors.primaryGradient,
                       border: 'none',
                       boxShadow: `0 8px 32px rgba(184,122,74,0.4), 0 4px 12px rgba(184,122,74,0.3), inset 0 2px 0 rgba(255,255,255,0.2)`,
                       color: colors.primaryText,
                       fontSize: '17px',
                       fontWeight: '700',
                       cursor: 'pointer',
                       fontFamily: 'inherit',
                       display: 'flex',
                       alignItems: 'center',
                       justifyContent: 'center',
                       textAlign: 'center',
                       lineHeight: '1.2',
                       padding: '16px',
                       transition: 'transform 0.15s ease, box-shadow 0.15s ease'
                     }}
                     onClick={showContinue ? () => setScreen('prayer') : startPraying}
                   >
                     {showContinue ? 'Continue\nPraying' : 'Start\nPraying'}
                   </button>
                 </div>
                 
                 {/* Action buttons stacked (portrait only) */}
                 <div className="home-actions-portrait" style={{ flexDirection: 'column', alignItems: 'center', gap: '10px' }}>
                   <button 
                     className="home-action-btn"
                     style={{ ...styles.btnSecondary, width: '180px', padding: '11px 16px', fontSize: '14px' }} 
                     onClick={() => setEditingPerson({})}
                   >
                     + Add Person
                   </button>
                   <button 
                     className="home-action-btn"
                     style={{ ...styles.btnSecondary, width: '180px', padding: '11px 16px', fontSize: '14px' }} 
                     onClick={() => setScreen('createGroup')}
                   >
                     Create Group
                   </button>
                 </div>
                 
                 {/* Divider line (portrait only) - adjust marginTop and marginBottom here */}
                 <div className="home-portrait-divider" style={{ width: '80%', maxWidth: '280px', height: '1px', background: colors.border, marginTop: '40px', marginBottom: '28px', marginLeft: 'auto', marginRight: 'auto' }} />
                 
                 {/* Spacer (portrait only) */}
                 <div className="home-spacer-bottom" style={{ flex: '1 1 auto', minHeight: '8px', maxHeight: '20px' }} />
              </div>
              
              {/* Separator line (landscape only) */}
              <div className="home-separator"></div>
              
              {/* Right column: Today's prayers only */}
              <div className="home-right">
                <div className="home-right-content">
                  <div className="home-prayers-heading" style={{ fontSize: '11px', fontWeight: '700', color: colors.textTertiary, textTransform: 'uppercase', letterSpacing: '1px', marginBottom: '10px', textAlign: 'center' }}>Today's Prayers</div>
                  {!count ? (
                    <div className="home-prayers-list" style={{ color: colors.textTertiary, fontSize: '13px', textAlign: 'center' }}>No prayers due today</div>
                  ) : (
                    <div className="home-prayers-list" style={{ fontSize: '13px', color: colors.textSecondary, lineHeight: '1.9', textAlign: 'center' }}>
                      {todaysCards.map((card, idx) => {
                        const isComplete = session?.checkedStatus?.[card.id] && isCardFullyChecked(card.id);
                        return (
                          <span key={card.id}>
                            <span style={{ 
                              color: isComplete ? colors.accent : colors.text,
                              textDecoration: isComplete ? 'line-through' : 'none',
                              opacity: isComplete ? 0.6 : 1
                            }}>
                              {card.name}
                            </span>
                            {idx < todaysCards.length - 1 && <span style={{ color: colors.textTertiary }}>  </span>}
                          </span>
                        );
                      })}
                    </div>
                  )}
                </div>
              </div>
            </div>
            
{/* Fixed bottom navigation tabs */}
             <div className="bottom-nav" style={{
               position: 'fixed',
               bottom: 0,
               left: 0,
               right: 0,
               background: colors.cardBg,
               borderTop: `1px solid ${colors.border}`,
               display: 'flex',
               margin: '0 auto',
               boxShadow: '0 -4px 20px rgba(0,0,0,0.08)'
             }}>
               <button 
                 style={{
                   flex: 1,
                   padding: '14px 8px',
                   paddingBottom: 'max(14px, env(safe-area-inset-bottom))',
                   fontSize: '13px',
                   fontWeight: '600',
                   background: 'transparent',
                   border: 'none',
                   borderRight: `1px solid ${colors.border}`,
                   color: colors.textSecondary,
                   cursor: 'pointer',
                   fontFamily: 'inherit',
                   whiteSpace: 'nowrap'
                 }} 
                 onClick={() => setScreen('manage')}
               >
                 Manage People & Groups
               </button>
               <button 
                 style={{
                   flex: 1,
                   padding: '14px 8px',
                   paddingBottom: 'max(14px, env(safe-area-inset-bottom))',
                   fontSize: '13px',
                   fontWeight: '600',
                   background: 'transparent',
                   border: 'none',
                   color: colors.textSecondary,
                   cursor: 'pointer',
                   fontFamily: 'inherit',
                   whiteSpace: 'nowrap'
                 }} 
                 onClick={() => setScreen('stats')}
               >
                 Prayer History
               </button>
             </div>
             
             {/* Edit name modal */}
             {editingName && (
               <div className="edit-name-overlay" onClick={() => setEditingName(false)}>
                 <div className="edit-name-modal" onClick={(e) => e.stopPropagation()}>
                   <h3>Edit Your Name</h3>
                   <input
                     className="onboarding-input"
                     type="text"
                     placeholder="Enter your first name"
                     value={editNameInput}
                     onChange={(e) => setEditNameInput(e.target.value)}
                     onKeyDown={(e) => e.key === 'Enter' && saveEditedName()}
                     autoFocus
                   />
                   <div style={{ display: 'flex', gap: '12px' }}>
                     <button 
                       className="onboarding-btn onboarding-btn-secondary"
                       style={{ flex: 1, marginBottom: 0 }}
                       onClick={() => setEditingName(false)}
                     >
                       Cancel
                     </button>
                     <button 
                       className="onboarding-btn onboarding-btn-primary"
                       style={{ flex: 1, marginBottom: 0, opacity: editNameInput.trim() ? 1 : 0.5 }}
                       onClick={saveEditedName}
                       disabled={!editNameInput.trim()}
                     >
                       Save
                     </button>
                   </div>
                 </div>
               </div>
             )}
             
             {/* Data backup/restore modal */}
             {dataModalOpen && (
               <div className="data-modal-overlay" onClick={() => { setDataModalOpen(false); setDataModalStep('main'); setPendingUploadData(null); }}>
                 <div className="data-modal" onClick={(e) => e.stopPropagation()}>
                   {dataModalStep === 'main' ? (
                     <>
                       <h3>Backup & Restore</h3>
                       <div className="data-modal-desc">
                         Download a backup of your prayer list to keep it safe, or restore from a previous backup.
                       </div>
                       <button className="data-modal-btn data-modal-btn-download" onClick={downloadData}>
                         <span></span> Download Backup
                       </button>
                       <label className="data-modal-btn data-modal-btn-upload" style={{ cursor: 'pointer' }}>
                         <span></span> Restore from Backup
                         <input 
                           type="file" 
                           accept=".json"
                           style={{ display: 'none' }}
                           onChange={handleFileUpload}
                         />
                       </label>
                       <button className="data-modal-btn data-modal-btn-cancel" onClick={() => setDataModalOpen(false)}>
                         Cancel
                       </button>
                     </>
                   ) : (
                     <>
                       <h3>Confirm Restore</h3>
                       <div className="data-modal-warning">
                         <strong>Warning:</strong> This will replace all your current prayer data with the backup. Any changes you've made since this backup will be lost.
                       </div>
                       <div className="data-modal-desc" style={{ marginBottom: '16px' }}>
                         Backup from: {pendingUploadData?.exportDate ? new Date(pendingUploadData.exportDate).toLocaleDateString() : 'Unknown date'}
                         <br />
                         Contains: {pendingUploadData?.people?.length || 0} people, {pendingUploadData?.cards?.length || 0} cards
                       </div>
                       <button className="data-modal-btn data-modal-btn-download" onClick={confirmUpload}>
                         Yes, Restore This Backup
                       </button>
                       <button className="data-modal-btn data-modal-btn-cancel" onClick={() => { setDataModalStep('main'); setPendingUploadData(null); }}>
                         Cancel
                       </button>
                     </>
                   )}
                 </div>
               </div>
             )}
          </div>
        );
      };

      const renderPrayer = () => {
        const allCards = getAllCardsInRotation();
        const incompleteCount = getIncompleteCount();
        const allDone = incompleteCount === 0;
        const showList = session?.currentView === 'list' || allDone;
        
        if (showList) return (
          <div className="app-container" style={styles.container}>
            <div className="app-header">
              <button style={styles.btnText} onClick={() => setScreen('home')}> Home</button>
              {!allDone && <button style={styles.btnText} onClick={() => setSession(s => ({ ...s, currentView: 'flashcard' }))}>Cards</button>}
            </div>
            <div className="page-title">{allDone ? 'All prayers complete' : "Today's Prayers"}</div>
            <div className="two-column-grid" style={{ maxHeight: 'calc(100vh - 140px)', overflowY: 'auto', padding: '4px 6px', margin: '0 -6px' }}>
              {session?.todaysList.map(cid => <div key={cid}>{renderPrayerCard(cid, false)}</div>)}
            </div>
          </div>
        );
        
        const cid = allCards[currentCardIndex % allCards.length];
        const currentCardComplete = isCardFullyChecked(cid);
        const isLastIncomplete = incompleteCount <= 1 && !currentCardComplete;
        const noMoreIncomplete = incompleteCount === 0 || (incompleteCount === 1 && currentCardComplete);
        const disabledBtnStyle = { ...styles.swipeButton, opacity: 0.3, cursor: 'default' };
        
        // Determine hint text
        let hintText;
        if (currentCardComplete) {
          hintText = 'Complete! Swipe for next';
        } else if (isLastIncomplete) {
          hintText = 'Last card';
        } else {
          hintText = `${incompleteCount} remaining`;
        }
        
        return (
          <div className="prayer-view-container" style={{ fontFamily: "'Open Sans', -apple-system, BlinkMacSystemFont, sans-serif", background: colors.bgGradient, color: colors.text, margin: '0 auto', maxWidth: 'none', width: '100%' }}>
            <div className="app-header" style={{ flexShrink: 0 }}>
              <button style={styles.btnText} onClick={() => setScreen('home')}> Home</button>
              <button style={styles.btnText} onClick={() => setSession(s => ({ ...s, currentView: 'list' }))}>List</button>
            </div>
            <div 
              ref={cardScrollRef}
              className={`prayer-card-area ${slideDirection === 'right' ? 'card-slide-right' : slideDirection === 'left' ? 'card-slide-left' : ''}`}
              onTouchStart={handleTouchStart} 
              onTouchEnd={handleTouchEnd}
              onScroll={checkCardScroll}
              style={{ touchAction: 'pan-y', position: 'relative' }}
              key={cid}
            >
              {renderPrayerCard(cid, true)}
              {(cardScrollState.canScrollDown || cardScrollState.canScrollUp) && (
                <div className={`scroll-indicator`} style={{ position: 'sticky', bottom: 0, marginLeft: 'auto', marginTop: '-24px' }}>
                  {cardScrollState.canScrollDown ? '' : ''}
                </div>
              )}
            </div>
            <div className="prayer-nav-area">
              <div style={styles.swipeButtons}>
                <button style={noMoreIncomplete ? disabledBtnStyle : styles.swipeButton} onClick={noMoreIncomplete ? undefined : swipePrev} disabled={noMoreIncomplete}></button>
                <button style={noMoreIncomplete ? disabledBtnStyle : styles.swipeButton} onClick={noMoreIncomplete ? undefined : swipeNext} disabled={noMoreIncomplete}></button>
              </div>
              <div style={styles.swipeHint}>{hintText}  swipe or use arrows</div>
            </div>
          </div>
        );
      };

      const renderManage = () => {
        const renderPeopleList = () => {
          if (!people.length) return <div style={styles.emptyState}>No people yet. Tap + to add.</div>;
          return (() => {
              const sorted = getSortedPeople();
              const listItemStyle = { ...styles.listItem, marginBottom: 0 };
              
              if (sortBy !== 'frequency') {
                return (
                  <div className="two-column-grid">
                    {sorted.map(p => { 
                      const c = cards.find(x => x.peopleIds.includes(p.id)); 
                      const isGrouped = c?.isGroup; 
                      const isOrg = !p.firstName && !p.lastName && p.organisation; 
                      const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim(); 
                      return (
                        <div key={p.id} style={listItemStyle} onClick={() => setEditingPerson(p)}>
                          <div style={{ flex: 1 }}>
                            <div style={{ ...styles.listItemName, fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}{p.organisation && !isOrg && <span style={{ fontSize: '12px', color: colors.textTertiary, fontStyle: 'italic', fontWeight: 'normal' }}>  {p.organisation}</span>}{p.isChild && <span style={{ color: colors.textTertiary, fontSize: '12px' }}> (child)</span>}</div>
                            {isGrouped && <div style={{ fontSize: '12px', color: colors.primary, marginTop: '2px' }}> {c.name}</div>}
                          </div>
                          <div style={{ fontSize: '12px', color: colors.textTertiary, textAlign: 'right', whiteSpace: 'nowrap' }}>{formatFrequency(c?.frequency)}  {getPrayerCountThisMonth(p.id)}</div>
                        </div>
                      ); 
                    })}
                  </div>
                );
              }
              // Frequency grouping
              const groups = {};
              sorted.forEach(p => {
                const freq = getPersonFrequency(p);
                if (!groups[freq]) groups[freq] = [];
                groups[freq].push(p);
              });
              const orderedFreqs = sortReversed ? [...frequencyOrder].reverse() : frequencyOrder;
              return orderedFreqs.map((freq) => {
                if (!groups[freq] || !groups[freq].length) return null;
                return (
                  <div key={freq}>
                    <div style={styles.frequencyHeading}>{formatFrequency(freq)}</div>
                    <div className="two-column-grid">
                      {groups[freq].map(p => {
                        const c = cards.find(x => x.peopleIds.includes(p.id));
                        const isGrouped = c?.isGroup;
                        const isOrg = !p.firstName && !p.lastName && p.organisation;
                        const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim();
                        return (
                          <div key={p.id} style={listItemStyle} onClick={() => setEditingPerson(p)}>
                            <div style={{ flex: 1 }}>
                              <div style={{ ...styles.listItemName, fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}{p.organisation && !isOrg && <span style={{ fontSize: '12px', color: colors.textTertiary, fontStyle: 'italic', fontWeight: 'normal' }}>  {p.organisation}</span>}{p.isChild && <span style={{ color: colors.textTertiary, fontSize: '12px' }}> (child)</span>}</div>
                              {isGrouped && <div style={{ fontSize: '12px', color: colors.primary, marginTop: '2px' }}> {c.name}</div>}
                            </div>
                            <div style={{ fontSize: '12px', color: colors.textTertiary, textAlign: 'right', whiteSpace: 'nowrap' }}>{getPrayerCountThisMonth(p.id)}</div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              });
            })();
        };
        
        const renderGroupsList = () => {
          if (!getSortedCards().length) return <div style={styles.emptyState}>No groups yet.<br/>Use "Create Group" to combine people.</div>;
          return (() => {
              const sortedCards = getSortedCards();
              const listItemStyle = { ...styles.listItem, marginBottom: 0 };
              
              if (cardSortBy !== 'frequency') {
                return (
                  <div className="two-column-grid">
                    {sortedCards.map(c => { 
                      const count = c.peopleIds.length; 
                      return (
                        <div key={c.id} style={listItemStyle} onClick={() => setEditingCard(c)}>
                          <div style={styles.listItemName}>{c.name}</div>
                          <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '2px' }}>{count} {count === 1 ? 'person' : 'people'}</div>
                          <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '4px' }}>{formatFrequency(c.frequency)}</div>
                        </div>
                      );
                    })}
                  </div>
                );
              }
              // Frequency grouping
              const groups = {};
              sortedCards.forEach(c => {
                if (!groups[c.frequency]) groups[c.frequency] = [];
                groups[c.frequency].push(c);
              });
              return frequencyOrder.map((freq) => {
                if (!groups[freq] || !groups[freq].length) return null;
                return (
                  <div key={freq}>
                    <div style={styles.frequencyHeading}>{formatFrequency(freq)}</div>
                    <div className="two-column-grid">
                      {groups[freq].map(c => {
                        const count = c.peopleIds.length;
                        return (
                          <div key={c.id} style={listItemStyle} onClick={() => setEditingCard(c)}>
                            <div style={styles.listItemName}>{c.name}</div>
                            <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '2px' }}>{count} {count === 1 ? 'person' : 'people'}</div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              });
            })();
        };
        
        const renderSortControls = (isPeople = true) => (
          <div className="sort-row" style={{ ...styles.sortRow, marginBottom: 0 }}>
            <div style={styles.sortDropdown}>
              <button style={styles.sortTrigger} onClick={() => setSortDropdownOpen(o => !o)}>
                {isPeople 
                  ? (sortBy === 'firstName' ? 'First Name' : sortBy === 'lastName' ? 'Last Name' : 'Frequency')
                  : (cardSortBy === 'name' ? 'Name' : 'Frequency')
                }
                <span style={{ marginLeft: 'auto', fontSize: '10px', opacity: 0.6 }}></span>
              </button>
              {sortDropdownOpen && (
                <>
                  <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} onClick={() => setSortDropdownOpen(false)} />
                  <div style={styles.sortMenu}>
                    {(isPeople 
                      ? [{ value: 'firstName', label: 'First Name' }, { value: 'lastName', label: 'Last Name' }, { value: 'frequency', label: 'Frequency' }]
                      : [{ value: 'name', label: 'Name' }, { value: 'frequency', label: 'Frequency' }]
                    ).map(opt => (
                      <div 
                        key={opt.value}
                        style={{ ...styles.sortOption, ...((isPeople ? sortBy : cardSortBy) === opt.value ? styles.sortOptionActive : {}) }}
                        onClick={() => { isPeople ? setSortBy(opt.value) : setCardSortBy(opt.value); setSortDropdownOpen(false); }}
                      >
                        <span style={{ width: '16px' }}>{(isPeople ? sortBy : cardSortBy) === opt.value ? '' : ''}</span>
                        {opt.label}
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
            <button style={styles.reverseBtn} onClick={() => setSortReversed(r => !r)}>{sortReversed ? '' : ''}</button>
          </div>
        );
        
        return (
          <div className="app-container" style={{ ...styles.container, display: 'flex', flexDirection: 'column', height: '100vh', overflow: 'hidden' }}>
            <div className="app-header">
              <button style={styles.btnText} onClick={() => setScreen('home')}> Back</button>
              {manageTab === 'people' && <button style={styles.btnText} onClick={() => setEditingPerson({})}>+ Add</button>}
            </div>
            
            {/* Portrait: Tabs stacked above sorting */}
            <div className="portrait-only">
              <div style={{ ...styles.tabs, marginBottom: '12px' }}>
                <button style={{ ...styles.tab, ...(manageTab === 'people' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setManageTab('people')}>People</button>
                <button style={{ ...styles.tab, ...(manageTab === 'cards' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setManageTab('cards')}>Groups</button>
              </div>
              {renderSortControls(manageTab === 'people')}
            </div>
            
            {/* Landscape: Tabs left, sorting right - same row */}
            <div className="landscape-only">
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px', gap: '12px' }}>
                <div style={{ ...styles.tabs, flex: '0 0 auto', width: '280px', marginBottom: 0 }}>
                  <button style={{ ...styles.tab, ...(manageTab === 'people' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setManageTab('people')}>People</button>
                  <button style={{ ...styles.tab, ...(manageTab === 'cards' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setManageTab('cards')}>Groups</button>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                  {renderSortControls(manageTab === 'people')}
                </div>
              </div>
            </div>
            
            {/* 2-column grid list */}
            <div className="two-column-list" style={{ flex: 1, overflowY: 'auto', padding: '4px 6px', margin: '0 -6px' }}>
              {manageTab === 'people' ? renderPeopleList() : renderGroupsList()}
            </div>
          </div>
        );
      };

      const renderEditPerson = () => {
        const isNew = !editingPerson?.id;
        const personCard = isNew ? null : cards.find(c => c.peopleIds.includes(editingPerson.id));
        const save = () => { 
          if (!personForm.firstName.trim() && !personForm.lastName.trim() && !personForm.organisation.trim()) { 
            alert('Enter a name or organisation'); 
            return; 
          } 
          if (isNew) addPerson(personForm); 
          else updatePerson(editingPerson.id, personForm); 
          setEditingPerson(null); 
        };
        const del = () => setModal({
          title: 'Delete person?',
          message: `This will remove ${personForm.firstName || personForm.organisation} and their prayer history permanently.`,
          confirmText: 'Delete',
          danger: true,
          onConfirm: () => { deletePerson(editingPerson.id); setEditingPerson(null); }
        });
        return (
          <div className="app-container" style={styles.container}>
            <div className="app-header"><button style={styles.btnText} onClick={() => setEditingPerson(null)}>Cancel</button><button style={styles.btnText} onClick={save}>Save</button></div>
            
            {!isNew && personCard && (
              <div 
                style={{ ...styles.card, padding: '14px 16px', marginBottom: '20px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', cursor: 'pointer' }}
                onClick={() => { setEditingPerson(null); setEditingCard(personCard); }}
              >
                <div>
                  <div style={{ fontSize: '12px', color: colors.textTertiary, marginBottom: '2px' }}>{personCard.isGroup ? 'PART OF GROUP' : 'PRAYER CARD'}</div>
                  <div style={{ fontSize: '16px', fontWeight: '600', color: colors.primary }}>{personCard.name}</div>
                </div>
                <div style={{ fontSize: '20px', color: colors.textTertiary }}></div>
              </div>
            )}
            
            <label style={styles.label}>First Name</label><input style={styles.input} value={personForm.firstName} onChange={e => setPersonForm({ ...personForm, firstName: e.target.value })} placeholder="First name" />
            <label style={styles.label}>Last Name</label><input style={styles.input} value={personForm.lastName} onChange={e => setPersonForm({ ...personForm, lastName: e.target.value })} placeholder="Last name" />
            <label style={styles.label}>Organisation / Ministry</label><input style={styles.input} value={personForm.organisation} onChange={e => setPersonForm({ ...personForm, organisation: e.target.value })} placeholder="Optional - e.g. OMF, City Youth" />
            <label style={styles.label}>Prayer Points</label><textarea style={{ ...styles.input, minHeight: '80px', resize: 'vertical' }} value={personForm.prayerPoint} onChange={e => setPersonForm({ ...personForm, prayerPoint: e.target.value })} placeholder="One per line" />
            <label style={styles.label}>Frequency</label>
            <div style={styles.sortDropdown}>
              <button type="button" style={styles.sortTrigger} onClick={() => setFreqDropdownOpen(!freqDropdownOpen)}>
                {{ daily: 'Daily', 'every-2-3-days': 'Every 2-3 Days', weekly: 'Weekly', monthly: 'Monthly' }[personForm.frequency]}
                <span style={{ marginLeft: 'auto', fontSize: '10px', opacity: 0.6 }}></span>
              </button>
              {freqDropdownOpen && (
                <>
                  <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} onClick={() => setFreqDropdownOpen(false)} />
                  <div style={styles.sortMenu}>
                    {[{ value: 'daily', label: 'Daily' }, { value: 'every-2-3-days', label: 'Every 2-3 Days' }, { value: 'weekly', label: 'Weekly' }, { value: 'monthly', label: 'Monthly' }].map(opt => (
                      <div key={opt.value} style={{ ...styles.sortOption, ...(personForm.frequency === opt.value ? styles.sortOptionActive : {}) }} onClick={() => { setPersonForm({ ...personForm, frequency: opt.value }); setFreqDropdownOpen(false); }}>
                        <span style={{ width: '16px' }}>{personForm.frequency === opt.value ? '' : ''}</span>
                        {opt.label}
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
            <label style={styles.label}>Type</label><div style={styles.toggle}><div style={{ ...styles.toggleOption, ...(!personForm.isChild ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setPersonForm({ ...personForm, isChild: false })}>Adult</div><div style={{ ...styles.toggleOption, ...(personForm.isChild ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setPersonForm({ ...personForm, isChild: true })}>Child</div></div>
            <label style={styles.label}>Individual checkbox</label><div style={styles.toggle}><div style={{ ...styles.toggleOption, ...(personForm.individualCheckbox ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setPersonForm({ ...personForm, individualCheckbox: true })}>Yes</div><div style={{ ...styles.toggleOption, ...(!personForm.individualCheckbox ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setPersonForm({ ...personForm, individualCheckbox: false })}>No</div></div>
            {!isNew && <><button style={{ ...styles.btnSecondary, width: '100%', marginTop: '8px' }} onClick={() => { setViewingStats(editingPerson); setEditingPerson(null); }}>View History</button><button style={styles.btnDanger} onClick={del}>Delete</button></>}
          </div>
        );
      };

      const renderEditCard = () => {
        const cp = editingCard?.peopleIds.map(id => people.find(p => p.id === id)).filter(Boolean) || [];
        const save = () => { if (!cardForm.name.trim()) { alert('Name required'); return; } updateCard(editingCard.id, cardForm); setEditingCard(null); };
        return (
          <div className="app-container" style={styles.container}>
            <div className="app-header"><button style={styles.btnText} onClick={() => setEditingCard(null)}>Cancel</button><button style={styles.btnText} onClick={save}>Save</button></div>
            <label style={styles.label}>Card Name</label><input style={styles.input} value={cardForm.name} onChange={e => setCardForm({ ...cardForm, name: e.target.value })} />
            <label style={styles.label}>Frequency</label>
            <div style={styles.sortDropdown}>
              <button type="button" style={styles.sortTrigger} onClick={() => setFreqDropdownOpen(!freqDropdownOpen)}>
                {{ daily: 'Daily', 'every-2-3-days': 'Every 2-3 Days', weekly: 'Weekly', monthly: 'Monthly' }[cardForm.frequency]}
                <span style={{ marginLeft: 'auto', fontSize: '10px', opacity: 0.6 }}></span>
              </button>
              {freqDropdownOpen && (
                <>
                  <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} onClick={() => setFreqDropdownOpen(false)} />
                  <div style={styles.sortMenu}>
                    {[{ value: 'daily', label: 'Daily' }, { value: 'every-2-3-days', label: 'Every 2-3 Days' }, { value: 'weekly', label: 'Weekly' }, { value: 'monthly', label: 'Monthly' }].map(opt => (
                      <div key={opt.value} style={{ ...styles.sortOption, ...(cardForm.frequency === opt.value ? styles.sortOptionActive : {}) }} onClick={() => { setCardForm({ ...cardForm, frequency: opt.value }); setFreqDropdownOpen(false); }}>
                        <span style={{ width: '16px' }}>{cardForm.frequency === opt.value ? '' : ''}</span>
                        {opt.label}
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
            <label style={styles.label}>Prayer Points</label><textarea style={{ ...styles.input, minHeight: '80px', resize: 'vertical' }} value={cardForm.prayerPoint} onChange={e => setCardForm({ ...cardForm, prayerPoint: e.target.value })} placeholder="One per line" />
            {editingCard?.isGroup && <><label style={styles.label}>Unnamed children</label><div style={styles.toggle}><div style={{ ...styles.toggleOption, ...(cardForm.includeUnnamedChildren ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setCardForm({ ...cardForm, includeUnnamedChildren: true })}>Yes</div><div style={{ ...styles.toggleOption, ...(!cardForm.includeUnnamedChildren ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setCardForm({ ...cardForm, includeUnnamedChildren: false })}>No</div></div><label style={styles.label}>People in group</label>{cp.map(p => {
              const isOrg = !p.firstName && !p.lastName && p.organisation;
              const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim();
              return (
                <div key={p.id} style={{ ...styles.listItem, cursor: 'default', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <div>
                    <span style={{ fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</span>
                    <span style={{ fontSize: '12px', color: colors.textTertiary, marginLeft: '8px' }}>{p.isChild ? 'Child' : 'Adult'}</span>
                  </div>
                  <button 
                    style={{ background: 'none', border: 'none', color: colors.textTertiary, fontSize: '18px', cursor: 'pointer', padding: '4px 8px' }}
                    onClick={() => setModal({
                      title: 'Remove from group?',
                      message: `${displayName} will be removed from this group and given their own individual prayer card. Their prayer history will be preserved.`,
                      confirmText: 'Remove',
                      onConfirm: () => removeFromGroup(editingCard.id, p.id)
                    })}
                  ></button>
                </div>
              );
            })}<button style={{ ...styles.btnSecondary, width: '100%', marginTop: '16px' }} onClick={() => setModal({
                  title: 'Split group?',
                  message: 'This will remove the group and create individual prayer cards for each person. Prayer history will be preserved.',
                  confirmText: 'Split',
                  onConfirm: () => { dissolveGroup(editingCard.id); setEditingCard(null); }
                })}>Split into individuals</button></>}
            {!editingCard?.isGroup && <button style={styles.btnDanger} onClick={() => setModal({
              title: 'Delete person?',
              message: 'This will remove this person and their prayer history permanently.',
              confirmText: 'Delete',
              danger: true,
              onConfirm: () => { deleteCard(editingCard.id); setEditingCard(null); }
            })}>Delete</button>}
          </div>
        );
      };

      const renderCreateGroup = () => {
        const sel = people.filter(p => selectedPeopleForGroup.includes(p.id));
        const create = () => { if (!groupForm.name.trim()) { alert('Name required'); return; } createGroup({ ...groupForm, peopleIds: selectedPeopleForGroup, checkboxOverrides }); setSelectedPeopleForGroup([]); setScreen('home'); };
        if (groupStep === 1) return (
          <div className="app-container" style={styles.container}>
            <div className="app-header"><button style={styles.btnText} onClick={() => { setSelectedPeopleForGroup([]); setScreen('home'); }}>Cancel</button><button style={{ ...styles.btnText, opacity: selectedPeopleForGroup.length < 2 ? 0.4 : 1 }} onClick={() => selectedPeopleForGroup.length >= 2 && setGroupStep(2)}>Next ({selectedPeopleForGroup.length})</button></div>
            <div style={{ fontSize: '20px', fontWeight: '700', marginBottom: '12px' }}>Select people</div>
            
            {/* Sorting controls */}
            <div style={{ ...styles.sortRow, marginBottom: '12px' }}>
              <div style={styles.sortDropdown}>
                <button style={styles.sortTrigger} onClick={() => setSortDropdownOpen(o => !o)}>
                  {sortBy === 'firstName' ? 'First Name' : sortBy === 'lastName' ? 'Last Name' : 'Frequency'}
                  <span style={{ marginLeft: 'auto', fontSize: '10px', opacity: 0.6 }}></span>
                </button>
                {sortDropdownOpen && (
                  <>
                    <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} onClick={() => setSortDropdownOpen(false)} />
                    <div style={styles.sortMenu}>
                      {[{ value: 'firstName', label: 'First Name' }, { value: 'lastName', label: 'Last Name' }, { value: 'frequency', label: 'Frequency' }].map(opt => (
                        <div 
                          key={opt.value}
                          style={{ ...styles.sortOption, ...(sortBy === opt.value ? styles.sortOptionActive : {}) }}
                          onClick={() => { setSortBy(opt.value); setSortDropdownOpen(false); }}
                        >
                          <span style={{ width: '16px' }}>{sortBy === opt.value ? '' : ''}</span>
                          {opt.label}
                        </div>
                      ))}
                    </div>
                  </>
                )}
              </div>
              <button style={styles.reverseBtn} onClick={() => setSortReversed(r => !r)}>{sortReversed ? '' : ''}</button>
            </div>
            
            {!people.length ? <div style={styles.emptyState}>Add people first.</div> : (
              <div style={{ maxHeight: 'calc(100vh - 200px)', overflowY: 'auto', padding: '4px 6px', margin: '0 -6px' }}>
                {sortBy !== 'frequency' ? (
                  getSortedPeople().map(p => { 
                    const isSel = selectedPeopleForGroup.includes(p.id); 
                    const isOrg = !p.firstName && !p.lastName && p.organisation; 
                    const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim(); 
                    return (
                      <div key={p.id} style={{ ...styles.listItem, background: isSel ? colors.primaryGradient : colors.cardBg, color: isSel ? colors.primaryText : colors.text }} onClick={() => setSelectedPeopleForGroup(prev => isSel ? prev.filter(id => id !== p.id) : [...prev, p.id])}>
                        <span style={{ fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</span>
                        {p.isChild && <span style={{ fontSize: '12px', opacity: 0.7 }}>(child)</span>}
                      </div>
                    ); 
                  })
                ) : (
                  (() => {
                    const groups = {};
                    getSortedPeople().forEach(p => {
                      const freq = getPersonFrequency(p);
                      if (!groups[freq]) groups[freq] = [];
                      groups[freq].push(p);
                    });
                    const orderedFreqs = sortReversed ? [...frequencyOrder].reverse() : frequencyOrder;
                    return orderedFreqs.map((freq) => {
                      if (!groups[freq] || !groups[freq].length) return null;
                      return (
                        <div key={freq}>
                          <div style={styles.frequencyHeading}>{formatFrequency(freq)}</div>
                          {groups[freq].map(p => { 
                            const isSel = selectedPeopleForGroup.includes(p.id); 
                            const isOrg = !p.firstName && !p.lastName && p.organisation; 
                            const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim(); 
                            return (
                              <div key={p.id} style={{ ...styles.listItem, background: isSel ? colors.primaryGradient : colors.cardBg, color: isSel ? colors.primaryText : colors.text }} onClick={() => setSelectedPeopleForGroup(prev => isSel ? prev.filter(id => id !== p.id) : [...prev, p.id])}>
                                <span style={{ fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</span>
                                {p.isChild && <span style={{ fontSize: '12px', opacity: 0.7 }}>(child)</span>}
                              </div>
                            ); 
                          })}
                        </div>
                      );
                    });
                  })()
                )}
              </div>
            )}
          </div>
        );
        return (
          <div className="app-container" style={{ ...styles.container, display: 'flex', flexDirection: 'column', height: '100vh', overflow: 'hidden' }}>
            <div className="app-header"><button style={styles.btnText} onClick={() => setGroupStep(1)}> Back</button><button style={styles.btnText} onClick={create}>Create</button></div>
            <div style={{ flex: 1, overflowY: 'auto', paddingBottom: '20px' }}>
              <label style={styles.label}>Group Name</label><input style={styles.input} value={groupForm.name} onChange={e => setGroupForm({ ...groupForm, name: e.target.value })} placeholder="e.g. Smiths" />
              <label style={styles.label}>Frequency</label>
              <div style={styles.sortDropdown}>
                <button type="button" style={styles.sortTrigger} onClick={() => setFreqDropdownOpen(!freqDropdownOpen)}>
                  {{ daily: 'Daily', 'every-2-3-days': 'Every 2-3 Days', weekly: 'Weekly', monthly: 'Monthly' }[groupForm.frequency]}
                  <span style={{ marginLeft: 'auto', fontSize: '10px', opacity: 0.6 }}></span>
                </button>
                {freqDropdownOpen && (
                  <>
                    <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} onClick={() => setFreqDropdownOpen(false)} />
                    <div style={styles.sortMenu}>
                      {[{ value: 'daily', label: 'Daily' }, { value: 'every-2-3-days', label: 'Every 2-3 Days' }, { value: 'weekly', label: 'Weekly' }, { value: 'monthly', label: 'Monthly' }].map(opt => (
                        <div key={opt.value} style={{ ...styles.sortOption, ...(groupForm.frequency === opt.value ? styles.sortOptionActive : {}) }} onClick={() => { setGroupForm({ ...groupForm, frequency: opt.value }); setFreqDropdownOpen(false); }}>
                          <span style={{ width: '16px' }}>{groupForm.frequency === opt.value ? '' : ''}</span>
                          {opt.label}
                        </div>
                      ))}
                    </div>
                  </>
                )}
              </div>
              <label style={styles.label}>Prayer Points</label><textarea style={{ ...styles.input, minHeight: '60px', resize: 'vertical' }} value={groupForm.prayerPoint} onChange={e => setGroupForm({ ...groupForm, prayerPoint: e.target.value })} placeholder="One per line" />
              <label style={styles.label}>Unnamed children</label><div style={styles.toggle}><div style={{ ...styles.toggleOption, ...(groupForm.includeUnnamedChildren ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setGroupForm({ ...groupForm, includeUnnamedChildren: true })}>Yes</div><div style={{ ...styles.toggleOption, ...(!groupForm.includeUnnamedChildren ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setGroupForm({ ...groupForm, includeUnnamedChildren: false })}>No</div></div>
              <label style={styles.label}>Checkboxes</label><div>{sel.map(p => { const isOrg = !p.firstName && !p.lastName && p.organisation; const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim(); return <div key={p.id} style={{ ...styles.listItem, flexDirection: 'column', alignItems: 'stretch' }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}><span style={{ fontWeight: '500', fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</span><span style={{ fontSize: '12px', color: colors.textTertiary }}>{p.isChild ? 'Child' : 'Adult'}</span></div><div style={{ ...styles.toggle, marginBottom: 0 }}><div style={{ ...styles.toggleOption, fontSize: '13px', padding: '8px', ...((checkboxOverrides[p.id] ?? p.individualCheckbox) ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setCheckboxOverrides({ ...checkboxOverrides, [p.id]: true })}>Individual</div><div style={{ ...styles.toggleOption, fontSize: '13px', padding: '8px', ...(!(checkboxOverrides[p.id] ?? p.individualCheckbox) ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setCheckboxOverrides({ ...checkboxOverrides, [p.id]: false })}>Grouped</div></div></div>; })}</div>
            </div>
          </div>
        );
      };

      // Get prayer history for a card (union of all people's histories)
      const getCardPrayerHistory = (card) => {
        const dateMap = new Map(); // date -> first history entry found
        card.peopleIds.forEach(pid => {
          const p = people.find(x => x.id === pid);
          (p?.prayerHistory || []).forEach(h => {
            const date = typeof h === 'string' ? h : h.date;
            if (!dateMap.has(date)) {
              dateMap.set(date, h);
            }
          });
        });
        return [...dateMap.values()].sort((a, b) => {
          const dateA = typeof a === 'string' ? a : a.date;
          const dateB = typeof b === 'string' ? b : b.date;
          return new Date(dateB) - new Date(dateA);
        });
      };
      
      const getCardPrayerCountThisMonth = (card) => {
        const m = new Date().getMonth(), y = new Date().getFullYear();
        const hist = getCardPrayerHistory(card);
        return getHistoryDates(hist).filter(d => {
          const x = new Date(d);
          return x.getMonth() === m && x.getFullYear() === y;
        }).length;
      };

      const renderStats = () => {
        // Individual person or group detail view
        if (viewingStats) {
          const isCard = viewingStats.peopleIds !== undefined;
          const hist = isCard ? getCardPrayerHistory(viewingStats) : (viewingStats.prayerHistory || []);
          const histDates = getHistoryDates(hist);
          const m = statsMonth.getMonth(), y = statsMonth.getFullYear();
          const days = new Date(y, m + 1, 0).getDate(), first = new Date(y, m, 1).getDay();
          const prayed = histDates.filter(d => { const x = new Date(d); return x.getMonth() === m && x.getFullYear() === y; }).map(d => new Date(d).getDate());
          const mName = new Date(y, m).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
          const isOrg = !isCard && !viewingStats.firstName && !viewingStats.lastName && viewingStats.organisation;
          const displayName = isCard ? viewingStats.name : (isOrg ? viewingStats.organisation : `${viewingStats.firstName} ${viewingStats.lastName}`.trim());
          const allDates = [...histDates].sort((a, b) => new Date(b) - new Date(a));
          
          // Check if selected date is in current month view
          const selectedInMonth = selectedHistoryDate && new Date(selectedHistoryDate).getMonth() === m && new Date(selectedHistoryDate).getFullYear() === y;
          const selectedDay = selectedInMonth ? new Date(selectedHistoryDate).getDate() : null;
          
          // Get historical entry for selected date
          const selectedEntry = selectedHistoryDate ? getHistoryForDate(hist, selectedHistoryDate) : null;
          
          // Render historical prayer points
          const renderHistoricalPrayerPoints = (text) => {
            if (!text) return null;
            const points = text.split('\n').filter(p => p.trim());
            if (points.length === 0) return null;
            return (
              <div style={{ fontSize: '14px', color: colors.textSecondary, fontStyle: 'italic', marginTop: '8px' }}>
                {points.map((point, i) => (
                  <div key={i} style={{ display: 'flex', gap: '8px', marginBottom: '2px' }}>
                    <span style={{ color: colors.textTertiary }}></span>
                    <span>{point}</span>
                  </div>
                ))}
              </div>
            );
          };
          
          return (
            <div className="app-container" style={styles.container}>
              <div className="app-header"><button style={styles.btnText} onClick={() => { setViewingStats(null); setSelectedHistoryDate(null); }}> Back</button></div>
              <div style={{ fontSize: '22px', fontWeight: '700', marginBottom: '4px', fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</div>
              <div style={{ color: colors.textSecondary, marginBottom: '24px', fontSize: '16px' }}>{prayed.length} times in {mName}</div>
              
              <div style={styles.calendar}>
                <div style={styles.calendarHeader}><button style={styles.navButton} onClick={() => setStatsMonth(new Date(y, m - 1))}></button><span style={{ fontWeight: '600', fontSize: '17px' }}>{mName}</span><button style={styles.navButton} onClick={() => setStatsMonth(new Date(y, m + 1))}></button></div>
                <div style={styles.calendarGrid}>
                  {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((d, i) => <div key={i} style={styles.calendarDayHeader}>{d}</div>)}
                  {Array(first).fill(null).map((_, i) => <div key={`e${i}`} style={styles.calendarDay}></div>)}
                  {Array(days).fill(null).map((_, i) => { 
                    const day = i + 1;
                    const isPrayed = prayed.includes(day);
                    const isSelected = day === selectedDay;
                    return (
                      <div 
                        key={day} 
                        style={{ 
                          ...styles.calendarDay, 
                          ...(isPrayed ? styles.prayedDay : {}),
                          ...(isSelected ? { boxShadow: `inset 0 0 0 3px ${colors.primary}` } : {}),
                          cursor: isPrayed ? 'pointer' : 'default',
                          transition: 'all 0.15s ease'
                        }}
                        onClick={() => isPrayed && setSelectedHistoryDate(formatDate(new Date(y, m, day)))}
                      >
                        {day}
                      </div>
                    );
                  })}
                </div>
              </div>
              
              {/* Historical Prayer Card - below calendar */}
              {selectedHistoryDate && (() => {
                // For cards, gather all individual prayer points from that date
                const individualPoints = [];
                if (isCard) {
                  viewingStats.peopleIds.forEach(pid => {
                    const person = people.find(p => p.id === pid);
                    if (person) {
                      const personEntry = getHistoryForDate(person.prayerHistory, selectedHistoryDate);
                      if (personEntry?.personPrayerPoint) {
                        const displayName = person.firstName || person.organisation || 'Unknown';
                        individualPoints.push({ name: displayName, points: personEntry.personPrayerPoint });
                      }
                    }
                  });
                }
                
                const hasCardPoints = selectedEntry?.cardPrayerPoint;
                const hasPersonalPoints = !isCard && selectedEntry?.personPrayerPoint;
                const hasIndividualPoints = individualPoints.length > 0;
                const hasAnyPoints = hasCardPoints || hasPersonalPoints || hasIndividualPoints;
                
                if (!hasAnyPoints) {
                  return (
                    <div style={{ ...styles.card, marginTop: '16px', background: colors.secondaryGradient, textAlign: 'center', padding: '12px 14px' }}>
                      <div style={{ fontSize: '13px', color: colors.textSecondary }}>
                        No prayer points recorded for {new Date(selectedHistoryDate).toLocaleDateString('en-US', { day: 'numeric', month: 'short', year: 'numeric' })}
                      </div>
                      <div style={{ fontSize: '11px', color: colors.textTertiary, marginTop: '4px' }}>
                        (Prayer points are saved from new prayers going forward)
                      </div>
                    </div>
                  );
                }
                
                return (
                  <div style={{ ...styles.card, marginTop: '16px', padding: '12px 14px', background: colors.primaryGradient + '15', border: `2px solid ${colors.primary}` }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                      <div style={{ fontSize: '12px', fontWeight: '600', color: colors.primary, textTransform: 'uppercase', letterSpacing: '0.5px' }}>
                        Prayer on {new Date(selectedHistoryDate).toLocaleDateString('en-US', { weekday: 'short', day: 'numeric', month: 'short', year: 'numeric' })}
                      </div>
                      <button 
                        style={{ background: 'none', border: 'none', color: colors.textTertiary, fontSize: '16px', cursor: 'pointer', padding: '2px' }}
                        onClick={() => setSelectedHistoryDate(null)}
                      ></button>
                    </div>
                    {hasCardPoints && (
                      <div style={{ marginBottom: (hasPersonalPoints || hasIndividualPoints) ? '10px' : '0' }}>
                        <div style={{ fontSize: '11px', color: colors.textTertiary, marginBottom: '2px' }}>Card</div>
                        {renderHistoricalPrayerPoints(selectedEntry.cardPrayerPoint)}
                      </div>
                    )}
                    {hasPersonalPoints && (
                      <div>
                        <div style={{ fontSize: '11px', color: colors.textTertiary, marginBottom: '2px' }}>Personal</div>
                        {renderHistoricalPrayerPoints(selectedEntry.personPrayerPoint)}
                      </div>
                    )}
                    {hasIndividualPoints && (
                      <div>
                        <div style={{ fontSize: '11px', color: colors.textTertiary, marginBottom: '4px' }}>Individual Prayer Points</div>
                        {individualPoints.map((item, idx) => (
                          <div key={idx} style={{ marginBottom: idx < individualPoints.length - 1 ? '8px' : '0' }}>
                            <div style={{ fontSize: '13px', fontWeight: '600', color: colors.text, marginBottom: '2px' }}>{item.name}</div>
                            {renderHistoricalPrayerPoints(item.points)}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                );
              })()}
              
              {allDates.length > 0 && (
                <div style={{ marginTop: '24px' }}>
                  <div style={{ fontSize: '13px', fontWeight: '600', color: colors.textSecondary, textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '12px' }}>All Prayer Dates</div>
                  {(() => {
                    // Group dates by month
                    const monthGroups = {};
                    allDates.forEach(date => {
                      const d = new Date(date);
                      const key = `${d.getFullYear()}-${String(d.getMonth()).padStart(2, '0')}`;
                      if (!monthGroups[key]) {
                        monthGroups[key] = { year: d.getFullYear(), month: d.getMonth(), dates: [] };
                      }
                      monthGroups[key].dates.push({ date, day: d.getDate() });
                    });
                    // Sort month keys descending
                    const sortedKeys = Object.keys(monthGroups).sort((a, b) => b.localeCompare(a));
                    return sortedKeys.map(key => {
                      const group = monthGroups[key];
                      const monthLabel = new Date(group.year, group.month).toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                      // Sort dates within month ascending
                      group.dates.sort((a, b) => a.day - b.day);
                      return (
                        <div key={key} style={{ marginBottom: '12px' }}>
                          <div style={{ display: 'flex', alignItems: 'flex-start', gap: '12px' }}>
                            <div style={{ fontSize: '13px', fontWeight: '600', color: colors.textTertiary, minWidth: '70px', paddingTop: '6px' }}>{monthLabel}</div>
                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px', flex: 1 }}>
                              {group.dates.map(({ date, day }) => {
                                const isSelected = date === selectedHistoryDate;
                                return (
                                  <button
                                    key={date}
                                    onClick={() => { setStatsMonth(new Date(group.year, group.month)); setSelectedHistoryDate(date); }}
                                    style={{
                                      width: '32px',
                                      height: '32px',
                                      borderRadius: '50%',
                                      fontSize: '13px',
                                      fontWeight: isSelected ? '700' : '500',
                                      background: isSelected ? colors.primaryGradient : colors.accentGradient,
                                      border: isSelected ? `2px solid ${colors.primary}` : 'none',
                                      boxShadow: isSelected ? `0 0 0 2px ${colors.cardBg}` : 'none',
                                      color: '#FFF',
                                      cursor: 'pointer',
                                      fontFamily: 'inherit',
                                      outline: 'none',
                                      display: 'flex',
                                      alignItems: 'center',
                                      justifyContent: 'center',
                                      padding: 0
                                    }}
                                  >
                                    {day}
                                  </button>
                                );
                              })}
                            </div>
                          </div>
                        </div>
                      );
                    });
                  })()}
                </div>
              )}
            </div>
          );
        }
        
        // Main history list view with tabs
        const renderHistorySortControls = (isPeople = true) => (
          <div className="sort-row" style={{ ...styles.sortRow, marginBottom: 0 }}>
            <div style={styles.sortDropdown}>
              <button style={styles.sortTrigger} onClick={() => setSortDropdownOpen(o => !o)}>
                {isPeople 
                  ? (sortBy === 'firstName' ? 'First Name' : sortBy === 'lastName' ? 'Last Name' : 'Frequency')
                  : (cardSortBy === 'name' ? 'Name' : 'Frequency')
                }
                <span style={{ marginLeft: 'auto', fontSize: '10px', opacity: 0.6 }}></span>
              </button>
              {sortDropdownOpen && (
                <>
                  <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} onClick={() => setSortDropdownOpen(false)} />
                  <div style={styles.sortMenu}>
                    {(isPeople 
                      ? [{ value: 'firstName', label: 'First Name' }, { value: 'lastName', label: 'Last Name' }, { value: 'frequency', label: 'Frequency' }]
                      : [{ value: 'name', label: 'Name' }, { value: 'frequency', label: 'Frequency' }]
                    ).map(opt => (
                      <div 
                        key={opt.value}
                        style={{ ...styles.sortOption, ...((isPeople ? sortBy : cardSortBy) === opt.value ? styles.sortOptionActive : {}) }}
                        onClick={() => { isPeople ? setSortBy(opt.value) : setCardSortBy(opt.value); setSortDropdownOpen(false); }}
                      >
                        <span style={{ width: '16px' }}>{(isPeople ? sortBy : cardSortBy) === opt.value ? '' : ''}</span>
                        {opt.label}
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
            <button style={styles.reverseBtn} onClick={() => setSortReversed(r => !r)}>{sortReversed ? '' : ''}</button>
          </div>
        );
        
        const renderHistoryPeopleList = () => {
          if (!people.length) return <div style={styles.emptyState}>No history yet.</div>;
          return (() => {
                const sorted = getSortedPeople();
                const listItemStyle = { ...styles.listItem, marginBottom: 0 };
                
                if (sortBy !== 'frequency') {
                  return (
                    <div className="two-column-grid">
                      {sorted.map(p => { 
                        const c = cards.find(x => x.peopleIds.includes(p.id)); 
                        const isOrg = !p.firstName && !p.lastName && p.organisation; 
                        const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim(); 
                        return (
                          <div key={p.id} style={listItemStyle} onClick={() => { setViewingStats(p); setStatsMonth(new Date()); setSelectedHistoryDate(null); }}>
                            <div style={{ ...styles.listItemName, fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}{p.organisation && !isOrg && <span style={{ fontSize: '12px', color: colors.textTertiary, fontStyle: 'italic', fontWeight: 'normal' }}>  {p.organisation}</span>}</div>
                            <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '4px' }}>{formatFrequency(c?.frequency)}  {getPrayerCountThisMonth(p.id)}</div>
                          </div>
                        ); 
                      })}
                    </div>
                  );
                }
                // Frequency grouping
                const groups = {};
                sorted.forEach(p => {
                  const freq = getPersonFrequency(p);
                  if (!groups[freq]) groups[freq] = [];
                  groups[freq].push(p);
                });
                const orderedFreqs = sortReversed ? [...frequencyOrder].reverse() : frequencyOrder;
                return orderedFreqs.map((freq) => {
                  if (!groups[freq] || !groups[freq].length) return null;
                  return (
                    <div key={freq}>
                      <div style={styles.frequencyHeading}>{formatFrequency(freq)}</div>
                      <div className="two-column-grid">
                        {groups[freq].map(p => {
                          const c = cards.find(x => x.peopleIds.includes(p.id));
                          const isOrg = !p.firstName && !p.lastName && p.organisation;
                          const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim();
                          return (
                            <div key={p.id} style={listItemStyle} onClick={() => { setViewingStats(p); setStatsMonth(new Date()); setSelectedHistoryDate(null); }}>
                              <div style={{ ...styles.listItemName, fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}{p.organisation && !isOrg && <span style={{ fontSize: '12px', color: colors.textTertiary, fontStyle: 'italic', fontWeight: 'normal' }}>  {p.organisation}</span>}</div>
                              <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '4px' }}>{getPrayerCountThisMonth(p.id)}</div>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  );
                });
              })();
        };
        
        const renderHistoryGroupsList = () => {
          if (!getSortedCards().length) return <div style={styles.emptyState}>No groups yet.</div>;
          return (() => {
                const sortedCards = getSortedCards();
                const listItemStyle = { ...styles.listItem, marginBottom: 0 };
                
                if (cardSortBy !== 'frequency') {
                  return (
                    <div className="two-column-grid">
                      {sortedCards.map(c => { 
                        const count = c.peopleIds.length; 
                        return (
                          <div key={c.id} style={listItemStyle} onClick={() => { setViewingStats(c); setStatsMonth(new Date()); setSelectedHistoryDate(null); }}>
                            <div style={styles.listItemName}>{c.name}</div>
                            <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '2px' }}>{count} {count === 1 ? 'person' : 'people'}</div>
                            <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '4px' }}>{formatFrequency(c.frequency)}  {getCardPrayerCountThisMonth(c)}</div>
                          </div>
                        );
                      })}
                    </div>
                  );
                }
                // Frequency grouping
                const groups = {};
                sortedCards.forEach(c => {
                  if (!groups[c.frequency]) groups[c.frequency] = [];
                  groups[c.frequency].push(c);
                });
                return frequencyOrder.map((freq) => {
                  if (!groups[freq] || !groups[freq].length) return null;
                  return (
                    <div key={freq}>
                      <div style={styles.frequencyHeading}>{formatFrequency(freq)}</div>
                      <div className="two-column-grid">
                        {groups[freq].map(c => {
                          const count = c.peopleIds.length;
                          return (
                            <div key={c.id} style={listItemStyle} onClick={() => { setViewingStats(c); setStatsMonth(new Date()); setSelectedHistoryDate(null); }}>
                              <div style={styles.listItemName}>{c.name}</div>
                              <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '2px' }}>{count} {count === 1 ? 'person' : 'people'}</div>
                              <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '4px' }}>{getCardPrayerCountThisMonth(c)}</div>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  );
                });
              })();
        };
        
        return (
          <div className="app-container" style={{ ...styles.container, display: 'flex', flexDirection: 'column', height: '100vh', overflow: 'hidden' }}>
            <div className="app-header">
              <button style={styles.btnText} onClick={() => setScreen('home')}> Back</button>
            </div>
            
            {/* Portrait: Tabs stacked above sorting */}
            <div className="portrait-only">
              <div style={{ ...styles.tabs, marginBottom: '12px' }}>
                <button style={{ ...styles.tab, ...(historyTab === 'people' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setHistoryTab('people')}>People</button>
                <button style={{ ...styles.tab, ...(historyTab === 'groups' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setHistoryTab('groups')}>Groups</button>
              </div>
              {renderHistorySortControls(historyTab === 'people')}
            </div>
            
            {/* Landscape: Tabs left, sorting right - same row */}
            <div className="landscape-only">
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px', gap: '12px' }}>
                <div style={{ ...styles.tabs, flex: '0 0 auto', width: '280px', marginBottom: 0 }}>
                  <button style={{ ...styles.tab, ...(historyTab === 'people' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setHistoryTab('people')}>People</button>
                  <button style={{ ...styles.tab, ...(historyTab === 'groups' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setHistoryTab('groups')}>Groups</button>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                  {renderHistorySortControls(historyTab === 'people')}
                </div>
              </div>
            </div>
            
            {/* 2-column grid list */}
            <div style={{ flex: 1, overflowY: 'auto', padding: '4px 6px', margin: '0 -6px' }}>
              {historyTab === 'people' ? renderHistoryPeopleList() : renderHistoryGroupsList()}
            </div>
          </div>
        );
      };

      // Onboarding takes highest priority
      if (!onboardingComplete) return renderOnboarding();
      
      // Help screen takes priority
      if (helpOpen) return renderHelp();
      
      if (editingPerson) return <>{renderEditPerson()}{renderModal()}</>;
      if (editingCard) return <>{renderEditCard()}{renderModal()}</>;
      if (viewingStats) return renderStats();
      
      switch (screen) {
        case 'home': return renderHome();
        case 'prayer': return renderPrayer();
        case 'manage': return renderManage();
        case 'stats': return renderStats();
        case 'createGroup': return renderCreateGroup();
        default: return renderHome();
      }
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<PrayerCompanion />);
  </script>
</body>
</html>

