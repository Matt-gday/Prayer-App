<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Prayer Companion</title>
  
  <!-- PWA / Add to Home Screen support for iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Prayer">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#EDE4D8">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  
  <!-- Favicon - Browser tab icon -->
  <link rel="icon" type="image/png" href="./prayer-companion-icon.png?v=2">
  <link rel="apple-touch-icon" href="./prayer-companion-icon.png?v=2">
  
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;500;600;700&family=Oranienbaum&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    html, body, #root {
      height: 100%;
      width: 100%;
      /* Match container background to prevent visible line */
      background: linear-gradient(160deg, #F5EEE4 0%, #E8DECE 50%, #EDE4D8 100%);
      background-attachment: fixed;
      overflow: hidden;
      overscroll-behavior: none;
      position: relative;
    }
    body {
      font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      /* Safe areas for notched phones and Safari bars */
      padding-top: env(safe-area-inset-top);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      padding-bottom: env(safe-area-inset-bottom);
      margin: 0;
      height: 100%;
      max-height: 100%;
    }
    input, textarea, select, button {
      font-family: inherit;
    }
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    ::-webkit-scrollbar-thumb {
      background: rgba(128,128,128,0.3);
      border-radius: 3px;
    }
    
    /* Home page circular buttons - unified style */
    .home-circle-btn {
      width: 34px;
      height: 34px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(250,247,242,0.95);
      border: 1.5px solid #D4C8B8;
      border-radius: 50%;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      font-style: italic;
      font-family: Georgia, serif;
      color: #6B5D4F;
      box-shadow: 0 2px 6px rgba(90,70,50,0.1);
      transition: all 0.2s ease;
    }
    .home-circle-btn:hover {
      background: #FAF7F2;
      border-color: #B87A4A;
      color: #B87A4A;
    }
    .home-circle-btn.active {
      background: linear-gradient(135deg, #D49A5A 0%, #A66830 100%);
      color: white;
      border-color: #A66830;
      box-shadow: 0 2px 8px rgba(184,122,74,0.3);
    }
    /* Symbol buttons don't need italic, lighter weight */
    .home-circle-btn.symbol {
      font-style: normal;
      font-family: inherit;
      font-weight: 400;
    }
    
    /* Onboarding screen */
    .onboarding-overlay {
      position: fixed;
      inset: 0;
      background: linear-gradient(160deg, #F5EEE4 0%, #E8DECE 50%, #EDE4D8 100%);
      z-index: 2000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px;
      text-align: center;
    }
    .onboarding-card {
      background: linear-gradient(145deg, #FFFFFF 0%, #F5F0E8 100%);
      border-radius: 24px;
      padding: 32px 28px;
      max-width: 360px;
      width: 100%;
      box-shadow: 0 8px 40px rgba(90,70,50,0.15), 0 2px 8px rgba(90,70,50,0.1);
      border: 1px solid #D4C8B8;
    }
    .onboarding-title {
      font-size: 24px;
      font-weight: 700;
      color: #3D352C;
      margin-bottom: 12px;
    }
    .onboarding-text {
      font-size: 15px;
      color: #6B5D4F;
      line-height: 1.6;
      margin-bottom: 24px;
    }
    .onboarding-input {
      width: 100%;
      padding: 16px 18px;
      font-size: 18px;
      text-align: center;
      background: #FAF7F2;
      border: 1.5px solid #D4C8B8;
      border-radius: 14px;
      color: #3D352C;
      margin-bottom: 20px;
      box-sizing: border-box;
      font-family: inherit;
      outline: none;
      text-transform: capitalize;
      transition: border-color 0.2s ease;
    }
    .onboarding-input:focus {
      border-color: #B87A4A;
    }
    .onboarding-input::placeholder {
      text-transform: none;
      color: #8C7B6A;
    }
    .onboarding-btn {
      width: 100%;
      padding: 16px 24px;
      font-size: 17px;
      font-weight: 600;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.2s ease;
      margin-bottom: 12px;
    }
    .onboarding-btn-primary {
      background: linear-gradient(135deg, #D49A5A 0%, #A66830 100%);
      color: white;
      box-shadow: 0 4px 16px rgba(184,122,74,0.35);
    }
    .onboarding-btn-secondary {
      background: linear-gradient(135deg, #EDE4D6 0%, #D9CDBF 100%);
      color: #4A3F34;
      border: 1px solid #D4C8B8;
    }
    .onboarding-hint {
      font-size: 13px;
      color: #8C7B6A;
      margin-top: 16px;
      font-style: italic;
    }
    
    /* Tutorial overlay */
    .tutorial-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 9998;
      pointer-events: auto;
    }
    .tutorial-highlight {
      position: absolute;
      z-index: 9999;
      box-shadow: 0 0 0 4px rgba(184,122,74,0.8), 0 0 0 9999px rgba(0,0,0,0.7);
      border-radius: 12px;
      pointer-events: none;
      transition: all 0.3s ease;
    }
    .tutorial-tooltip {
      position: absolute;
      z-index: 10000;
      background: linear-gradient(145deg, #FFFFFF 0%, #F5F0E8 100%);
      border-radius: 16px;
      padding: 20px;
      max-width: 320px;
      box-shadow: 0 8px 32px rgba(90,70,50,0.25);
      border: 1px solid #D4C8B8;
    }
    .tutorial-tooltip-arrow {
      position: absolute;
      width: 0;
      height: 0;
      border-style: solid;
    }
    .tutorial-tooltip-arrow.top {
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      border-width: 10px 10px 0 10px;
      border-color: #F5F0E8 transparent transparent transparent;
    }
    .tutorial-tooltip-arrow.bottom {
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      border-width: 0 10px 10px 10px;
      border-color: transparent transparent #FFFFFF transparent;
    }
    .tutorial-tooltip-arrow.left {
      right: -10px;
      top: 50%;
      transform: translateY(-50%);
      border-width: 10px 0 10px 10px;
      border-color: transparent transparent transparent #F5F0E8;
    }
    .tutorial-tooltip-arrow.right {
      left: -10px;
      top: 50%;
      transform: translateY(-50%);
      border-width: 10px 10px 10px 0;
      border-color: transparent #FFFFFF transparent transparent;
    }
    .tutorial-title {
      font-size: 18px;
      font-weight: 700;
      color: #3D352C;
      margin-bottom: 10px;
    }
    .tutorial-text {
      font-size: 15px;
      color: #6B5D4F;
      line-height: 1.5;
      margin-bottom: 16px;
    }
    .tutorial-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    .tutorial-btn {
      padding: 10px 18px;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      font-family: inherit;
      transition: all 0.2s ease;
    }
    .tutorial-btn-primary {
      background: linear-gradient(145deg, #B87A4A 0%, #9A6840 100%);
      color: white;
    }
    .tutorial-btn-secondary {
      background: transparent;
      color: #8C7B6A;
      border: 1px solid #D4C8B8;
    }
    .tutorial-progress {
      display: flex;
      gap: 6px;
      justify-content: center;
      margin-top: 16px;
    }
    .tutorial-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #D4C8B8;
      transition: all 0.2s ease;
    }
    .tutorial-dot.active {
      background: #B87A4A;
      transform: scale(1.2);
    }
    .tutorial-dot.completed {
      background: #6EC49F;
    }
    
    /* Edit name button */
    .edit-name-btn {
      background: none;
      border: none;
      padding: 4px;
      margin-left: 6px;
      cursor: pointer;
      color: #8C7B6A;
      font-size: 12px;
      opacity: 0.6;
      transition: opacity 0.2s ease;
      vertical-align: middle;
    }
    .edit-name-btn:hover {
      opacity: 1;
      color: #B87A4A;
    }
    
    /* Data modal */
    .data-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      z-index: 1500;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .data-modal {
      background: linear-gradient(145deg, #FFFFFF 0%, #F5F0E8 100%);
      border-radius: 20px;
      padding: 24px;
      max-width: 360px;
      width: 100%;
      box-shadow: 0 8px 40px rgba(0,0,0,0.2);
      border: 1px solid #D4C8B8;
    }
    .data-modal h3 {
      font-size: 18px;
      font-weight: 600;
      color: #3D352C;
      margin-bottom: 8px;
      text-align: center;
    }
    .data-modal-desc {
      font-size: 14px;
      color: #6B5D4F;
      text-align: center;
      margin-bottom: 20px;
      line-height: 1.5;
    }
    .data-modal-btn {
      width: 100%;
      padding: 14px 20px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.2s ease;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    .data-modal-btn-download {
      background: linear-gradient(135deg, #6DB88A 0%, #4A8862 100%);
      color: white;
      box-shadow: 0 4px 16px rgba(90,158,120,0.3);
    }
    .data-modal-btn-upload {
      background: linear-gradient(135deg, #EDE4D6 0%, #D9CDBF 100%);
      color: #4A3F34;
      border: 1px solid #D4C8B8;
    }
    .data-modal-btn-cancel {
      background: transparent;
      color: #8C7B6A;
      margin-top: 8px;
      margin-bottom: 0;
    }
    .data-modal-warning {
      background: rgba(196,99,94,0.1);
      border: 1px solid rgba(196,99,94,0.3);
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 16px;
      font-size: 13px;
      color: #8B4513;
      text-align: center;
      line-height: 1.5;
    }
    
    /* Edit name modal */
    .edit-name-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      z-index: 1500;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .edit-name-modal {
      background: linear-gradient(145deg, #FFFFFF 0%, #F5F0E8 100%);
      border-radius: 20px;
      padding: 24px;
      max-width: 320px;
      width: 100%;
      box-shadow: 0 8px 40px rgba(0,0,0,0.2);
      border: 1px solid #D4C8B8;
    }
    .edit-name-modal h3 {
      font-size: 18px;
      font-weight: 600;
      color: #3D352C;
      margin-bottom: 16px;
      text-align: center;
    }
    
    /* Card scroll indicator */
    .scroll-indicator {
      position: absolute;
      bottom: 8px;
      right: 12px;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #8C7B6A;
      font-size: 14px;
      opacity: 0.7;
      transition: opacity 0.3s ease, transform 0.3s ease;
      pointer-events: none;
    }
    .scroll-indicator.hidden {
      opacity: 0;
    }
    
    /* Help/Manual accordion */
    .help-section {
      margin-bottom: 8px;
    }
    .help-accordion {
      background: linear-gradient(145deg, #FFFFFF 0%, #F5F0E8 100%);
      border: 1px solid #D4C8B8;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(90,70,50,0.08);
    }
    .help-accordion-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s ease;
    }
    .help-accordion-header:hover {
      background: rgba(184,122,74,0.05);
    }
    .help-accordion-title {
      font-size: 15px;
      font-weight: 600;
      color: #3D352C;
    }
    .help-accordion-icon {
      color: #8C7B6A;
      font-size: 14px;
      transition: transform 0.3s ease;
    }
    .help-accordion-icon.open {
      transform: rotate(180deg);
    }
    .help-accordion-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .help-accordion-content.open {
      max-height: 1500px;
    }
    .help-accordion-body {
      padding: 0 16px 16px;
      font-size: 14px;
      color: #6B5D4F;
      line-height: 1.6;
    }
    .help-accordion-body p {
      margin-bottom: 8px;
    }
    .help-accordion-body ul {
      margin-left: 16px;
      margin-bottom: 8px;
    }
    .help-accordion-body li {
      margin-bottom: 4px;
    }
    .help-tip {
      background: rgba(184,122,74,0.1);
      padding: 10px 12px;
      border-radius: 8px;
      font-style: italic;
      margin-top: 8px;
    }
    
    /* App container - full width on mobile/tablet, constrained only on desktop */
    .app-container {
      max-width: none;
      width: 100%;
    }
    /* Desktop wrapper - rounded container */
    .desktop-wrapper {
      display: block;
    }
    @media (min-width: 1200px) {
      .desktop-wrapper {
        max-width: 540px;
        margin: 20px auto;
        background: linear-gradient(160deg, #F5EEE4 0%, #E8DECE 50%, #EDE4D8 100%);
        border-radius: 24px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1);
        border: 1px solid #D4C8B8;
        overflow-y: auto;
        overflow-x: hidden;
        height: calc(100vh - 40px);
        display: flex;
        flex-direction: column;
      }
      .desktop-wrapper > * {
        flex: 1 0 auto;
        min-height: min-content;
      }
      .app-container {
        max-width: 540px;
        background: transparent !important;
        min-height: 100%;
      }
    }
    @media (min-width: 1400px) {
      .desktop-wrapper {
        max-width: 600px;
      }
      .app-container {
        max-width: 600px;
      }
    }
    /* Bottom nav - match container width */
    .bottom-nav {
      max-width: none;
      width: 100%;
    }
    @media (min-width: 1200px) {
      .bottom-nav {
        max-width: 540px;
      }
    }
    @media (min-width: 1400px) {
      .bottom-nav {
        max-width: 600px;
      }
    }
    
    /* Desktop scrollable areas - add padding for rounded corners */
    @media (min-width: 1200px) {
      .two-column-list,
      .two-column-grid {
        padding-bottom: 32px !important;
      }
      /* Fix height to use container height instead of viewport */
      .app-container {
        display: flex;
        flex-direction: column;
        overflow: hidden;
        height: 100% !important;
        max-height: 100% !important;
      }
      /* Ensure scrollable areas respect container bounds */
      .two-column-list {
        max-height: none !important;
      }
    }
    
    /* Tablet-specific adjustments - scale up everything (exclude landscape phones by requiring min-height) */
    @media (min-width: 768px) and (max-width: 1199px) and (min-height: 600px) {
      .app-container {
        padding-left: 32px;
        padding-right: 32px;
        padding-top: 24px;
      }
      /* Scale up buttons */
      .home-start-btn {
        width: clamp(200px, 28vw, 280px) !important;
        height: clamp(200px, 28vw, 280px) !important;
        font-size: clamp(24px, 3.5vw, 34px) !important;
      }
      .home-start-wrapper {
        padding: 60px 0 !important;
        margin-bottom: 60px !important;
      }
      .home-action-btn {
        padding: 18px 36px !important;
        font-size: 18px !important;
        min-width: 240px !important;
        width: auto !important;
      }
      /* Scale up text */
      .home-welcome {
        font-size: clamp(32px, 5vw, 44px) !important;
      }
      .home-subtext {
        font-size: clamp(18px, 2.5vw, 24px) !important;
        margin-top: 4px !important;
      }
      .home-prayers-heading {
        font-size: 15px !important;
        margin-bottom: 20px !important;
        letter-spacing: 1.5px !important;
      }
      .home-prayers-list {
        font-size: clamp(17px, 2.5vw, 22px) !important;
        line-height: 2.4 !important;
      }
      /* More spacing */
      .home-actions-portrait {
        gap: 20px !important;
      }
      .home-portrait-divider {
        margin-top: 56px !important;
        margin-bottom: 40px !important;
        max-width: 360px !important;
      }
      .home-greeting {
        padding-top: 24px !important;
        margin-bottom: 16px !important;
      }
    }
    
    /* Large tablet landscape */
    @media (min-width: 1024px) and (max-width: 1199px) and (orientation: landscape) {
      .home-start-btn {
        width: clamp(140px, 16vw, 180px) !important;
        height: clamp(140px, 16vw, 180px) !important;
        font-size: clamp(18px, 2.2vw, 24px) !important;
      }
    }
    
    /* Prayer view - fit within viewport with scrollable card area */
    .prayer-view-container {
      display: flex;
      flex-direction: column;
      height: 100dvh; /* Dynamic viewport height - accounts for mobile browser UI */
      height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      max-height: 100dvh;
      padding: 16px;
      padding-top: max(12px, env(safe-area-inset-top));
      padding-bottom: max(16px, env(safe-area-inset-bottom));
      box-sizing: border-box;
      overflow: hidden;
    }
    .prayer-card-area {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      display: flex;
      flex-direction: column;
    }
    .prayer-card-area > div:first-child {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      max-height: 100%;
    }
    .card-content-scrollable {
      -webkit-overflow-scrolling: touch;
      overflow-y: auto;
      min-height: 0;
    }
    .prayer-nav-area {
      flex-shrink: 0;
      padding-top: 8px;
    }
    /* Desktop - constrain prayer view width and height */
    @media (min-width: 1200px) {
      .prayer-view-container {
        max-width: 540px;
        height: 100% !important;
        max-height: 100% !important;
      }
    }
    @media (min-width: 1400px) {
      .prayer-view-container {
        max-width: 600px;
      }
    }
    
    /* Home page landscape layout */
    .home-content {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      overflow-x: hidden;
      overscroll-behavior: contain;
      -webkit-overflow-scrolling: touch;
    }
    .home-left {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .home-right {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }
    .home-right-content {
      display: flex;
      flex-direction: column;
    }
    .home-separator {
      display: none;
    }
    .home-actions-portrait {
      display: flex;
    }
    .home-header-row {
      display: none;
    }
    /* Landscape mode - two columns (phone/small tablet only) */
    @media (orientation: landscape) and (max-width: 932px) and (max-height: 500px) {
      .home-content {
        flex-direction: row;
        gap: 0;
      }
      .home-left {
        flex: 0 0 auto;
        width: calc(50% - 1px);
        justify-content: center;
        align-items: center;
        padding-right: 24px;
      }
      .home-right {
        flex: 1;
        padding-left: 24px;
        justify-content: center;
        align-items: center;
        padding-top: 0;
      }
      .home-right-content {
        width: 100%;
        max-width: 100%;
      }
      .home-actions-portrait {
        display: flex !important;
        flex-direction: row !important;
        gap: 10px;
        margin-bottom: 0 !important;
        margin-top: 36px !important;
      }
      .home-start-btn-wrapper {
        padding: 0 !important;
        margin-bottom: 0 !important;
      }
      .home-start-btn {
        width: 130px !important;
        height: 130px !important;
        font-size: 17px !important;
        padding: 16px !important;
      }
      .home-action-btn {
        width: 160px !important;
        padding: 11px 16px !important;
        font-size: 14px !important;
      }
      .home-separator {
        display: block;
        width: 1px;
        background: linear-gradient(180deg, transparent 0%, rgba(180,160,140,0.4) 20%, rgba(180,160,140,0.4) 80%, transparent 100%);
        align-self: stretch;
      }
      .home-header-row {
        display: flex !important;
        flex-direction: row !important;
        justify-content: space-between !important;
        align-items: center !important;
        text-align: left !important;
        padding-top: 4px !important;
        margin-bottom: 8px !important;
      }
      .home-header-row .home-greeting-text {
        display: flex;
        align-items: baseline;
        gap: 12px;
      }
      .home-greeting {
        display: none !important;
      }
      .home-start-btn-wrapper {
        padding: 0 !important;
      }
.home-spacer-top, .home-spacer-bottom, .home-portrait-divider {
         display: none;
       }
       .home-header-row {
         display: flex !important;
       }
     }
     
     /* Generic landscape 2-column layout for other screens */
     .landscape-layout {
       display: flex;
       flex-direction: column;
       flex: 1;
       min-height: 0;
     }
     .landscape-left {
       display: flex;
       flex-direction: column;
     }
     .landscape-right {
       flex: 1;
       min-height: 0;
       display: flex;
       flex-direction: column;
       overflow-y: auto;
     }
     .landscape-separator {
       display: none;
     }
     @media (orientation: landscape) and (max-width: 932px) and (max-height: 500px) {
       .landscape-layout {
         flex-direction: row;
         gap: 0;
       }
       .landscape-left {
         flex: 0 0 auto;
         width: calc(50% - 1px);
         padding-right: 24px;
         overflow-y: auto;
       }
       .landscape-right {
         flex: 1;
         padding-left: 24px;
       }
       .landscape-separator {
         display: block;
         width: 1px;
         background: linear-gradient(180deg, transparent 0%, rgba(180,160,140,0.4) 20%, rgba(180,160,140,0.4) 80%, transparent 100%);
         align-self: stretch;
         flex-shrink: 0;
       }
     }
     
     /* 2-column grid for lists in landscape */
     .two-column-grid {
       display: grid !important;
       grid-template-columns: 1fr;
       gap: 6px;
       align-content: start;
     }
     @media (orientation: landscape) and (max-width: 932px) and (max-height: 500px) {
       .two-column-grid {
         grid-template-columns: 1fr 1fr !important;
         gap: 8px 16px !important;
         align-content: start !important;
       }
     }
     
/* Reduce header spacing in landscape */
    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      min-height: 28px;
    }
    .page-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 8px;
      text-align: center;
    }
     @media (orientation: landscape) and (max-width: 932px) and (max-height: 500px) {
       .app-header {
         margin-bottom: 6px;
         min-height: 36px;
       }
       .app-container {
         padding-top: 8px !important;
       }
     }
     
     /* 3-column grid for group cards in prayer view */
     .three-column-grid {
       display: grid !important;
       grid-template-columns: repeat(3, 1fr);
       gap: 8px 12px;
     }
     
     /* Portrait/Landscape only visibility */
     .portrait-only { display: block !important; }
     .landscape-only { display: none !important; }
     
     /* Phone landscape mode - only for actual phones/small tablets in landscape */
     /* Uses max-height to detect actual landscape orientation on narrow devices */
    @media (orientation: landscape) and (max-width: 932px) and (max-height: 500px) {
      .portrait-only { display: none !important; }
      .landscape-only { display: flex !important; }
       .card-header-row { margin-bottom: 4px !important; }
       .sort-row { width: auto !important; justify-content: flex-start !important; gap: 8px !important; }
       /* Reduce prayer nav button size in landscape */
       .prayer-nav-button {
         width: 32px !important;
         height: 32px !important;
         border-radius: 16px !important;
         font-size: 16px !important;
       }
       /* Reduce spacing between card and nav buttons in landscape */
       .prayer-nav-area {
         padding-top: 0px !important;
         padding-bottom: 4px !important;
       }
       /* Reduce gap between nav buttons in landscape */
       .prayer-nav-area > div:first-child {
         gap: 16px !important;
         margin-top: 8px !important;
       }
       /* Reduce card bottom padding in landscape to maximize space */
       .landscape-only.card-content-scrollable {
         padding-bottom: 0px !important;
       }
       /* Reduce prayer view container bottom padding in landscape */
       .prayer-view-container {
         padding-bottom: 4px !important;
       }
        /* Reduce calendar size in landscape */
        .landscape-left .calendar {
          padding: 22px !important;
        }
       .landscape-left .calendar-header {
         margin-bottom: 12px !important;
       }
       .landscape-left .calendar-grid {
         gap: 4px !important;
       }
       .landscape-left .calendar-day {
         padding: 6px 2px !important;
         font-size: 13px !important;
         border-radius: 6px !important;
       }
       .landscape-left .calendar-day-header {
         font-size: 11px !important;
         padding: 4px 2px !important;
       }
       .landscape-left .nav-button {
         font-size: 16px !important;
         padding: 4px 8px !important;
       }
     }
     
     /* Card slide animations */
     @keyframes slideInFromRight {
       from { transform: translateX(100%); opacity: 0; }
       to { transform: translateX(0); opacity: 1; }
     }
     @keyframes slideInFromLeft {
       from { transform: translateX(-100%); opacity: 0; }
       to { transform: translateX(0); opacity: 1; }
     }
     .card-slide-right {
       animation: slideInFromRight 0.25s ease-out;
     }
     .card-slide-left {
       animation: slideInFromLeft 0.25s ease-out;
     }
   </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    const generateId = () => Math.random().toString(36).substr(2, 9);
    const formatDate = (date) => {
      const d = new Date(date);
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    };
    const getToday = () => formatDate(new Date());

    const getGreeting = (name = 'Friend') => {
      const hour = new Date().getHours();
      if (hour < 12) return `Good morning, ${name}`;
      if (hour < 17) return `Good afternoon, ${name}`;
      return `Good evening, ${name}`;
    };

    // Hash function to consistently assign cards to time slots for even distribution
    const getSlotFromId = (id, numSlots) => {
      let hash = 0;
      for (let i = 0; i < id.length; i++) {
        hash = ((hash << 5) - hash) + id.charCodeAt(i);
        hash = hash & hash;
      }
      return Math.abs(hash) % numSlots;
    };

    const generatePrayerHistory = (frequency, weeksBack = 8) => {
      const history = [];
      const today = new Date();
      for (let i = 0; i < weeksBack * 7; i++) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        let shouldAdd = false;
        if (frequency === 'daily') shouldAdd = Math.random() > 0.15;
        else if (frequency === 'every-2-3-days') shouldAdd = i % 2 === 0 && Math.random() > 0.2;
        else if (frequency === 'weekly') shouldAdd = i % 7 === 0 && Math.random() > 0.1;
        else if (frequency === 'monthly') shouldAdd = i % 28 === 0;
        if (shouldAdd) history.push(formatDate(date));
      }
      return history;
    };

    const generateDemoData = () => {
      const today = new Date();
      const demoPeople = [
        // Mitchells family - 2 adults with prayer points, grouped children
        { id: 'p1', firstName: 'Hannah', lastName: 'Mitchell', organisation: '', prayerPoint: 'Healing from surgery\nPeace during recovery', isChild: false, individualCheckbox: true },
        { id: 'p2', firstName: 'Thomas', lastName: 'Mitchell', organisation: '', prayerPoint: 'Job interview this week\nWisdom in career decisions', isChild: false, individualCheckbox: true },
        { id: 'p3', firstName: 'Emma', lastName: 'Mitchell', organisation: '', prayerPoint: '', isChild: true, individualCheckbox: false },
        { id: 'p4', firstName: 'Liam', lastName: 'Mitchell', organisation: '', prayerPoint: '', isChild: true, individualCheckbox: false },
        // David Chen - person with name, organisation, and multiple prayer points
        { id: 'p5', firstName: 'David', lastName: 'Chen', organisation: 'Christ Central Church', prayerPoint: 'Wisdom for church direction\nNew building project\nStaff team unity', isChild: false, individualCheckbox: true },
        // City Youth Outreach - organisation only (no name) with multiple prayer points
        { id: 'p6', firstName: '', lastName: '', organisation: 'City Youth Outreach', prayerPoint: 'Volunteer recruitment\nYouth camp planning\nFunding for new programs', isChild: false, individualCheckbox: true },
        // Sarah - just a first name, no other details
        { id: 'p7', firstName: 'Sarah', lastName: '', organisation: '', prayerPoint: '', isChild: false, individualCheckbox: true },
        // Lisa - single mother with unnamed children
        { id: 'p8', firstName: 'Lisa', lastName: 'Thompson', organisation: '', prayerPoint: 'Strength as a single mum\nFinancial provision', isChild: false, individualCheckbox: true },
        // Other people for variety
        { id: 'p9', firstName: 'Grace', lastName: 'Warren', organisation: '', prayerPoint: 'Peace and direction', isChild: false, individualCheckbox: true },
        { id: 'p10', firstName: 'Nathan', lastName: 'Reynolds', organisation: '', prayerPoint: '', isChild: false, individualCheckbox: true },
        { id: 'p11', firstName: 'Craig', lastName: 'Thompson', organisation: '', prayerPoint: 'Marriage restoration', isChild: false, individualCheckbox: true },
        { id: 'p12', firstName: 'Ben', lastName: 'Parker', organisation: '', prayerPoint: '', isChild: false, individualCheckbox: true },
        { id: 'p13', firstName: 'Victoria', lastName: 'Greene', organisation: '', prayerPoint: 'Confidence at school', isChild: false, individualCheckbox: true },
        { id: 'p14', firstName: 'Mark', lastName: 'Stevens', organisation: 'OMF Thailand', prayerPoint: 'Protection and provision\nTeam health\nLocal partnerships', isChild: false, individualCheckbox: true },
        // Torres Family
        { id: 'p15', firstName: 'Michael', lastName: 'Torres', organisation: '', prayerPoint: 'Financial breakthrough', isChild: false, individualCheckbox: true },
        { id: 'p16', firstName: 'Claire', lastName: 'Torres', organisation: '', prayerPoint: '', isChild: false, individualCheckbox: true },
        { id: 'p17', firstName: 'Sophie', lastName: 'Torres', organisation: '', prayerPoint: '', isChild: true, individualCheckbox: false },
      ];

      const generateHistoryForFrequency = (frequency, personId, prayerPoint) => {
        const history = [];
        const today = new Date();
        
        // Sample historical prayer points that vary over time
        const historicalPoints = {
          p1: ['Healing from surgery\nPeace during recovery', 'Pre-surgery preparations\nStrength and courage', 'Recovery going well\nPhysical therapy progress'],
          p2: ['Job interview this week\nWisdom in career decisions', 'Waiting on job offer\nPatience and trust', 'Starting new role\nSmooth transition'],
          p5: ['Wisdom for church direction\nNew building project\nStaff team unity', 'Building leadership team', 'Vision for 2026'],
          p6: ['Volunteer recruitment\nYouth camp planning\nFunding for new programs', 'Youth camp planning\nFunding needs', 'New youth leaders'],
          p8: ['Strength as a single mum\nFinancial provision', 'Kids settling into school\nWork-life balance', 'Support network growing'],
          p9: ['Peace and direction', 'New opportunities arising\nDiscernment needed', 'Grateful for clarity'],
          p11: ['Marriage restoration', 'Communication with spouse\nHealing past hurts', 'Counselling sessions'],
          p13: ['Confidence at school', 'Upcoming exams\nFocus and clarity', 'Friendships at school'],
          p14: ['Protection and provision\nTeam health\nLocal partnerships', 'Team health in Thailand\nLocal partnerships', 'Visa renewal process'],
          p15: ['Financial breakthrough', 'Business decisions\nProvision for family', 'Debt reduction progress']
        };
        
        const cardPoints = {
          c1: ['Family unity and health\nKids schooling', 'Holiday time together\nSafe travels', 'School year starting well'],
          c5: ['Translation projects\nTeam health and unity', 'New language partnerships\nFunding needs', 'Staff transitions\nOngoing projects'],
          c9: ['Torres family provision\nKids schooling', 'Family health', '']
        };
        
        let startDay;
        if (frequency === 'daily') startDay = 1;
        else if (frequency === 'every-2-3-days') startDay = 3;
        else if (frequency === 'weekly') startDay = 7;
        else if (frequency === 'fortnightly') startDay = 14;
        else startDay = 30;
        
        for (let i = startDay; i < 8 * 7; i++) {
          const date = new Date(today);
          date.setDate(date.getDate() - i);
          
          let shouldAdd = false;
          if (frequency === 'daily') shouldAdd = Math.random() > 0.15;
          else if (frequency === 'every-2-3-days') shouldAdd = i % 2 === 0 && Math.random() > 0.2;
          else if (frequency === 'weekly') shouldAdd = i % 7 === 0 && Math.random() > 0.1;
          else if (frequency === 'fortnightly') shouldAdd = i % 14 === 0 && Math.random() > 0.1;
          else if (frequency === 'monthly') shouldAdd = i % 28 === 0;
          
          if (shouldAdd) {
            const pointsArray = historicalPoints[personId] || [prayerPoint || ''];
            const pointIndex = Math.floor(i / 14) % pointsArray.length; // Change points every ~2 weeks
            const personPrayerPoint = pointsArray[pointIndex] || prayerPoint || '';
            
            // Determine which card this person belongs to for card prayer points
            let cardPrayerPoint = '';
            let cardName = '';
            if (['p1', 'p2', 'p3', 'p4'].includes(personId)) {
              const cPoints = cardPoints['c1'] || [''];
              cardPrayerPoint = cPoints[pointIndex % cPoints.length] || '';
              cardName = 'Mitchells';
            } else if (['p10', 'p11', 'p12'].includes(personId)) {
              const cPoints = cardPoints['c5'] || [''];
              cardPrayerPoint = cPoints[pointIndex % cPoints.length] || '';
              cardName = 'Wycliffe Bible Translators';
            } else if (['p15', 'p16', 'p17'].includes(personId)) {
              const cPoints = cardPoints['c9'] || [''];
              cardPrayerPoint = cPoints[pointIndex % cPoints.length] || '';
              cardName = 'Torres Family';
            }
            
            history.push({
              date: formatDate(date),
              personPrayerPoint,
              cardPrayerPoint,
              cardName
            });
          }
        }
        return history;
      };

      const frequencies = { 
        // Mitchells family (daily - shows on first day)
        p1: 'daily', p2: 'daily', p3: 'daily', p4: 'daily', 
        // David Chen with org (daily - shows on first day)
        p5: 'daily',
        // City Youth Outreach org only (daily - shows on first day)
        p6: 'daily',
        // Sarah first name only (daily - shows on first day)
        p7: 'daily',
        // Lisa + children (daily - shows on first day)
        p8: 'daily',
        // Other people with varied frequencies
        p9: 'every-2-3-days',
        p10: 'every-2-3-days', p11: 'every-2-3-days', p12: 'every-2-3-days',
        p13: 'weekly',
        p14: 'fortnightly',
        // Torres family (weekly)
        p15: 'weekly', p16: 'weekly', p17: 'weekly'
      };

      const peopleWithHistory = demoPeople.map(p => ({
        ...p,
        prayerHistory: generateHistoryForFrequency(frequencies[p.id], p.id, p.prayerPoint),
        dateAdded: '2024-10-01',
        firstPrayerCompleted: true
      }));

      const demoCards = [
        // TEST CASE 1: Family with 2 adults (with prayer points), grouped children, and group prayer points
        { id: 'c1', name: 'Mitchells', peopleIds: ['p1', 'p2', 'p3', 'p4'], frequency: 'daily', prayerPoint: 'Family unity and health\nKids schooling', includeUnnamedChildren: false, isGroup: true, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        // TEST CASE 2: Single person with name, organisation, and multiple prayer points
        { id: 'c2', name: 'David Chen', peopleIds: ['p5'], frequency: 'daily', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        // TEST CASE 3: Organisation only (no first/last name) with multiple prayer points
        { id: 'c3', name: 'City Youth Outreach', peopleIds: ['p6'], frequency: 'daily', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        // TEST CASE 4: Just a first name, no other details
        { id: 'c4', name: 'Sarah', peopleIds: ['p7'], frequency: 'daily', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        // TEST CASE 5: Single mother with "and children" (unnamed children)
        { id: 'c8', name: 'Lisa Thompson', peopleIds: ['p8'], frequency: 'daily', prayerPoint: '', includeUnnamedChildren: true, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        // Other cards with varied frequencies
        { id: 'c5', name: 'Wycliffe Bible Translators', peopleIds: ['p10', 'p11', 'p12'], frequency: 'every-2-3-days', prayerPoint: 'Translation projects\nTeam health and unity', includeUnnamedChildren: false, isGroup: true, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        { id: 'c6', name: 'Grace Warren', peopleIds: ['p9'], frequency: 'every-2-3-days', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        { id: 'c7', name: 'Victoria Greene', peopleIds: ['p13'], frequency: 'weekly', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        { id: 'c9', name: 'Torres Family', peopleIds: ['p15', 'p16', 'p17'], frequency: 'weekly', prayerPoint: 'Torres family provision\nKids schooling', includeUnnamedChildren: true, isGroup: true, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
        { id: 'c10', name: 'Mark Stevens', peopleIds: ['p14'], frequency: 'fortnightly', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: '2024-10-01', firstPrayerCompleted: true },
      ];

      return { people: peopleWithHistory, cards: demoCards };
    };

    const getStored = (key, fallback) => { 
      try { 
        const s = localStorage.getItem(key); 
        return s ? JSON.parse(s) : fallback; 
      } catch { 
        return fallback; 
      } 
    };
    

    function PrayerCompanion() {
      const [people, setPeople] = useState(() => getStored('prayerApp_people', []));
      const [cards, setCards] = useState(() => getStored('prayerApp_cards', []));
      const [session, setSession] = useState(() => getStored('prayerApp_session', null));
      const [screen, setScreen] = useState('home');
      const [currentCardIndex, setCurrentCardIndex] = useState(0);
      const [touchStart, setTouchStart] = useState(null);
      const [slideDirection, setSlideDirection] = useState(null);
      const [selectedPeopleForGroup, setSelectedPeopleForGroup] = useState([]);
      const [editingPerson, setEditingPerson] = useState(null);
      const [editingCard, setEditingCard] = useState(null);
      const [viewingStats, setViewingStats] = useState(null);
      const [statsMonth, setStatsMonth] = useState(new Date());
      const [sortBy, setSortBy] = useState('lastName');
      const [sortReversed, setSortReversed] = useState(false);
      const [cardSortBy, setCardSortBy] = useState('name');
      const [manageTab, setManageTab] = useState('people');
      const [historyTab, setHistoryTab] = useState('people');
      const [selectedHistoryDate, setSelectedHistoryDate] = useState(null);
      const [sortDropdownOpen, setSortDropdownOpen] = useState(false);
      const [freqDropdownOpen, setFreqDropdownOpen] = useState(false);
      const [personForm, setPersonForm] = useState({ firstName: '', lastName: '', organisation: '', prayerPoint: '', frequency: 'daily', isChild: false, individualCheckbox: true });
      const [cardForm, setCardForm] = useState({ name: '', frequency: 'daily', prayerPoint: '', includeUnnamedChildren: false });
      const [groupForm, setGroupForm] = useState({ name: '', frequency: 'weekly', prayerPoint: '', includeUnnamedChildren: false });
      const [groupStep, setGroupStep] = useState(1);
      const [checkboxOverrides, setCheckboxOverrides] = useState({});
      
      // Refs for form field navigation
      const firstNameRef = useRef(null);
      const lastNameRef = useRef(null);
      const organisationRef = useRef(null);
      const prayerPointsRef = useRef(null);
      const groupNameRef = useRef(null);
      const groupPrayerPointsRef = useRef(null);
      const [modal, setModal] = useState(null);
      const [demoMode, setDemoMode] = useState(() => getStored('prayerApp_demoMode', false));
      const [helpOpen, setHelpOpen] = useState(false);
      const [openAccordions, setOpenAccordions] = useState({});
      const [userName, setUserName] = useState(() => getStored('prayerApp_userName', ''));
      const [onboardingComplete, setOnboardingComplete] = useState(() => getStored('prayerApp_onboardingComplete', false));
      const [onboardingStep, setOnboardingStep] = useState(1);
      const [tutorialActive, setTutorialActive] = useState(false);
      const [tutorialStep, setTutorialStep] = useState(0);
      const [nameInput, setNameInput] = useState('');
      const [editingName, setEditingName] = useState(false);
      const [editNameInput, setEditNameInput] = useState('');
      const [searchTerm, setSearchTerm] = useState('');
      const [dataModalOpen, setDataModalOpen] = useState(false);
      const [dataModalStep, setDataModalStep] = useState('main'); // 'main', 'confirmUpload'
      const [pendingUploadData, setPendingUploadData] = useState(null);
      
      // PWA Update Modal State
      const [updateModalOpen, setUpdateModalOpen] = useState(false);
      const [waitingWorker, setWaitingWorker] = useState(null);
      const [updateDownloaded, setUpdateDownloaded] = useState(false);
      
      // PWA Install prompt state
      const [deferredInstallPrompt, setDeferredInstallPrompt] = useState(null);
      const [isStandalone, setIsStandalone] = useState(false);
      const [isIOS, setIsIOS] = useState(false);
      const [isMobile, setIsMobile] = useState(false);
      
      // Detect standalone mode, iOS, and mobile on mount
      useEffect(() => {
        // Check if already running as installed PWA
        const standalone = window.matchMedia('(display-mode: standalone)').matches || 
                          window.navigator.standalone === true;
        setIsStandalone(standalone);
        
        // Detect iOS
        const iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        setIsIOS(iOS);
        
        // Detect mobile/tablet (skip install modal on desktop)
        const mobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) ||
                      window.innerWidth <= 1024;
        setIsMobile(mobile);
        
        // Listen for PWA install prompt (Android/Chrome)
        const handleBeforeInstallPrompt = (e) => {
          e.preventDefault();
          setDeferredInstallPrompt(e);
        };
        
        window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
        
        return () => {
          window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
        };
      }, []);
      
      // Data version for future migrations
      const DATA_VERSION = 1;
      const [cardScrollState, setCardScrollState] = useState({ canScrollDown: false, canScrollUp: false });
      const cardScrollRef = React.useRef(null);
      const [cardContentScrollState, setCardContentScrollState] = useState({ canScrollDown: false, canScrollUp: false, needsScroll: false });
      const cardContentScrollRef = React.useRef(null);
      const cardContentScrollRefPortrait = React.useRef(null);
      const cardContentScrollRefLandscape = React.useRef(null);
      const greetingPortraitRef = React.useRef(null);
      const greetingLandscapeRef = React.useRef(null);
      const [greetingPortraitFontSize, setGreetingPortraitFontSize] = useState(null);
      const [greetingLandscapeFontSize, setGreetingLandscapeFontSize] = useState(null);

      // Calculate font size to fit text within available width
      const calculateGreetingFontSize = (text, availableWidth, padding = 0, minSize = 16, maxSize = 40) => {
        if (!availableWidth || availableWidth <= 0) return maxSize;
        const width = availableWidth - padding;
        if (width <= 0) return minSize;
        
        // Create a temporary element to measure actual text width
        const tempEl = document.createElement('span');
        tempEl.style.position = 'absolute';
        tempEl.style.visibility = 'hidden';
        tempEl.style.whiteSpace = 'nowrap';
        tempEl.style.fontFamily = '"Oranienbaum", serif';
        tempEl.style.fontWeight = '400';
        tempEl.textContent = text;
        document.body.appendChild(tempEl);
        
        // Binary search for the right font size
        let low = minSize;
        let high = maxSize;
        let bestSize = maxSize;
        
        while (low <= high) {
          const mid = Math.floor((low + high) / 2);
          tempEl.style.fontSize = `${mid}px`;
          const textWidth = tempEl.offsetWidth;
          
          if (textWidth <= width) {
            bestSize = mid;
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        
        document.body.removeChild(tempEl);
        return Math.max(minSize, Math.min(maxSize, bestSize));
      };

      // "Morning Prayer" - warm parchment, golden hour glow
      const colors = {
        bg: '#EDE4D8', 
        bgGradient: 'linear-gradient(160deg, #F5EEE4 0%, #E8DECE 50%, #EDE4D8 100%)', 
        cardBg: '#FAF7F2', 
        cardBgGradient: 'linear-gradient(145deg, #FFFFFF 0%, #F5F0E8 100%)',
        text: '#3D352C', 
        textSecondary: '#6B5D4F', 
        textTertiary: '#8C7B6A',
        primary: '#B87A4A', 
        primaryGradient: 'linear-gradient(135deg, #D49A5A 0%, #A66830 100%)', 
        primaryText: '#FFFFFF',
        secondary: '#E4D9CA', 
        secondaryGradient: 'linear-gradient(135deg, #EDE4D6 0%, #D9CDBF 100%)',
        secondaryText: '#4A3F34', 
        accent: '#5A9E78', 
        accentGradient: 'linear-gradient(135deg, #6DB88A 0%, #4A8862 100%)',
        danger: '#C4635E', 
        dangerGradient: 'linear-gradient(135deg, #D4736D 0%, #A8504B 100%)', 
        border: '#D4C8B8', 
        checkboxBg: '#DED4C6', 
        checkboxChecked: '#B87A4A',
        cardShadow: '0 4px 20px rgba(90,70,50,0.12), 0 1px 3px rgba(90,70,50,0.08)', 
        inputBg: '#FAF7F2',
        inputBorder: '#D4C8B8'
      };

      const baseBtn = { border: 'none', borderRadius: '14px', cursor: 'pointer', fontWeight: '600', transition: 'all 0.2s ease', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', fontFamily: 'inherit' };
      const styles = {
        container: { fontFamily: "'Open Sans', -apple-system, BlinkMacSystemFont, sans-serif", background: colors.bgGradient, color: colors.text, padding: '16px', paddingTop: '12px', boxSizing: 'border-box', margin: '0 auto' },
        header: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px', minHeight: '44px' },
        btnPrimary: { ...baseBtn, width: '100%', padding: '18px 24px', fontSize: '17px', background: colors.primaryGradient, color: colors.primaryText, boxShadow: '0 6px 24px rgba(184,122,74,0.35), 0 2px 8px rgba(184,122,74,0.25)' },
        btnSecondary: { ...baseBtn, padding: '14px 20px', fontSize: '15px', background: colors.secondaryGradient, color: colors.secondaryText, flex: 1, border: `1px solid ${colors.border}` },
        btnText: { background: 'none', border: 'none', color: colors.primary, fontSize: '17px', fontWeight: '500', cursor: 'pointer', padding: '8px 0', fontFamily: 'inherit' },
        btnDanger: { ...baseBtn, width: '100%', padding: '16px 20px', fontSize: '16px', background: colors.dangerGradient, color: '#FFF', marginTop: '16px' },
        btnArchive: { ...baseBtn, padding: '16px 20px', fontSize: '16px', background: 'linear-gradient(135deg, #8C7B6A 0%, #6B5D4F 100%)', color: '#FFF', flex: 1 },
        btnSmall: { ...baseBtn, padding: '8px 14px', fontSize: '13px', background: colors.secondaryGradient, color: colors.textSecondary, borderRadius: '10px', border: `1px solid ${colors.border}` },
        buttonRow: { display: 'flex', gap: '12px', marginBottom: '12px' },
        card: { background: colors.cardBgGradient || colors.cardBg, borderRadius: '20px', padding: '20px', marginBottom: '12px', boxShadow: colors.cardShadow, border: `1px solid ${colors.border}` },
        cardFullScreen: { flex: 1, display: 'flex', flexDirection: 'column', marginBottom: '0', minHeight: 0 },
        listItem: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '12px 14px', background: colors.cardBgGradient || colors.cardBg, borderRadius: '12px', marginBottom: '6px', cursor: 'pointer', boxShadow: colors.cardShadow, border: `1px solid ${colors.border}` },
        listItemName: { fontSize: '16px', fontWeight: '500' },
        listItemMeta: { fontSize: '15px', color: colors.textSecondary, fontWeight: '500' },
        input: { width: '100%', padding: '12px 16px', fontSize: '16px', backgroundColor: colors.inputBg, border: `1px solid ${colors.inputBorder || colors.border}`, borderRadius: '12px', color: colors.text, marginBottom: '12px', boxSizing: 'border-box', fontFamily: 'inherit', outline: 'none' },
        label: { display: 'block', fontSize: '12px', fontWeight: '600', color: colors.textSecondary, marginBottom: '6px', textTransform: 'uppercase', letterSpacing: '0.5px' },
        select: { width: '100%', padding: '12px 16px', fontSize: '16px', backgroundColor: colors.inputBg, border: `1px solid ${colors.inputBorder || colors.border}`, borderRadius: '12px', color: colors.text, marginBottom: '12px', boxSizing: 'border-box', fontFamily: 'inherit', appearance: 'none' },
        toggle: { display: 'flex', gap: '8px', marginBottom: '12px', background: colors.secondaryGradient, borderRadius: '12px', padding: '4px', border: `1px solid ${colors.border}` },
        toggleOption: { flex: 1, padding: '10px', textAlign: 'center', borderRadius: '10px', cursor: 'pointer', fontSize: '14px', fontWeight: '500', transition: 'all 0.2s ease' },
        toggleActive: { background: colors.primaryGradient, color: colors.primaryText, boxShadow: '0 2px 12px rgba(184,122,74,0.3)' },
        toggleInactive: { backgroundColor: 'transparent', color: colors.textSecondary },
        tabs: { display: 'flex', marginBottom: '12px', background: colors.secondaryGradient, borderRadius: '12px', padding: '4px', border: `1px solid ${colors.border}` },
        tab: { flex: 1, padding: '10px', textAlign: 'center', borderRadius: '10px', cursor: 'pointer', fontSize: '14px', fontWeight: '500', border: 'none', fontFamily: 'inherit' },
        cardHeaderRow: { display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '12px' },
        cardTitle: { fontSize: '15px', fontWeight: '600', color: colors.textSecondary, textTransform: 'uppercase', letterSpacing: '0.5px' },
        cardFrequency: { fontSize: '13px', color: colors.textSecondary, background: colors.secondaryGradient, padding: '4px 10px', borderRadius: '8px', fontWeight: '500', border: `1px solid ${colors.border}` },
        cardPrayerPoint: { fontSize: '15px', color: colors.textSecondary, marginBottom: '16px', fontStyle: 'italic', lineHeight: '1.5', textAlign: 'center' },
        nameRowContainer: { display: 'flex', flexDirection: 'column', marginBottom: '4px' },
        nameRow: { display: 'flex', alignItems: 'center', cursor: 'pointer', padding: '8px 0' },
        nameCheckbox: { borderRadius: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center', fontWeight: '700', color: '#FFF', flexShrink: 0, transition: 'all 0.2s ease' },
        namePrayerPoint: { fontSize: '14px', color: colors.textSecondary, fontStyle: 'italic', marginTop: '2px', lineHeight: '1.4' },
        singlePersonContent: { flex: 1, display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', padding: '20px 0' },
        singleNameRow: { display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', padding: '12px' },
        singlePrayerPoint: { fontSize: '16px', color: colors.textSecondary, textAlign: 'center', marginTop: '20px', fontStyle: 'italic', maxWidth: '85%', lineHeight: '1.5' },
        groupNamesContainer: { display: 'flex', flexDirection: 'column', padding: '12px 0' },
        adultsSection: { display: 'flex', flexDirection: 'column', gap: '4px' },
        childrenDivider: { height: '1px', backgroundColor: colors.border, margin: '16px 0' },
        childrenNamesSection: { display: 'flex', flexDirection: 'column', gap: '4px' },
        swipeButtons: { display: 'flex', justifyContent: 'center', gap: '24px', marginTop: '16px' },
        swipeButton: { width: '56px', height: '56px', borderRadius: '28px', background: colors.cardBgGradient || colors.cardBg, border: `1px solid ${colors.border}`, fontSize: '22px', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', color: colors.text, boxShadow: colors.cardShadow },
        swipeHint: { textAlign: 'center', color: colors.textTertiary, fontSize: '14px', marginTop: '12px', fontWeight: '500' },
        calendar: { background: colors.cardBgGradient || colors.cardBg, borderRadius: '20px', padding: '20px', boxShadow: colors.cardShadow, border: `1px solid ${colors.border}` },
        calendarHeader: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' },
        calendarGrid: { display: 'grid', gridTemplateColumns: 'repeat(7, 1fr)', gap: '6px', textAlign: 'center' },
        calendarDay: { padding: '10px 4px', fontSize: '15px', borderRadius: '10px', fontWeight: '500' },
        calendarDayHeader: { fontSize: '12px', color: colors.textTertiary, fontWeight: '600', padding: '8px 4px', textTransform: 'uppercase' },
        prayedDay: { background: colors.accentGradient, color: '#FFF', fontWeight: '600' },
        navButton: { background: 'none', border: 'none', fontSize: '20px', cursor: 'pointer', padding: '8px 12px', color: colors.primary, fontWeight: '600' },
        greeting: { fontSize: '28px', fontWeight: '700', textAlign: 'center', marginTop: '32px', marginBottom: '8px', letterSpacing: '-0.5px' },
        subGreeting: { fontSize: '16px', color: colors.textSecondary, textAlign: 'center', marginBottom: '32px' },
        emptyState: { textAlign: 'center', color: colors.textSecondary, padding: '60px 20px', fontSize: '16px', lineHeight: '1.6' },
        sortRow: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', width: '100%', marginBottom: '12px' },
        sortDropdown: { position: 'relative', marginBottom: '12px' },
        sortTrigger: { padding: '10px 14px', paddingRight: '32px', fontSize: '14px', background: colors.secondary, border: `1px solid ${colors.border}`, borderRadius: '10px', color: colors.text, fontWeight: '500', fontFamily: 'inherit', outline: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '8px', height: '42px', boxSizing: 'border-box' },
        sortMenu: { position: 'absolute', top: '100%', left: 0, marginTop: '4px', background: colors.cardBg, border: `1px solid ${colors.border}`, borderRadius: '12px', boxShadow: colors.cardShadow, overflow: 'hidden', zIndex: 100, minWidth: '160px' },
        sortOption: { padding: '12px 16px', fontSize: '14px', color: colors.text, cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '10px', transition: 'background 0.15s ease' },
        sortOptionActive: { background: colors.primary + '20', color: colors.primary, fontWeight: '600' },
        reverseBtn: { width: '42px', height: '42px', fontSize: '16px', background: colors.secondary, border: `1px solid ${colors.border}`, borderRadius: '10px', color: colors.text, fontWeight: '500', fontFamily: 'inherit', outline: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', boxSizing: 'border-box', paddingBottom: '3px' },
        searchInput: { flex: 1, height: '32px', padding: '0 14px', fontSize: '14px', background: colors.inputBg, border: `1px solid ${colors.border}`, borderRadius: '16px', color: colors.text, fontFamily: 'inherit', outline: 'none', margin: '0 12px', minWidth: '80px', maxWidth: '300px', boxSizing: 'border-box' },
        frequencyHeading: { fontSize: '11px', fontWeight: '700', color: colors.textTertiary, textTransform: 'uppercase', letterSpacing: '1px', padding: '16px 0 8px 4px' },
        modalOverlay: { position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000, padding: '20px', boxSizing: 'border-box' },
        modalContent: { background: colors.cardBgGradient || colors.cardBg, borderRadius: '20px', padding: '24px', maxWidth: '340px', width: '100%', boxShadow: '0 8px 40px rgba(0,0,0,0.4)', border: `1px solid ${colors.border}` },
        modalTitle: { fontSize: '18px', fontWeight: '700', marginBottom: '12px', textAlign: 'center', color: colors.text },
        modalMessage: { fontSize: '15px', color: colors.textSecondary, lineHeight: '1.5', marginBottom: '24px', textAlign: 'center' },
        modalButtons: { display: 'flex', gap: '12px' }
      };

      useEffect(() => { 
        localStorage.setItem('prayerApp_people', JSON.stringify(people)); 
        // Also update real data backup if not in demo mode
        if (!demoMode) {
          localStorage.setItem('prayerApp_realPeople', JSON.stringify(people));
        }
      }, [people, demoMode]);
      useEffect(() => { 
        localStorage.setItem('prayerApp_cards', JSON.stringify(cards)); 
        // Also update real data backup if not in demo mode
        if (!demoMode) {
          localStorage.setItem('prayerApp_realCards', JSON.stringify(cards));
        }
      }, [cards, demoMode]);
      useEffect(() => { if (session) localStorage.setItem('prayerApp_session', JSON.stringify(session)); }, [session]);

      // Prevent body/document scrolling - all pages should handle their own scrolling in containers
      useEffect(() => {
        // Body and html are already set to overflow: hidden in CSS
        // This ensures they stay that way and prevents any accidental scrolling
        document.body.style.overflow = 'hidden';
        document.body.style.overscrollBehavior = 'none';
        document.documentElement.style.overflow = 'hidden';
        document.documentElement.style.overscrollBehavior = 'none';
        
        return () => {
          // Don't reset on unmount - keep it hidden globally
        };
      }, []);

      // Calculate greeting font sizes to fit within container width
      useEffect(() => {
        const updateGreetingFontSizes = () => {
          const showContinue = session && !isNewDay();
          const greetingText = showContinue ? `Welcome back, ${userName || 'Friend'}` : getGreeting(userName || 'Friend');
          
          // Portrait greeting
          if (greetingPortraitRef.current) {
            const container = greetingPortraitRef.current.closest('.home-greeting');
            if (container) {
              const containerWidth = container.offsetWidth || window.innerWidth;
              // Account for padding (20px each side) and edit button (~30px)
              const availableWidth = containerWidth - 40 - 30;
              const fontSize = calculateGreetingFontSize(greetingText, availableWidth, 0, 18, 42);
              setGreetingPortraitFontSize(fontSize);
            }
          }
          
          // Landscape greeting
          if (greetingLandscapeRef.current) {
            const container = greetingLandscapeRef.current.parentElement;
            if (container) {
              const containerWidth = container.offsetWidth || window.innerWidth / 2;
              // Account for padding and edit button
              const availableWidth = containerWidth - 20 - 30;
              const fontSize = calculateGreetingFontSize(greetingText, availableWidth, 0, 16, 36);
              setGreetingLandscapeFontSize(fontSize);
            }
          }
        };
        
        // Use requestAnimationFrame to ensure DOM is ready
        const rafId = requestAnimationFrame(() => {
          setTimeout(updateGreetingFontSizes, 50);
        });
        
        window.addEventListener('resize', updateGreetingFontSizes);
        return () => {
          cancelAnimationFrame(rafId);
          window.removeEventListener('resize', updateGreetingFontSizes);
        };
      }, [userName, session, screen]);

      // Update session rotation when cards are edited (e.g., frequency changed to daily)
      useEffect(() => {
        if (!session || session.dateStarted !== getToday()) return;
        
        // Find cards that are due today but not in the current rotation
        const currentRotation = session.cardsInRotation || [];
        const currentTodaysList = session.todaysList || [];
        
        // Check each active card to see if it should be added
        const cardsToAdd = cards.filter(c => {
          if (!c.active) return false;
          if (currentRotation.includes(c.id)) return false; // Already in rotation
          
          // Check if card is due today (simplified check for daily cards or new cards)
          if (c.frequency === 'daily') return true;
          if (!c.firstPrayerCompleted) return true; // New card never prayed for
          
          return false;
        }).map(c => c.id);
        
        if (cardsToAdd.length > 0) {
          setSession(prev => ({
            ...prev,
            cardsInRotation: [...prev.cardsInRotation, ...cardsToAdd],
            todaysList: [...prev.todaysList, ...cardsToAdd]
          }));
        }
      }, [cards, session?.dateStarted]);

      const loadDemoData = () => {
        const { people: dp, cards: dc } = generateDemoData();
        setPeople(dp); setCards(dc); setSession(null);
        localStorage.removeItem('prayerApp_session');
      };
      
      const toggleDemoMode = () => {
        if (demoMode) {
          // Turn off demo mode - restore real user data
          const realPeople = getStored('prayerApp_realPeople', []);
          const realCards = getStored('prayerApp_realCards', []);
          setPeople(realPeople);
          setCards(realCards);
          setSession(null);
          setDemoMode(false);
          localStorage.setItem('prayerApp_demoMode', 'false');
          // Restore real data to main storage
          localStorage.setItem('prayerApp_people', JSON.stringify(realPeople));
          localStorage.setItem('prayerApp_cards', JSON.stringify(realCards));
        } else {
          // Turn on demo mode - save real data first, then load demo data
          localStorage.setItem('prayerApp_realPeople', JSON.stringify(people));
          localStorage.setItem('prayerApp_realCards', JSON.stringify(cards));
          loadDemoData();
          setDemoMode(true);
          localStorage.setItem('prayerApp_demoMode', 'true');
        }
      };
      
      const toggleAccordion = (id) => {
        setOpenAccordions(prev => ({ ...prev, [id]: !prev[id] }));
      };
      
      const capitalizeFirstLetter = (str) => {
        return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
      };
      
      const handleNameSubmit = () => {
        if (nameInput.trim()) {
          const capitalizedName = capitalizeFirstLetter(nameInput.trim());
          setUserName(capitalizedName);
          localStorage.setItem('prayerApp_userName', JSON.stringify(capitalizedName));
          setOnboardingStep(2);
        }
      };
      
      // Onboarding flow:
      // Step 1: Name input
      // Step 2: Demo content choice
      // Step 3: Install to home screen prompt
      // Step 4: How to use prompt
      const [pendingDemoChoice, setPendingDemoChoice] = useState(false);
      
      const handleDemoChoice = (enableDemo) => {
        // Save the demo choice to apply at the end
        setPendingDemoChoice(enableDemo);
        // Move to install prompt step
        setOnboardingStep(3);
      };
      
      const handleInstallPrompt = async () => {
        // Try to trigger the native install prompt (Android/Chrome)
        if (deferredInstallPrompt) {
          try {
            deferredInstallPrompt.prompt();
            const choice = await deferredInstallPrompt.userChoice;
            // Clear the prompt after use
            setDeferredInstallPrompt(null);
          } catch (err) {
            console.log('Install prompt error:', err);
          }
        }
        // Move to How to Use step
        setOnboardingStep(4);
      };
      
      const skipInstall = () => {
        // Move to How to Use step
        setOnboardingStep(4);
      };
      
      const finalizeOnboarding = (startTutorial = false) => {
        // Apply demo mode if chosen
        if (pendingDemoChoice) {
          // Save current (empty) real data first
          localStorage.setItem('prayerApp_realPeople', JSON.stringify(people));
          localStorage.setItem('prayerApp_realCards', JSON.stringify(cards));
          loadDemoData();
          setDemoMode(true);
          localStorage.setItem('prayerApp_demoMode', 'true');
          // Reset session so button shows "Start Praying" for fresh demo experience
          setSession(null);
          localStorage.removeItem('prayerApp_session');
        }
        // Mark onboarding as complete
        setOnboardingComplete(true);
        localStorage.setItem('prayerApp_onboardingComplete', 'true');
        // Start tutorial if requested
        if (startTutorial) {
          setTutorialActive(true);
          setTutorialStep(0);
        }
      };
      
      // Tutorial steps configuration
      const tutorialSteps = [
        {
          id: 'welcome',
          title: 'Welcome to Your Home Screen',
          text: 'This is your prayer dashboard. From here you can start praying, add people, and access all features of the app.',
          target: null, // No specific target for welcome
          position: 'center'
        },
        {
          id: 'start-praying',
          title: 'Start Your Daily Prayers',
          text: 'Tap this button to begin your prayer session. Cards will appear for each person or group scheduled for today.',
          target: 'start-praying-btn',
          position: 'top'
        },
        {
          id: 'add-person',
          title: 'Add Someone to Pray For',
          text: 'Add individuals to your prayer list. You can include their name, organisation, prayer points, and how often you want to pray for them.',
          target: 'add-person-btn',
          position: 'top'
        },
        {
          id: 'create-group',
          title: 'Create Prayer Groups',
          text: 'Combine people into groups like families or communities. This way you can pray for multiple people on one card.',
          target: 'create-group-btn',
          position: 'top'
        },
        {
          id: 'manage',
          title: 'People & Groups',
          text: 'View and edit everyone in your prayer list. You can update details, change frequencies, or remove people here.',
          target: 'manage-btn',
          position: 'top'
        },
        {
          id: 'history',
          title: 'Prayer History',
          text: 'See your prayer history for each person. A calendar view shows which days you prayed and what prayer points were used.',
          target: 'history-btn',
          position: 'top'
        },
        {
          id: 'help',
          title: 'How to Use',
          text: 'Tap this button anytime to access detailed help and instructions for all features.',
          target: 'help-btn',
          position: 'bottom'
        },
        {
          id: 'backup',
          title: 'Backup & Restore',
          text: 'Your data is stored on this device. Use this button to download a backup or restore from a previous backup.',
          target: 'backup-btn',
          position: 'bottom'
        },
        {
          id: 'demo',
          title: 'Demo Mode',
          text: 'Toggle Demo Mode on or off anytime to explore the app with sample data. Great for learning how everything works before adding your own people.',
          target: 'demo-btn',
          position: 'bottom'
        },
        {
          id: 'finish',
          title: "You're Ready!",
          text: demoMode 
            ? "Demo mode is active with sample data. Try tapping 'Start Praying' to see how it works! You can restart this tutorial from the How to Use section."
            : "You're all set! Start by adding someone to pray for, or try Demo Mode to explore with sample data. You can restart this tutorial from the How to Use section.",
          target: null,
          position: 'center'
        }
      ];
      
      const nextTutorialStep = () => {
        if (tutorialStep < tutorialSteps.length - 1) {
          setTutorialStep(tutorialStep + 1);
        } else {
          setTutorialActive(false);
          setTutorialStep(0);
        }
      };
      
      const skipTutorial = () => {
        setTutorialActive(false);
        setTutorialStep(0);
      };
      
      const restartTutorial = () => {
        setHelpOpen(false);
        setTutorialActive(true);
        setTutorialStep(0);
      };
      
      // Legacy function for compatibility (if needed)
      const completeOnboarding = (enableDemo) => {
        if (enableDemo) {
          loadDemoData();
          setDemoMode(true);
          localStorage.setItem('prayerApp_demoMode', 'true');
        }
        setOnboardingComplete(true);
        localStorage.setItem('prayerApp_onboardingComplete', 'true');
      };
      
      const openEditName = () => {
        setEditNameInput(userName);
        setEditingName(true);
      };
      
      const saveEditedName = () => {
        if (editNameInput.trim()) {
          const capitalizedName = capitalizeFirstLetter(editNameInput.trim());
          setUserName(capitalizedName);
          localStorage.setItem('prayerApp_userName', JSON.stringify(capitalizedName));
          setEditingName(false);
        }
      };
      
      const downloadData = (fromUpdateModal = false) => {
        try {
          // Always export real user data, not demo data
          // If in demo mode, get the saved real data from localStorage
          const exportPeople = demoMode ? getStored('prayerApp_realPeople', []) : people;
          const exportCards = demoMode ? getStored('prayerApp_realCards', []) : cards;
          
          const exportData = {
            version: DATA_VERSION,
            exportDate: new Date().toISOString(),
            userName,
            people: exportPeople,
            cards: exportCards
            // Note: demoMode is intentionally not exported - it's a viewing preference, not user data
          };
          const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `prayer-companion-backup-${new Date().toISOString().split('T')[0]}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (err) {
          console.error('Download error:', err);
        }
        
        // If called from update modal, enable the update button regardless
        if (fromUpdateModal) {
          setUpdateDownloaded(true);
        } else {
          setDataModalOpen(false);
          setDataModalStep('main');
        }
      };
      
      // Show update modal when a new service worker is waiting
      const showUpdateModal = (worker) => {
        if (worker) {
          setWaitingWorker(worker);
          // Only reset updateDownloaded if modal isn't already open
          // This prevents resetting after user has already clicked Download
          setUpdateModalOpen(prev => {
            if (!prev) {
              // Modal is being opened for first time, reset the downloaded state
              setUpdateDownloaded(false);
            }
            return true;
          });
        }
      };
      
      // Handle update button click - activate the new service worker
      const handleUpdateApp = () => {
        if (!isMobile) {
          // Desktop: Hard reload with cache clear
          setUpdateModalOpen(false);
          setWaitingWorker(null);
          setUpdateDownloaded(false);
          // Clear caches and reload
          if ('caches' in window) {
            caches.keys().then(names => {
              Promise.all(names.map(name => caches.delete(name))).then(() => {
                window.location.reload(true);
              });
            });
          } else {
            window.location.reload(true);
          }
        } else if (waitingWorker) {
          // Mobile: Send message to service worker to skip waiting
          waitingWorker.postMessage({ type: 'SKIP_WAITING' });
          setUpdateModalOpen(false);
          setWaitingWorker(null);
          setUpdateDownloaded(false);
          // The controllerchange event will reload the page
        }
      };
      
      // Listen for service worker update notifications
      useEffect(() => {
        const handleSWWaiting = (event) => {
          if (event.detail) {
            showUpdateModal(event.detail);
          }
        };
        
        window.addEventListener('sw-waiting', handleSWWaiting);
        
        return () => {
          window.removeEventListener('sw-waiting', handleSWWaiting);
        };
      }, []); // Empty deps - showUpdateModal uses stable state setters
      
      const handleFileUpload = (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            if (!data.version || !data.people || !data.cards) {
              alert('Invalid backup file. Please select a valid Prayer Companion backup.');
              return;
            }
            setPendingUploadData(data);
            setDataModalStep('confirmUpload');
          } catch (err) {
            alert('Could not read file. Please select a valid JSON backup file.');
          }
        };
        reader.readAsText(file);
        event.target.value = ''; // Reset file input
      };
      
      const confirmUpload = () => {
        if (!pendingUploadData) return;
        
        // Restore data - always restore as real user data, not demo mode
        const restoredPeople = pendingUploadData.people || [];
        const restoredCards = pendingUploadData.cards || [];
        
        setPeople(restoredPeople);
        setCards(restoredCards);
        setUserName(pendingUploadData.userName || '');
        setDemoMode(false); // Always turn off demo mode when restoring
        setSession(null);
        
        // Save to localStorage - both main storage and real data backup
        localStorage.setItem('prayerApp_people', JSON.stringify(restoredPeople));
        localStorage.setItem('prayerApp_cards', JSON.stringify(restoredCards));
        localStorage.setItem('prayerApp_realPeople', JSON.stringify(restoredPeople));
        localStorage.setItem('prayerApp_realCards', JSON.stringify(restoredCards));
        localStorage.setItem('prayerApp_userName', JSON.stringify(pendingUploadData.userName || ''));
        localStorage.setItem('prayerApp_demoMode', 'false');
        localStorage.removeItem('prayerApp_session');
        
        setPendingUploadData(null);
        setDataModalStep('main');
        setDataModalOpen(false);
      };
      
      const checkCardScroll = () => {
        const el = cardScrollRef.current;
        if (!el) return;
        const canScrollDown = el.scrollHeight > el.clientHeight && el.scrollTop < el.scrollHeight - el.clientHeight - 5;
        const canScrollUp = el.scrollTop > 5;
        setCardScrollState({ canScrollDown, canScrollUp });
      };
      
      const checkCardContentScroll = () => {
        // Check which ref is actually visible (not hidden by CSS)
        let el = null;
        
        // Check portrait ref first
        if (cardContentScrollRefPortrait.current) {
          const style = window.getComputedStyle(cardContentScrollRefPortrait.current);
          if (style.display !== 'none' && style.visibility !== 'hidden') {
            el = cardContentScrollRefPortrait.current;
          }
        }
        
        // Check landscape ref if portrait not visible
        if (!el && cardContentScrollRefLandscape.current) {
          const style = window.getComputedStyle(cardContentScrollRefLandscape.current);
          if (style.display !== 'none' && style.visibility !== 'hidden') {
            el = cardContentScrollRefLandscape.current;
          }
        }
        
        // Fallback to single person card ref
        if (!el && cardContentScrollRef.current) {
          const style = window.getComputedStyle(cardContentScrollRef.current);
          if (style.display !== 'none' && style.visibility !== 'hidden') {
            el = cardContentScrollRef.current;
          }
        }
        
        // If refs not set, find the visible scrollable element by querying DOM
        if (!el) {
          const portraitEl = document.querySelector('.portrait-only.card-content-scrollable');
          const landscapeEl = document.querySelector('.landscape-only.card-content-scrollable');
          const singleEl = document.querySelector('.card-content-scrollable:not(.portrait-only):not(.landscape-only)');
          
          // Check which element is actually visible (not hidden by CSS)
          if (portraitEl) {
            const style = window.getComputedStyle(portraitEl);
            if (style.display !== 'none' && style.visibility !== 'hidden') {
              el = portraitEl;
            }
          }
          if (!el && landscapeEl) {
            const style = window.getComputedStyle(landscapeEl);
            if (style.display !== 'none' && style.visibility !== 'hidden') {
              el = landscapeEl;
            }
          }
          if (!el && singleEl) {
            const style = window.getComputedStyle(singleEl);
            if (style.display !== 'none' && style.visibility !== 'hidden') {
              el = singleEl;
            }
          }
        }
        
        if (!el) return;
        const scrollThreshold = 10; // Threshold for detecting scroll position
        const needsScroll = el.scrollHeight > el.clientHeight + scrollThreshold;
        const canScrollDown = needsScroll && el.scrollTop < el.scrollHeight - el.clientHeight - scrollThreshold;
        const canScrollUp = el.scrollTop > scrollThreshold;
        setCardContentScrollState({ canScrollDown, canScrollUp, needsScroll });
      };
      
      const getScrollableElement = () => {
        // Check which ref is actually visible (not hidden by CSS)
        let el = null;
        
        // Check portrait ref first
        if (cardContentScrollRefPortrait.current) {
          const style = window.getComputedStyle(cardContentScrollRefPortrait.current);
          if (style.display !== 'none' && style.visibility !== 'hidden') {
            el = cardContentScrollRefPortrait.current;
          }
        }
        
        // Check landscape ref if portrait not visible
        if (!el && cardContentScrollRefLandscape.current) {
          const style = window.getComputedStyle(cardContentScrollRefLandscape.current);
          if (style.display !== 'none' && style.visibility !== 'hidden') {
            el = cardContentScrollRefLandscape.current;
          }
        }
        
        // Fallback to single person card ref
        if (!el && cardContentScrollRef.current) {
          const style = window.getComputedStyle(cardContentScrollRef.current);
          if (style.display !== 'none' && style.visibility !== 'hidden') {
            el = cardContentScrollRef.current;
          }
        }
        
        // If refs not set, find the visible scrollable element by querying DOM
        if (!el) {
          const portraitEl = document.querySelector('.portrait-only.card-content-scrollable');
          const landscapeEl = document.querySelector('.landscape-only.card-content-scrollable');
          const singleEl = document.querySelector('.card-content-scrollable:not(.portrait-only):not(.landscape-only)');
          
          // Check which element is actually visible (not hidden by CSS)
          if (portraitEl) {
            const style = window.getComputedStyle(portraitEl);
            if (style.display !== 'none' && style.visibility !== 'hidden') {
              el = portraitEl;
            }
          }
          if (!el && landscapeEl) {
            const style = window.getComputedStyle(landscapeEl);
            if (style.display !== 'none' && style.visibility !== 'hidden') {
              el = landscapeEl;
            }
          }
          if (!el && singleEl) {
            const style = window.getComputedStyle(singleEl);
            if (style.display !== 'none' && style.visibility !== 'hidden') {
              el = singleEl;
            }
          }
        }
        
        return el;
      };
      
      const scrollCardContentToBottom = () => {
        const el = getScrollableElement();
        if (!el) return;
        el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' });
        setTimeout(() => checkCardContentScroll(), 300);
      };
      
      const scrollCardContentToTop = () => {
        const el = getScrollableElement();
        if (!el) return;
        el.scrollTo({ top: 0, behavior: 'smooth' });
        setTimeout(() => checkCardContentScroll(), 300);
      };
      
      React.useEffect(() => {
        // Check scroll state when card changes - run multiple times to catch DOM updates
        const check = () => {
          checkCardContentScroll();
        };
        // Immediate check
        check();
        // Check after a short delay for DOM to settle
        const timeout1 = setTimeout(check, 100);
        // Check after a longer delay to catch any async rendering
        const timeout2 = setTimeout(check, 300);
        // Check one more time after a longer delay
        const timeout3 = setTimeout(check, 500);
        return () => {
          clearTimeout(timeout1);
          clearTimeout(timeout2);
          clearTimeout(timeout3);
        };
      }, [currentCardIndex, screen]);
      
      // Also check when card content is rendered (using MutationObserver as fallback)
      React.useEffect(() => {
        const observer = new MutationObserver(() => {
          setTimeout(() => checkCardContentScroll(), 50);
        });
        const target = document.querySelector('.card-content-scrollable');
        if (target) {
          observer.observe(target, { childList: true, subtree: true, attributes: true });
        }
        return () => observer.disconnect();
      }, [currentCardIndex]);
      
      // Also check when window resizes
      React.useEffect(() => {
        const handleResize = () => {
          setTimeout(() => checkCardContentScroll(), 100);
        };
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, []);
      
      React.useEffect(() => {
        checkCardScroll();
      }, [currentCardIndex, screen]);

      const isNewDay = useCallback(() => !session || session.dateStarted !== getToday(), [session]);
      const getLastPrayedDate = useCallback((card) => {
        const cp = card.peopleIds.map(id => people.find(p => p.id === id)).filter(Boolean);
        if (!cp.length) return null;
        const dates = cp.flatMap(p => p.prayerHistory || []);
        return dates.length ? dates.sort().reverse()[0] : null;
      }, [people]);
      const daysSinceLastPrayer = useCallback((card) => {
        const last = getLastPrayedDate(card);
        if (!last) return Infinity;
        return Math.floor((new Date(getToday()) - new Date(last)) / (1000 * 60 * 60 * 24));
      }, [getLastPrayedDate]);
      const isCardDueToday = useCallback((card) => {
        if (!card.active) return false;
        if (!card.firstPrayerCompleted) return true;
        
        const today = new Date();
        const dayOfWeek = today.getDay(); // 0-6 (Sun-Sat)
        const dayOfMonth = today.getDate(); // 1-31
        const days = daysSinceLastPrayer(card);
        
        if (card.frequency === 'daily') return true;
        
        if (card.frequency === 'every-2-3-days') {
          // Spread across 3-day cycles based on card ID
          const slot = getSlotFromId(card.id, 3);
          const todaySlot = dayOfMonth % 3;
          // Due on their slot day, or overdue (4+ days)
          return todaySlot === slot || days >= 4;
        }
        
        if (card.frequency === 'weekly') {
          // Each card assigned to a specific day of week
          const slot = getSlotFromId(card.id, 7);
          // Due on their assigned day, or overdue (9+ days as safety net)
          return dayOfWeek === slot || days >= 9;
        }
        
        if (card.frequency === 'fortnightly') {
          // Each card assigned to a specific day in a 14-day cycle
          const slot = getSlotFromId(card.id, 14);
          const dayInCycle = dayOfMonth % 14;
          // Due on their assigned day, or overdue (16+ days as safety net)
          return dayInCycle === slot || days >= 16;
        }
        
        if (card.frequency === 'monthly') {
          // Each card assigned to a specific day of month (1-28)
          const slot = getSlotFromId(card.id, 28) + 1; // 1-28
          const last = getLastPrayedDate(card);
          if (!last) return true;
          const lastDate = new Date(last);
          const prayedThisMonth = lastDate.getMonth() === today.getMonth() && lastDate.getFullYear() === today.getFullYear();
          // Due on their assigned day if not prayed this month, or if we've passed their day and still not prayed
          if (prayedThisMonth) return false;
          return dayOfMonth >= slot;
        }
        
        return true;
      }, [daysSinceLastPrayer, getLastPrayedDate]);
      const isPriorityCard = useCallback((card) => {
        if (!card.firstPrayerCompleted) return true;
        const days = daysSinceLastPrayer(card);
        // Priority = overdue past their normal window
        if (card.frequency === 'daily') return days >= 1;
        if (card.frequency === 'every-2-3-days') return days >= 4;
        if (card.frequency === 'weekly') return days >= 9;
        if (card.frequency === 'fortnightly') return days >= 16;
        if (card.frequency === 'monthly') {
          // Priority if we're past day 28 and haven't prayed this month
          const today = new Date();
          const last = getLastPrayedDate(card);
          if (!last) return true;
          const lastDate = new Date(last);
          const prayedThisMonth = lastDate.getMonth() === today.getMonth() && lastDate.getFullYear() === today.getFullYear();
          return !prayedThisMonth && today.getDate() > 28;
        }
        return false;
      }, [daysSinceLastPrayer, getLastPrayedDate]);
      const buildTodaysList = useCallback(() => {
        // Filter out archived cards and cards where all members are archived
        const due = cards.filter(c => {
          if (!c.active || c.archived) return false;
          if (!isCardDueToday(c)) return false;
          // For group cards, check if at least one member is not archived
          const activeMembers = c.peopleIds.filter(pid => {
            const p = people.find(x => x.id === pid);
            return p && !p.archived;
          });
          // Card is valid if it has active members or includeUnnamedChildren
          return activeMembers.length > 0 || c.includeUnnamedChildren;
        });
        const shuffle = arr => { const a = [...arr]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; };
        return [...shuffle(due.filter(isPriorityCard)), ...shuffle(due.filter(c => !isPriorityCard(c)))].map(c => c.id);
      }, [cards, people, isCardDueToday, isPriorityCard]);

      const startPraying = () => {
        if (!cards.filter(c => c.active).length) { alert('Add some people first!'); return; }
        const list = buildTodaysList();
        if (!list.length) { alert('No prayers due today!'); return; }
        const checked = {};
        list.forEach(cid => {
          const card = cards.find(c => c.id === cid);
          if (card) {
            checked[cid] = {};
            card.peopleIds.forEach(pid => { const p = people.find(x => x.id === pid); if (p?.individualCheckbox) checked[cid][pid] = false; });
            checked[cid]['_group'] = false;
          }
        });
        setSession({ dateStarted: getToday(), todaysList: list, checkedStatus: checked, currentView: 'flashcard', cardsInRotation: [...list] });
        setCurrentCardIndex(0);
        setScreen('prayer');
      };

      // Helper to get dates from prayer history (handles both old string[] and new object[] formats)
      const getHistoryDates = (history) => {
        if (!history) return [];
        return history.map(h => typeof h === 'string' ? h : h.date);
      };
      
      // Helper to check if a date exists in history
      const hasDateInHistory = (history, date) => getHistoryDates(history).includes(date);
      
      // Helper to get history entry for a specific date
      const getHistoryForDate = (history, date) => {
        if (!history) return null;
        const entry = history.find(h => (typeof h === 'string' ? h : h.date) === date);
        return typeof entry === 'string' ? { date: entry } : entry;
      };

      const toggleCheckbox = (cardId, key) => {
        if (!session) return;
        const newChecked = { ...session.checkedStatus };
        if (!newChecked[cardId]) newChecked[cardId] = {};
        const was = newChecked[cardId][key];
        newChecked[cardId][key] = !was;
        if (!was) {
          const card = cards.find(c => c.id === cardId);
          if (card) {
            const today = getToday();
            const toUpdate = key === '_group' ? card.peopleIds.filter(pid => { const p = people.find(x => x.id === pid); return p && !p.individualCheckbox; }) : [key];
            
            // Create prayer history snapshot with prayer points
            setPeople(prev => prev.map(p => {
              if (!toUpdate.includes(p.id)) return p;
              if (hasDateInHistory(p.prayerHistory, today)) return p;
              
              const historyEntry = {
                date: today,
                personPrayerPoint: p.prayerPoint || '',
                cardPrayerPoint: card.prayerPoint || '',
                cardName: card.name,
                cardId: card.id
              };
              
              return { ...p, prayerHistory: [...(p.prayerHistory || []), historyEntry] };
            }));
            
            if (!card.firstPrayerCompleted) setCards(prev => prev.map(c => c.id === cardId ? { ...c, firstPrayerCompleted: true } : c));
          }
        }
        const newSession = { ...session, checkedStatus: newChecked };
        setSession(newSession);
      };

      const isCardFullyChecked = (cardId, checked = session?.checkedStatus) => {
        if (!checked?.[cardId]) return false;
        const card = cards.find(c => c.id === cardId);
        if (!card) return false;
        
        // Get valid people from the card (people that exist and are not archived)
        const validPeople = card.peopleIds.map(pid => people.find(x => x.id === pid)).filter(p => p && !p.archived);
        
        // If the card has peopleIds but no valid people found, consider it incomplete
        // This handles edge cases where people array might be out of sync
        if (card.peopleIds.length > 0 && validPeople.length === 0 && !card.includeUnnamedChildren) {
          return false;
        }
        
        // Check individual checkboxes
        for (const p of validPeople) { 
          if (p.individualCheckbox && !checked[cardId][p.id]) return false; 
        }
        
        // Check grouped people
        const hasGroupedPeople = validPeople.some(p => !p.individualCheckbox);
        
        if ((hasGroupedPeople || card.includeUnnamedChildren) && !checked[cardId]['_group']) return false;
        
        return true;
      };

      // Get all cards in rotation (including completed ones for display)
      const getAllCardsInRotation = () => session?.cardsInRotation || [];
      // Get only incomplete cards for counting
      const getIncompleteCards = () => (session?.cardsInRotation || []).filter(cid => !isCardFullyChecked(cid));
      const getIncompleteCount = () => getIncompleteCards().length;
      
      // Find the next incomplete card index, starting from a given index
      const findNextIncompleteIndex = (startIndex, direction = 1) => {
        const all = getAllCardsInRotation();
        if (all.length === 0) return -1;
        
        // Check all cards in the given direction
        for (let i = 1; i <= all.length; i++) {
          const idx = (startIndex + (i * direction) + all.length) % all.length;
          if (!isCardFullyChecked(all[idx])) {
            return idx;
          }
        }
        return -1; // All cards are complete
      };
      
      const swipeNext = () => { 
        const nextIdx = findNextIncompleteIndex(currentCardIndex, 1);
        if (nextIdx === -1) {
          // All done - switch to list view
          setSession(s => ({ ...s, currentView: 'list' }));
          return;
        }
        setSlideDirection('right');
        setCurrentCardIndex(nextIdx);
        setTimeout(() => setSlideDirection(null), 250);
      };
      
      const swipePrev = () => { 
        const prevIdx = findNextIncompleteIndex(currentCardIndex, -1);
        if (prevIdx === -1) {
          // All done - switch to list view
          setSession(s => ({ ...s, currentView: 'list' }));
          return;
        }
        setSlideDirection('left');
        setTimeout(() => setSlideDirection(null), 250);
        setCurrentCardIndex(prevIdx); 
      };

      // Touch/swipe handlers for mobile
      const handleTouchStart = (e) => {
        setTouchStart(e.touches[0].clientX);
      };
      
      const handleTouchEnd = (e) => {
        if (touchStart === null) return;
        const touchEnd = e.changedTouches[0].clientX;
        const diff = touchStart - touchEnd;
        const minSwipeDistance = 50; // minimum px to trigger swipe
        
        if (Math.abs(diff) > minSwipeDistance) {
          if (diff > 0) {
            swipeNext(); // swiped left = next
          } else {
            swipePrev(); // swiped right = prev
          }
        }
        setTouchStart(null);
      };

      // Keyboard navigation for desktop
      const handleKeyDown = useCallback((e) => {
        if (screen !== 'prayer' || session?.currentView === 'list') return;
        if (e.key === 'ArrowRight' || e.key === ' ') {
          e.preventDefault();
          swipeNext();
        } else if (e.key === 'ArrowLeft') {
          e.preventDefault();
          swipePrev();
        }
      }, [screen, session?.currentView]);
      
      useEffect(() => {
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [handleKeyDown]);
      
      // Keep card index in bounds
      useEffect(() => {
        const allCards = getAllCardsInRotation();
        if (allCards.length > 0 && currentCardIndex >= allCards.length) {
          setCurrentCardIndex(0);
        }
      }, [session?.cardsInRotation]);

      const addPerson = (data) => {
        const isOrg = !data.firstName && !data.lastName && data.organisation;
        const displayName = isOrg ? data.organisation : `${data.firstName} ${data.lastName}`.trim();
        const np = { id: generateId(), firstName: data.firstName, lastName: data.lastName, organisation: data.organisation || '', prayerPoint: data.prayerPoint || '', isChild: data.isChild || false, individualCheckbox: data.individualCheckbox !== false, prayerHistory: [], dateAdded: getToday(), firstPrayerCompleted: false };
        const nc = { id: generateId(), name: displayName, peopleIds: [np.id], frequency: data.frequency || 'daily', prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: getToday(), firstPrayerCompleted: false };
        setPeople(prev => [...prev, np]); setCards(prev => [...prev, nc]);
      };
      const updatePerson = (pid, data) => {
        setPeople(prev => prev.map(p => p.id === pid ? { ...p, ...data } : p));
        const solo = cards.find(c => c.peopleIds.length === 1 && c.peopleIds[0] === pid && !c.isGroup);
        if (solo) {
          const isOrg = !data.firstName && !data.lastName && data.organisation;
          const displayName = isOrg ? data.organisation : `${data.firstName} ${data.lastName}`.trim();
          setCards(prev => prev.map(c => c.id === solo.id ? { ...c, name: displayName, frequency: data.frequency || c.frequency } : c));
        }
      };
      const deletePerson = (pid) => {
        setCards(prev => prev.map(c => ({ ...c, peopleIds: c.peopleIds.filter(id => id !== pid) })).filter(c => c.peopleIds.length || c.includeUnnamedChildren));
        setPeople(prev => prev.filter(p => p.id !== pid));
      };
      
      const archivePerson = (pid) => {
        setPeople(prev => prev.map(p => p.id === pid ? { ...p, archived: true, archivedDate: getToday() } : p));
        // Also archive their solo card if they have one
        const soloCard = cards.find(c => c.peopleIds.length === 1 && c.peopleIds[0] === pid && !c.isGroup);
        if (soloCard) {
          setCards(prev => prev.map(c => c.id === soloCard.id ? { ...c, archived: true, archivedDate: getToday() } : c));
        }
      };
      
      const unarchivePerson = (pid) => {
        setPeople(prev => prev.map(p => p.id === pid ? { ...p, archived: false, archivedDate: null } : p));
        // Also unarchive their solo card if they have one
        const soloCard = cards.find(c => c.peopleIds.length === 1 && c.peopleIds[0] === pid && !c.isGroup);
        if (soloCard) {
          setCards(prev => prev.map(c => c.id === soloCard.id ? { ...c, archived: false, archivedDate: null } : c));
        }
      };
      
      const archiveCard = (cid) => {
        setCards(prev => prev.map(c => c.id === cid ? { ...c, archived: true, archivedDate: getToday() } : c));
      };
      
      const unarchiveCard = (cid) => {
        setCards(prev => prev.map(c => c.id === cid ? { ...c, archived: false, archivedDate: null } : c));
      };
      const createGroup = (data) => {
        if (data.checkboxOverrides) setPeople(prev => prev.map(p => data.checkboxOverrides[p.id] !== undefined ? { ...p, individualCheckbox: data.checkboxOverrides[p.id] } : p));
        setCards(prev => prev.filter(c => c.isGroup || !c.peopleIds.some(id => data.peopleIds.includes(id))));
        setCards(prev => [...prev, { id: generateId(), name: data.name, peopleIds: data.peopleIds, frequency: data.frequency, prayerPoint: data.prayerPoint || '', includeUnnamedChildren: data.includeUnnamedChildren || false, isGroup: true, active: true, dateCreated: getToday(), firstPrayerCompleted: false }]);
        setSelectedPeopleForGroup([]);
      };
      const updateCard = (cid, data) => setCards(prev => prev.map(c => c.id === cid ? { ...c, ...data } : c));
      const dissolveGroup = (cid) => {
        const card = cards.find(c => c.id === cid);
        if (!card?.isGroup) return;
        // Create individual cards for non-archived members
        card.peopleIds.forEach(pid => { 
          const p = people.find(x => x.id === pid); 
          if (p && !p.archived) {
            setCards(prev => [...prev, { id: generateId(), name: `${p.firstName} ${p.lastName}`.trim() || p.organisation, peopleIds: [pid], frequency: card.frequency, prayerPoint: '', includeUnnamedChildren: false, isGroup: false, active: true, dateCreated: getToday(), firstPrayerCompleted: true }]); 
          }
        });
        // Archive the group instead of deleting it (preserves prayer history)
        setCards(prev => prev.map(c => c.id === cid ? { ...c, archived: true, archivedDate: getToday(), dissolved: true } : c));
      };
      
      const removeFromGroup = (cardId, personId) => {
        const card = cards.find(c => c.id === cardId);
        if (!card) return;
        const person = people.find(p => p.id === personId);
        if (!person) return;
        
        const newCard = {
          id: generateId(),
          name: `${person.firstName} ${person.lastName}`.trim() || person.organisation,
          peopleIds: [personId],
          frequency: card.frequency,
          prayerPoint: '',
          includeUnnamedChildren: false,
          isGroup: false,
          active: true,
          dateCreated: getToday(),
          firstPrayerCompleted: true
        };
        
        const updatedPeopleIds = card.peopleIds.filter(id => id !== personId);
        
        if (updatedPeopleIds.length <= 1) {
          setCards(prev => {
            const withoutOld = prev.filter(c => c.id !== cardId);
            const remainingPersonId = updatedPeopleIds[0];
            const remainingPerson = people.find(p => p.id === remainingPersonId);
            if (remainingPerson) {
              return [...withoutOld, newCard, {
                id: generateId(),
                name: `${remainingPerson.firstName} ${remainingPerson.lastName}`.trim() || remainingPerson.organisation,
                peopleIds: [remainingPersonId],
                frequency: card.frequency,
                prayerPoint: card.prayerPoint,
                includeUnnamedChildren: false,
                isGroup: false,
                active: true,
                dateCreated: getToday(),
                firstPrayerCompleted: true
              }];
            }
            return [...withoutOld, newCard];
          });
          setEditingCard(null);
        } else {
          setCards(prev => prev.map(c => c.id === cardId ? { ...c, peopleIds: updatedPeopleIds } : c).concat(newCard));
          setEditingCard(prev => prev ? { ...prev, peopleIds: updatedPeopleIds } : null);
        }
      };
      const deleteCard = (cid) => {
        const card = cards.find(c => c.id === cid);
        if (!card) return;
        if (!card.isGroup) card.peopleIds.forEach(deletePerson);
        else dissolveGroup(cid);
        setCards(prev => prev.filter(c => c.id !== cid));
      };

      const frequencyOrder = ['daily', 'every-2-3-days', 'weekly', 'fortnightly', 'monthly'];
      const getPersonFrequency = (p) => { const c = cards.find(x => x.peopleIds.includes(p.id)); return c?.frequency || 'daily'; };
      
      // Get dynamic display name for a card - for non-group cards, derive from person data
      const getCardDisplayName = (card) => {
        if (!card) return '';
        // For groups, use the stored group name
        if (card.isGroup) return card.name;
        // For single-person cards, derive from the actual person data
        if (card.peopleIds.length === 1) {
          const person = people.find(p => p.id === card.peopleIds[0]);
          if (person) {
            const isOrg = !person.firstName && !person.lastName && person.organisation;
            return isOrg ? person.organisation : `${person.firstName} ${person.lastName}`.trim();
          }
        }
        // Fallback to stored name
        return card.name;
      };
      const getSortedPeople = () => {
        let sorted = [...people].sort((a, b) => {
          if (sortBy === 'firstName') return a.firstName.localeCompare(b.firstName);
          if (sortBy === 'lastName') return (a.lastName || '').localeCompare(b.lastName || '');
          if (sortBy === 'frequency') {
            const freqA = frequencyOrder.indexOf(getPersonFrequency(a));
            const freqB = frequencyOrder.indexOf(getPersonFrequency(b));
            if (freqA !== freqB) return freqA - freqB;
            return (a.lastName || '').localeCompare(b.lastName || '');
          }
          return 0;
        });
        return sortReversed ? sorted.reverse() : sorted;
      };
      const getSortedCards = () => [...cards].filter(c => c.isGroup).sort((a, b) => cardSortBy === 'name' ? a.name.localeCompare(b.name) : 0);
      
      // Search filter functions
      const filterPeopleBySearch = (peopleList) => {
        if (!searchTerm.trim()) return peopleList;
        const term = searchTerm.toLowerCase();
        return peopleList.filter(p => {
          const firstName = (p.firstName || '').toLowerCase();
          const lastName = (p.lastName || '').toLowerCase();
          const organisation = (p.organisation || '').toLowerCase();
          const card = cards.find(c => c.peopleIds.includes(p.id));
          const groupName = (card?.name || '').toLowerCase();
          return firstName.includes(term) || lastName.includes(term) || 
                 organisation.includes(term) || groupName.includes(term);
        });
      };
      
      const filterCardsBySearch = (cardsList) => {
        if (!searchTerm.trim()) return cardsList;
        const term = searchTerm.toLowerCase();
        return cardsList.filter(c => {
          const cardName = (c.name || '').toLowerCase();
          // Also search people in the card
          const peopleInCard = c.peopleIds.map(id => people.find(p => p.id === id)).filter(Boolean);
          const peopleMatch = peopleInCard.some(p => 
            (p.firstName || '').toLowerCase().includes(term) ||
            (p.lastName || '').toLowerCase().includes(term) ||
            (p.organisation || '').toLowerCase().includes(term)
          );
          return cardName.includes(term) || peopleMatch;
        });
      };
      
      const getFilteredSortedPeople = () => filterPeopleBySearch(getSortedPeople());
      const getFilteredSortedCards = () => filterCardsBySearch(getSortedCards());
      
      const getPrayerCountThisMonth = (pid) => { 
        const p = people.find(x => x.id === pid); 
        if (!p) return 0; 
        const m = new Date().getMonth(), y = new Date().getFullYear(); 
        return getHistoryDates(p.prayerHistory).filter(d => { 
          const x = new Date(d); 
          return x.getMonth() === m && x.getFullYear() === y; 
        }).length; 
      };
      const formatFrequency = (f) => ({ daily: 'Daily', 'every-2-3-days': '2-3 days', weekly: 'Weekly', monthly: 'Monthly' }[f] || f);

      useEffect(() => { 
        if (editingPerson && editingPerson.id) { 
          // Editing an existing person
          const card = cards.find(c => c.peopleIds.includes(editingPerson.id)) || null; 
          setPersonForm({ 
            firstName: editingPerson.firstName || '', 
            lastName: editingPerson.lastName || '', 
            organisation: editingPerson.organisation || '', 
            prayerPoint: editingPerson.prayerPoint || '', 
            frequency: card?.frequency || 'daily', 
            isChild: editingPerson.isChild || false, 
            individualCheckbox: editingPerson.individualCheckbox !== false 
          }); 
        } else if (editingPerson && !editingPerson.id) {
          // Adding a new person (editingPerson is {} or {id: undefined})
          setPersonForm({ firstName: '', lastName: '', organisation: '', prayerPoint: '', frequency: 'daily', isChild: false, individualCheckbox: true });
        } else {
          // editingPerson is null/undefined - reset form
          setPersonForm({ firstName: '', lastName: '', organisation: '', prayerPoint: '', frequency: 'daily', isChild: false, individualCheckbox: true });
        }
      }, [editingPerson, cards]);
      
      
      useEffect(() => { if (editingCard) setCardForm({ name: editingCard.name || '', frequency: editingCard.frequency || 'daily', prayerPoint: editingCard.prayerPoint || '', includeUnnamedChildren: editingCard.includeUnnamedChildren || false }); }, [editingCard]);
      useEffect(() => { if (screen === 'createGroup') { setGroupStep(1); setGroupForm({ name: '', frequency: 'weekly', prayerPoint: '', includeUnnamedChildren: false }); setCheckboxOverrides({}); } }, [screen]);
      useEffect(() => { if (selectedPeopleForGroup.length) { const sel = people.filter(p => selectedPeopleForGroup.includes(p.id)); const surnames = [...new Set(sel.map(p => p.lastName).filter(Boolean))]; setGroupForm(f => ({ ...f, name: surnames.length === 1 && surnames[0] ? surnames[0] + 's' : '' })); } }, [selectedPeopleForGroup, people]);

      const renderPrayerCard = (cardId, isFullScreen = false) => {
        const card = cards.find(c => c.id === cardId);
        if (!card) return null;
        // Filter out archived people from the card
        const cardPeople = card.peopleIds.map(id => people.find(p => p.id === id)).filter(p => p && !p.archived);
        const adults = cardPeople.filter(p => !p.isChild), children = cardPeople.filter(p => p.isChild);
        const isSingle = cardPeople.length === 1 && !card.isGroup;
        const freq = formatFrequency(card.frequency);
        const checked = session?.checkedStatus?.[cardId] || {};
        
        const renderPrayerPoints = (text, centered = false) => {
          if (!text) return null;
          const points = text.split('\n').filter(p => p.trim());
          if (points.length === 0) return null;
          return (
            <div style={{ fontSize: '14px', color: colors.textSecondary, fontStyle: 'italic', textAlign: 'left', marginTop: '4px' }}>
              {points.map((point, i) => (
                <div key={i} style={{ display: 'flex', gap: '8px', marginBottom: '2px', justifyContent: centered ? 'center' : 'flex-start' }}>
                  <span style={{ color: colors.textTertiary }}></span>
                  <span>{point}</span>
                </div>
              ))}
            </div>
          );
        };
        
        if (!isFullScreen) {
          const allChecked = isCardFullyChecked(cardId);
          
          const individualPeople = cardPeople.filter(p => p.individualCheckbox);
          const groupedPeople = cardPeople.filter(p => !p.individualCheckbox);
          const hasGroupedItems = groupedPeople.length > 0 || card.includeUnnamedChildren;
          
          return (
            <div style={{ ...styles.card, padding: '12px 14px', marginBottom: '6px', opacity: allChecked ? 0.5 : 1 }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                <div style={{ flex: 1 }}>
                  {/* Adults / Individual checkboxes row */}
                  <div style={{ display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap' }}>
                    {individualPeople.map(p => {
                      const isChecked = checked[p.id] || false;
                      const isOrg = !p.firstName && !p.lastName && p.organisation;
                      const displayName = isOrg ? p.organisation : p.firstName;
                      return (
                        <div key={p.id} style={{ display: 'flex', alignItems: 'center', gap: '6px', cursor: 'pointer' }} onClick={() => toggleCheckbox(cardId, p.id)}>
                          <span style={{ width: '22px', height: '22px', borderRadius: '6px', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '12px', fontWeight: '700', color: '#FFF', background: isChecked ? colors.accentGradient : colors.checkboxBg }}>{isChecked && ''}</span>
                          <span style={{ fontSize: '15px', fontWeight: '500', fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</span>
                        </div>
                      );
                    })}
                  </div>
                  {/* Grouped children row */}
                  {hasGroupedItems && (
                    <div style={{ display: 'flex', alignItems: 'center', gap: '6px', cursor: 'pointer', marginTop: '6px' }} onClick={() => toggleCheckbox(cardId, '_group')}>
                      <span style={{ width: '22px', height: '22px', borderRadius: '6px', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '12px', fontWeight: '700', color: '#FFF', background: checked['_group'] ? colors.accentGradient : colors.checkboxBg }}>{checked['_group'] && ''}</span>
                      <span style={{ fontSize: '14px', fontWeight: '500', color: colors.textSecondary }}>
                        {groupedPeople.map(p => p.firstName).join(', ')}
                        {groupedPeople.length > 0 && card.includeUnnamedChildren ? ' and others' : ''}
                        {card.includeUnnamedChildren && groupedPeople.length === 0 ? 'Children' : ''}
                      </span>
                    </div>
                  )}
                </div>
                <div style={{ fontSize: '11px', color: colors.textTertiary, marginLeft: '8px', flexShrink: 0 }}>{freq}</div>
              </div>
            </div>
          );
        }
        
        const cardStyle = { ...styles.card, ...styles.cardFullScreen, paddingLeft: '12px', paddingRight: '12px' };
        const nameAlign = isSingle ? 'center' : 'flex-start';
        
        // Fixed sizes that work in both portrait and landscape
        const adultCheckboxSize = '36px';
        const childCheckboxSize = '36px'; // Same as adult
        const adultFontSize = 'clamp(20px, 6vw, 28px)';
        const childFontSize = 'clamp(16px, 5vw, 22px)';
        const adultIndent = '52px'; // 36px checkbox + 16px margin
        const childIndent = '52px'; // Same as adult (36px checkbox + 16px margin)
        
        const renderName = (person, isChild = false) => {
          const isOrg = !person.firstName && !person.lastName && person.organisation;
          const name = isOrg ? person.organisation : (isChild ? person.firstName : `${person.firstName} ${person.lastName}`.trim());
          const isChecked = person.individualCheckbox ? (checked[person.id] || false) : (checked['_group'] || false);
          const nameFontSize = isChild ? childFontSize : adultFontSize;
          const checkboxSize = adultCheckboxSize; // All checkboxes same size
          const checkFontSize = '18px'; // All checkboxes same font size
          const contentIndent = adultIndent; // All same indent
          return (
            <div key={person.id} style={{ marginBottom: '8px' }}>
              <div style={{ ...styles.nameRow, justifyContent: nameAlign }} onClick={() => toggleCheckbox(cardId, person.individualCheckbox ? person.id : '_group')}>
                <span style={{ ...styles.nameCheckbox, width: checkboxSize, height: checkboxSize, minWidth: checkboxSize, minHeight: checkboxSize, fontSize: checkFontSize, background: isChecked ? colors.accentGradient : colors.checkboxBg, boxShadow: isChecked ? '0 2px 10px rgba(110,196,159,0.5)' : 'none' }}>{isChecked && ''}</span>
                <span style={{ fontSize: nameFontSize, fontWeight: '600', marginLeft: '16px', fontStyle: isOrg ? 'italic' : 'normal', whiteSpace: 'nowrap' }}>{name}</span>
              </div>
              {person.organisation && !isOrg && <div style={{ fontSize: '14px', color: colors.textSecondary, fontStyle: 'italic', marginTop: '-2px', marginBottom: '2px', marginLeft: contentIndent, textAlign: 'left' }}>{person.organisation}</div>}
              {person.prayerPoint && <div style={{ marginLeft: contentIndent }}>{renderPrayerPoints(person.prayerPoint, false)}</div>}
            </div>
          );
        };

        if (isSingle) {
          const p = cardPeople[0];
          const isOrg = !p.firstName && !p.lastName && p.organisation;
          const name = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim();
          const isChecked = checked[p.id] || checked['_group'] || false;
          const prayerText = card.prayerPoint || p.prayerPoint;
          const singleCheckboxSize = '48px';
          const singleNameIndent = '66px'; // checkbox + 18px margin
          
          // Only reduce font size for long names (>18 chars), otherwise use default
          const isLongName = name.length > 18;
          const nameFontSize = isLongName ? 'clamp(16px, 5vw, 22px)' : 'clamp(24px, 8vw, 36px)';
          
          return (
            <div style={cardStyle}>
              <div style={styles.cardHeaderRow}><div></div><div style={styles.cardFrequency}>{freq}</div></div>
              <div 
                ref={cardContentScrollRef}
                onScroll={checkCardContentScroll}
                className="card-content-scrollable" 
                style={{ ...styles.singlePersonContent, minHeight: 0, overflowY: 'auto', position: 'relative' }}
              >
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start' }}>
                  <div style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }} onClick={() => toggleCheckbox(cardId, p.individualCheckbox ? p.id : '_group')}>
                    <span style={{ ...styles.nameCheckbox, width: singleCheckboxSize, height: singleCheckboxSize, minWidth: singleCheckboxSize, minHeight: singleCheckboxSize, fontSize: '24px', background: isChecked ? colors.accentGradient : colors.checkboxBg, boxShadow: isChecked ? '0 3px 12px rgba(110,196,159,0.5)' : 'none' }}>{isChecked && ''}</span>
                    <span style={{ fontSize: nameFontSize, fontWeight: '600', marginLeft: '18px', fontStyle: isOrg ? 'italic' : 'normal', whiteSpace: 'nowrap' }}>{name}</span>
                  </div>
                  {p.organisation && !isOrg && <div style={{ fontSize: '16px', color: colors.textSecondary, fontStyle: 'italic', marginTop: '4px', marginLeft: singleNameIndent }}>{p.organisation}</div>}
                  {prayerText && <div style={{ marginTop: '12px', marginLeft: singleNameIndent }}>{renderPrayerPoints(prayerText, false)}</div>}
                </div>
                {cardContentScrollState.needsScroll && (
                  <button
                    onClick={cardContentScrollState.canScrollDown ? scrollCardContentToBottom : scrollCardContentToTop}
                    style={{
                      position: 'sticky',
                      bottom: '4px',
                      right: '4px',
                      width: '32px',
                      height: '32px',
                      minWidth: '32px',
                      minHeight: '32px',
                      maxWidth: '32px',
                      maxHeight: '32px',
                      borderRadius: '50%',
                      background: colors.cardBgGradient || colors.cardBg,
                      border: `1px solid ${colors.border}`,
                      fontSize: '14px',
                      cursor: 'pointer',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      color: colors.text,
                      boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
                      zIndex: 10,
                      marginLeft: 'auto',
                      marginTop: 'auto',
                      alignSelf: 'flex-end',
                      padding: 0,
                      boxSizing: 'border-box'
                    }}
                  >
                    {cardContentScrollState.canScrollDown ? '' : ''}
                  </button>
                )}
              </div>
            </div>
          );
        }

        // Separate individual vs grouped people
        const individualAdults = adults.filter(p => p.individualCheckbox);
        const individualChildren = children.filter(p => p.individualCheckbox);
        const groupedPeople = cardPeople.filter(p => !p.individualCheckbox);
        const hasGroupedRow = groupedPeople.length > 0 || card.includeUnnamedChildren;

        const renderGroupedRow = () => {
          const isChecked = checked['_group'] || false;
          const names = groupedPeople.map(p => p.firstName).filter(Boolean);
          let label = names.join(', ');
          if (card.includeUnnamedChildren) {
            label = label ? `${label} and others` : 'And children';
          }
          return (
            <div style={{ marginBottom: '8px' }}>
              <div style={{ ...styles.nameRow, justifyContent: nameAlign }} onClick={() => toggleCheckbox(cardId, '_group')}>
                <span style={{ ...styles.nameCheckbox, width: adultCheckboxSize, height: adultCheckboxSize, minWidth: adultCheckboxSize, minHeight: adultCheckboxSize, fontSize: '18px', background: isChecked ? colors.accentGradient : colors.checkboxBg, boxShadow: isChecked ? '0 2px 10px rgba(110,196,159,0.5)' : 'none' }}>{isChecked && ''}</span>
                <span style={{ fontSize: childFontSize, fontWeight: '600', marginLeft: '16px', color: colors.textSecondary, whiteSpace: 'nowrap' }}>{label}</span>
              </div>
            </div>
          );
        };

        // Compact 3-column name rendering for landscape (with prayer points under each name)
        const renderCompactName = (person, isChild = false) => {
          const isOrg = !person.firstName && !person.lastName && person.organisation;
          const name = isOrg ? person.organisation : (isChild ? person.firstName : `${person.firstName} ${person.lastName}`.trim());
          const isChecked = person.individualCheckbox ? (checked[person.id] || false) : (checked['_group'] || false);
          const compactCheckboxSize = '26px'; // All checkboxes same size
          const compactFontSize = isChild ? '14px' : '16px';
          const checkFontSize = '13px'; // All checkboxes same font size
          return (
            <div key={person.id} style={{ marginBottom: '8px' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }} onClick={() => toggleCheckbox(cardId, person.individualCheckbox ? person.id : '_group')}>
                <span style={{ ...styles.nameCheckbox, width: compactCheckboxSize, height: compactCheckboxSize, minWidth: compactCheckboxSize, minHeight: compactCheckboxSize, fontSize: checkFontSize, background: isChecked ? colors.accentGradient : colors.checkboxBg, boxShadow: isChecked ? '0 2px 8px rgba(110,196,159,0.4)' : 'none' }}>{isChecked && ''}</span>
                <div style={{ display: 'flex', flexDirection: 'column' }}>
                  <span style={{ fontSize: compactFontSize, fontWeight: '600', fontStyle: isOrg ? 'italic' : 'normal', whiteSpace: 'nowrap' }}>{name}</span>
                  {person.organisation && !isOrg && <span style={{ fontSize: '11px', color: colors.textSecondary, fontStyle: 'italic' }}>{person.organisation}</span>}
                </div>
              </div>
              {person.prayerPoint && (
                <div style={{ fontSize: '12px', color: colors.textSecondary, fontStyle: 'italic', marginTop: '2px', marginLeft: `calc(${compactCheckboxSize} + 8px)` }}>
                  {person.prayerPoint.split('\n').filter(p => p.trim()).map((point, i) => (
                    <div key={i} style={{ display: 'flex', gap: '4px' }}>
                      <span style={{ color: colors.textTertiary }}></span>
                      <span>{point}</span>
                    </div>
                  ))}
                </div>
              )}
            </div>
          );
        };

        const renderCompactGroupedRow = () => {
          const isChecked = checked['_group'] || false;
          const names = groupedPeople.map(p => p.firstName).filter(Boolean);
          let label = names.join(', ');
          if (card.includeUnnamedChildren) {
            label = label ? `${label} and others` : 'And children';
          }
          return (
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', marginBottom: '6px' }} onClick={() => toggleCheckbox(cardId, '_group')}>
              <span style={{ ...styles.nameCheckbox, width: '26px', height: '26px', minWidth: '26px', minHeight: '26px', fontSize: '13px', background: isChecked ? colors.accentGradient : colors.checkboxBg, boxShadow: isChecked ? '0 2px 8px rgba(110,196,159,0.4)' : 'none' }}>{isChecked && ''}</span>
              <span style={{ fontSize: '14px', fontWeight: '600', color: colors.textSecondary, whiteSpace: 'nowrap' }}>{label}</span>
            </div>
          );
        };

        // Show children section if there are any children (individual or grouped) or includeUnnamedChildren
        const hasChildrenSection = individualChildren.length > 0 || children.length > 0 || card.includeUnnamedChildren;

        return (
          <div style={cardStyle}>
            <div className="card-header-row" style={styles.cardHeaderRow}><div style={styles.cardTitle}>{getCardDisplayName(card)}</div><div style={styles.cardFrequency}>{freq}</div></div>
            
            {/* Portrait layout - original with prayer points under each name */}
            <div 
              ref={cardContentScrollRefPortrait}
              onScroll={checkCardContentScroll}
              className="portrait-only card-content-scrollable" 
              style={{ flexDirection: 'column', padding: '12px 0', flex: 1, minHeight: 0, overflowY: 'auto', position: 'relative' }}
            >
              {card.prayerPoint && <div style={{ marginBottom: '12px', marginLeft: adultIndent }}>{renderPrayerPoints(card.prayerPoint, false)}</div>}
              {card.prayerPoint && <div style={styles.childrenDivider}></div>}
              <div>
                {individualAdults.map(p => renderName(p, false))}
              </div>
              {hasChildrenSection && (
                <>
                  <div style={styles.childrenDivider}></div>
                  <div>
                    {individualChildren.map(c => renderName(c, true))}
                    {hasGroupedRow && renderGroupedRow()}
                  </div>
                </>
              )}
              {hasGroupedRow && !hasChildrenSection && renderGroupedRow()}
              {cardContentScrollState.needsScroll && (
                <button
                  onClick={cardContentScrollState.canScrollDown ? scrollCardContentToBottom : scrollCardContentToTop}
                  style={{
                    position: 'sticky',
                    bottom: '8px',
                    right: '4px',
                    width: '32px',
                    height: '32px',
                    minWidth: '32px',
                    minHeight: '32px',
                    maxWidth: '32px',
                    maxHeight: '32px',
                    borderRadius: '50%',
                    background: colors.cardBgGradient || colors.cardBg,
                    border: `1px solid ${colors.border}`,
                    fontSize: '14px',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: colors.text,
                    boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
                    zIndex: 10,
                    padding: 0,
                    boxSizing: 'border-box',
                    marginLeft: 'auto',
                    marginTop: 'auto',
                    alignSelf: 'flex-end'
                  }}
                >
                  {cardContentScrollState.canScrollDown ? '' : ''}
                </button>
              )}
            </div>
            
            {/* Landscape layout - 3 columns with prayer points under each name */}
            <div 
              ref={cardContentScrollRefLandscape}
              onScroll={checkCardContentScroll}
              className="landscape-only card-content-scrollable" 
              style={{ flexDirection: 'column', paddingBottom: '4px', flex: 1, minHeight: 0, overflowY: 'auto', position: 'relative' }}
            >
              {card.prayerPoint && (() => {
                const points = card.prayerPoint.split('\n').filter(p => p.trim());
                if (points.length === 0) return null;
                const compactCheckboxSize = '26px';
                const prayerPointIndent = `calc(${compactCheckboxSize} + 8px)`;
                return (
                  <div style={{ marginBottom: '6px', fontSize: '12px', color: colors.textSecondary, fontStyle: 'italic' }}>
                    <div className="three-column-grid" style={{ gap: '4px 8px' }}>
                      {points.map((point, i) => (
                        <div key={i} style={{ display: 'flex', gap: '4px', paddingLeft: prayerPointIndent }}>
                          <span style={{ color: colors.textTertiary }}></span>
                          <span>{point}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                );
              })()}
              {card.prayerPoint && <div style={{ ...styles.childrenDivider, width: '100%', flexShrink: 0 }}></div>}
              <div className="three-column-grid">
                {individualAdults.map(p => renderCompactName(p, false))}
              </div>
              {hasChildrenSection && (
                <>
                  <div style={{ ...styles.childrenDivider, width: '100%', flexShrink: 0 }}></div>
                  <div className="three-column-grid">
                    {individualChildren.map(c => renderCompactName(c, true))}
                    {hasGroupedRow && renderCompactGroupedRow()}
                  </div>
                </>
              )}
              {hasGroupedRow && !hasChildrenSection && renderCompactGroupedRow()}
              {cardContentScrollState.needsScroll && (
                <button
                  onClick={cardContentScrollState.canScrollDown ? scrollCardContentToBottom : scrollCardContentToTop}
                  style={{
                    position: 'sticky',
                    bottom: '8px',
                    right: '4px',
                    width: '32px',
                    height: '32px',
                    minWidth: '32px',
                    minHeight: '32px',
                    maxWidth: '32px',
                    maxHeight: '32px',
                    borderRadius: '50%',
                    background: colors.cardBgGradient || colors.cardBg,
                    border: `1px solid ${colors.border}`,
                    fontSize: '14px',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: colors.text,
                    boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
                    zIndex: 10,
                    padding: 0,
                    boxSizing: 'border-box',
                    marginLeft: 'auto',
                    marginTop: 'auto',
                    alignSelf: 'flex-end'
                  }}
                >
                  {cardContentScrollState.canScrollDown ? '' : ''}
                </button>
              )}
            </div>
          </div>
          );
        };

      const renderModal = () => {
        if (!modal) return null;
        return (
          <div style={styles.modalOverlay} onClick={() => setModal(null)}>
            <div style={styles.modalContent} onClick={e => e.stopPropagation()}>
              <div style={styles.modalTitle}>{modal.title}</div>
              <div style={styles.modalMessage}>{modal.message}</div>
              <div style={styles.modalButtons}>
                <button style={{ ...styles.btnSecondary, flex: 1 }} onClick={() => setModal(null)}>Cancel</button>
                <button style={{ ...styles.btnPrimary, flex: 1, background: modal.danger ? colors.dangerGradient : colors.primaryGradient }} onClick={() => { modal.onConfirm(); setModal(null); }}>
                  {modal.confirmText || 'Confirm'}
                </button>
              </div>
            </div>
          </div>
        );
      };
      
      const renderOnboarding = () => {
        // Step 1: Name input
        if (onboardingStep === 1) {
          return (
            <div className="onboarding-overlay">
              <div className="onboarding-card">
                <div className="onboarding-title">Welcome to Prayer Companion</div>
                <div className="onboarding-text">
                  A simple way to remember and organize your daily prayers for the people you care about.
                </div>
                <input
                  className="onboarding-input"
                  type="text"
                  placeholder="Enter your first name"
                  value={nameInput}
                  onChange={(e) => setNameInput(e.target.value)}
                  onKeyDown={(e) => e.key === 'Enter' && handleNameSubmit()}
                  autoFocus
                />
                <button 
                  className="onboarding-btn onboarding-btn-primary"
                  onClick={handleNameSubmit}
                  disabled={!nameInput.trim()}
                  style={{ opacity: nameInput.trim() ? 1 : 0.5 }}
                >
                  Continue
                </button>
                <div className="onboarding-hint">
                  You can change your name anytime by tapping the edit icon next to your greeting.
                </div>
              </div>
            </div>
          );
        }
        
        // Step 2: Demo content choice
        if (onboardingStep === 2) {
          return (
            <div className="onboarding-overlay">
              <div className="onboarding-card">
                <div className="onboarding-title">Hi, {userName}!</div>
                <div className="onboarding-text">
                  Would you like to start with some demo content? This will add sample people and prayer groups so you can explore how the app works.
                </div>
                <button 
                  className="onboarding-btn onboarding-btn-primary"
                  onClick={() => handleDemoChoice(true)}
                >
                  Yes, show me a demo
                </button>
                <button 
                  className="onboarding-btn onboarding-btn-secondary"
                  onClick={() => handleDemoChoice(false)}
                >
                  No, I'll start fresh
                </button>
                <div className="onboarding-hint">
                  You can toggle demo mode anytime using the "D" button on the home screen.
                </div>
              </div>
            </div>
          );
        }
        
        // Step 3: Install to home screen prompt (mobile/tablet only)
        if (onboardingStep === 3) {
          // Skip install step if already running as standalone app OR on desktop
          if (isStandalone || !isMobile) {
            setOnboardingStep(4);
            return null;
          }
          
          return (
            <div className="onboarding-overlay">
              <div className="onboarding-card">
                <div className="onboarding-title">Add to Home Screen</div>
                <div className="onboarding-text">
                  For the best experience, add Prayer Companion to your home screen. This gives you quick access and a full-screen experience.
                </div>
                
                {/* iOS-specific instructions */}
                {isIOS && !deferredInstallPrompt && (
                  <div style={{ 
                    background: 'linear-gradient(135deg, #F5F0E8 0%, #EDE4D8 100%)', 
                    borderRadius: '12px', 
                    padding: '16px', 
                    marginBottom: '20px',
                    border: '1px solid #D4C8B8'
                  }}>
                    <div style={{ fontWeight: '600', marginBottom: '12px', color: '#3D352C' }}>
                      On iPhone/iPad:
                    </div>
                    <div style={{ display: 'flex', alignItems: 'flex-start', gap: '12px', marginBottom: '8px' }}>
                      <span style={{ 
                        background: '#B87A4A', 
                        color: 'white', 
                        width: '24px', 
                        height: '24px', 
                        borderRadius: '50%', 
                        display: 'flex', 
                        alignItems: 'center', 
                        justifyContent: 'center',
                        fontSize: '14px',
                        fontWeight: '600',
                        flexShrink: 0
                      }}>1</span>
                      <span style={{ color: '#4A3F34', fontSize: '14px' }}>
                        Tap the <strong>Share</strong> button (square with arrow) at the bottom of Safari
                      </span>
                    </div>
                    <div style={{ display: 'flex', alignItems: 'flex-start', gap: '12px', marginBottom: '8px' }}>
                      <span style={{ 
                        background: '#B87A4A', 
                        color: 'white', 
                        width: '24px', 
                        height: '24px', 
                        borderRadius: '50%', 
                        display: 'flex', 
                        alignItems: 'center', 
                        justifyContent: 'center',
                        fontSize: '14px',
                        fontWeight: '600',
                        flexShrink: 0
                      }}>2</span>
                      <span style={{ color: '#4A3F34', fontSize: '14px' }}>
                        Scroll down and tap <strong>"Add to Home Screen"</strong>
                      </span>
                    </div>
                    <div style={{ display: 'flex', alignItems: 'flex-start', gap: '12px' }}>
                      <span style={{ 
                        background: '#B87A4A', 
                        color: 'white', 
                        width: '24px', 
                        height: '24px', 
                        borderRadius: '50%', 
                        display: 'flex', 
                        alignItems: 'center', 
                        justifyContent: 'center',
                        fontSize: '14px',
                        fontWeight: '600',
                        flexShrink: 0
                      }}>3</span>
                      <span style={{ color: '#4A3F34', fontSize: '14px' }}>
                        Tap <strong>"Add"</strong> in the top right corner
                      </span>
                    </div>
                  </div>
                )}
                
                {/* Android/Chrome - show install button if available */}
                {deferredInstallPrompt && (
                  <button 
                    className="onboarding-btn onboarding-btn-primary"
                    onClick={handleInstallPrompt}
                  >
                    Install App
                  </button>
                )}
                
                {/* Non-iOS without install prompt */}
                {!isIOS && !deferredInstallPrompt && (
                  <div style={{ 
                    background: 'linear-gradient(135deg, #F5F0E8 0%, #EDE4D8 100%)', 
                    borderRadius: '12px', 
                    padding: '16px', 
                    marginBottom: '20px',
                    border: '1px solid #D4C8B8',
                    fontSize: '14px',
                    color: '#4A3F34'
                  }}>
                    Your browser doesn't support automatic installation, but you can bookmark this page or add it to your home screen from your browser's menu.
                  </div>
                )}
                
                <button 
                  className="onboarding-btn onboarding-btn-secondary"
                  onClick={skipInstall}
                >
                  {isIOS ? "I've done this" : deferredInstallPrompt ? "Maybe later" : "Continue"}
                </button>
                
                <div className="onboarding-hint">
                  You can find install instructions anytime in the "How to Use" section (tap the  button).
                </div>
              </div>
            </div>
          );
        }
        
        // Step 4: How to Use prompt
        if (onboardingStep === 4) {
          return (
            <div className="onboarding-overlay">
              <div className="onboarding-card">
                <div className="onboarding-title">You're all set!</div>
                <div className="onboarding-text">
                  Would you like a quick tour of how Prayer Companion works? It only takes a minute.
                </div>
                <button 
                  className="onboarding-btn onboarding-btn-primary"
                  onClick={() => finalizeOnboarding(true)}
                >
                  Yes, show me how it works
                </button>
                <button 
                  className="onboarding-btn onboarding-btn-secondary"
                  onClick={() => finalizeOnboarding(false)}
                >
                  No thanks, I'll explore
                </button>
                <div className="onboarding-hint">
                  You can access "How to Use" anytime by tapping the  button on the home screen.
                </div>
              </div>
            </div>
          );
        }
        
        return null;
      };
      
      const renderTutorial = () => {
        if (!tutorialActive) return null;
        
        const step = tutorialSteps[tutorialStep];
        if (!step) return null;
        
        // Get target element position
        let targetRect = null;
        let targetEl = null;
        if (step.target) {
          targetEl = document.getElementById(step.target);
          if (targetEl) {
            targetRect = targetEl.getBoundingClientRect();
          }
        }
        
        // Calculate tooltip position with smart positioning
        const padding = 16;
        const tooltipWidth = 300;
        const tooltipEstimatedHeight = 200; // Estimated height for calculations
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        // Determine actual position (may flip if not enough space)
        const getActualPosition = () => {
          if (step.position === 'center' || !targetRect) return 'center';
          
          const spaceAbove = targetRect.top;
          const spaceBelow = windowHeight - targetRect.bottom;
          
          if (step.position === 'top') {
            // Prefer top, but flip to bottom if not enough space
            return spaceAbove > tooltipEstimatedHeight + padding ? 'top' : 'bottom';
          } else if (step.position === 'bottom') {
            // Prefer bottom, but flip to top if not enough space
            return spaceBelow > tooltipEstimatedHeight + padding ? 'bottom' : 'top';
          }
          return 'center';
        };
        
        const actualPosition = getActualPosition();
        
        const getTooltipStyle = () => {
          if (actualPosition === 'center' || !targetRect) {
            // Centered on screen
            return {
              position: 'fixed',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)'
            };
          }
          
          // Calculate horizontal position (centered on target, but clamped to screen)
          let left = targetRect.left + (targetRect.width / 2) - (tooltipWidth / 2);
          left = Math.max(padding, Math.min(left, windowWidth - tooltipWidth - padding));
          
          if (actualPosition === 'top') {
            // Tooltip above the element
            const bottomPos = windowHeight - targetRect.top + padding + 8; // 8px extra for highlight padding
            return {
              position: 'fixed',
              bottom: `${bottomPos}px`,
              left: `${left}px`,
              width: `${tooltipWidth}px`,
              maxHeight: `${targetRect.top - padding - 8}px`,
              overflowY: 'auto'
            };
          } else if (actualPosition === 'bottom') {
            // Tooltip below the element
            const topPos = targetRect.bottom + padding + 8; // 8px extra for highlight padding
            return {
              position: 'fixed',
              top: `${topPos}px`,
              left: `${left}px`,
              width: `${tooltipWidth}px`,
              maxHeight: `${windowHeight - targetRect.bottom - padding - 8}px`,
              overflowY: 'auto'
            };
          }
          
          return {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)'
          };
        };
        
        // Get arrow class based on actual position
        const getArrowClass = () => {
          if (actualPosition === 'top') return 'top';
          if (actualPosition === 'bottom') return 'bottom';
          return '';
        };
        
        return (
          <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 9997, pointerEvents: 'auto' }}>
            {/* Overlay - only show solid overlay when no target element (centered steps) */}
            {!targetRect && (
              <div 
                className="tutorial-overlay"
                onClick={skipTutorial}
                style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.7)', zIndex: 9998 }}
              />
            )}
            
            {/* Click handler for when there IS a target - transparent overlay for click detection */}
            {targetRect && (
              <div 
                onClick={skipTutorial}
                style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'transparent', zIndex: 9998 }}
              />
            )}
            
            {/* Highlight around target element - the box-shadow creates the darkened overlay with a clear cutout */}
            {targetRect && (
              <div 
                className="tutorial-highlight"
                style={{
                  position: 'fixed',
                  top: `${targetRect.top - 8}px`,
                  left: `${targetRect.left - 8}px`,
                  width: `${targetRect.width + 16}px`,
                  height: `${targetRect.height + 16}px`,
                  boxShadow: '0 0 0 4px rgba(184,122,74,0.8), 0 0 0 9999px rgba(0,0,0,0.75)',
                  borderRadius: '12px',
                  pointerEvents: 'none',
                  zIndex: 9999,
                  background: 'transparent'
                }}
              />
            )}
            
            {/* Tooltip */}
            <div 
              className="tutorial-tooltip"
              style={{
                ...getTooltipStyle(),
                zIndex: 10000
              }}
            >
              {step.position !== 'center' && targetRect && (
                <div className={`tutorial-tooltip-arrow ${getArrowClass()}`} />
              )}
              <div className="tutorial-title">{step.title}</div>
              <div className="tutorial-text">{step.text}</div>
              
              <div className="tutorial-buttons">
                {tutorialStep > 0 && (
                  <button 
                    className="tutorial-btn tutorial-btn-secondary"
                    onClick={() => setTutorialStep(tutorialStep - 1)}
                  >
                    Back
                  </button>
                )}
                <button 
                  className="tutorial-btn tutorial-btn-secondary"
                  onClick={skipTutorial}
                >
                  Skip
                </button>
                <button 
                  className="tutorial-btn tutorial-btn-primary"
                  onClick={nextTutorialStep}
                >
                  {tutorialStep === tutorialSteps.length - 1 ? 'Finish' : 'Next'}
                </button>
              </div>
              
              {/* Progress dots */}
              <div className="tutorial-progress">
                {tutorialSteps.map((_, idx) => (
                  <div 
                    key={idx}
                    className={`tutorial-dot ${idx === tutorialStep ? 'active' : ''} ${idx < tutorialStep ? 'completed' : ''}`}
                  />
                ))}
              </div>
            </div>
          </div>
        );
      };
      
      const renderHelp = () => {
        const helpSections = [
          {
            id: 'getting-started',
            title: 'Getting Started',
            content: (
              <>
                <p>Welcome to Prayer Companion! This app helps you organize and track your daily prayers for the people you care about.</p>
                <ul>
                  <li><strong>Add people</strong> you want to pray for</li>
                  <li><strong>Create groups</strong> for families or communities</li>
                  <li><strong>Set prayer frequencies</strong> (daily, weekly, monthly)</li>
                  <li><strong>Track your prayers</strong> with checkboxes and history</li>
                </ul>
                <div className="help-tip">Tip: Use Demo Mode from the menu to explore the app with sample data!</div>
              </>
            )
          },
          {
            id: 'adding-people',
            title: 'Adding People',
            content: (
              <>
                <p>Tap <strong>"Add Person"</strong> on the home screen to add someone to your prayer list.</p>
                <ul>
                  <li><strong>Name:</strong> Enter their first and last name, or leave both blank to add just an organisation</li>
                  <li><strong>Organisation:</strong> Their church, workplace, ministry, etc. You can add an organisation without a name by leaving first and last name blank</li>
                  <li><strong>Prayer Points:</strong> Specific things to pray for (one per line)</li>
                  <li><strong>Frequency:</strong> How often to pray for them</li>
                  <li><strong>Is Child:</strong> Mark if they're a child (affects display) - only available when a name is entered</li>
                </ul>
              </>
            )
          },
          {
            id: 'creating-groups',
            title: 'Creating Groups',
            content: (
              <>
                <p>Groups let you pray for multiple people together, like a family.</p>
                <ul>
                  <li>Tap <strong>"Create Group"</strong> and give it a name</li>
                  <li>Select the people to include</li>
                  <li>Choose if each person has an individual checkbox or one for all</li>
                  <li><strong>"Include unnamed children"</strong> adds a catch-all for kids you haven't added individually</li>
                </ul>
                <div className="help-tip">Tip: People in a group won't appear as separate cards - they'll only show in the group.</div>
              </>
            )
          },
          {
            id: 'prayer-frequencies',
            title: 'Prayer Frequencies',
            content: (
              <>
                <p>Choose how often someone appears in your prayers:</p>
                <ul>
                  <li><strong>Daily:</strong> Every day</li>
                  <li><strong>Every 2-3 days:</strong> Spreads out evenly across the week</li>
                  <li><strong>Weekly:</strong> Once a week, distributed evenly</li>
                  <li><strong>Fortnightly:</strong> Once every two weeks</li>
                  <li><strong>Monthly:</strong> Once a month, spread across the month</li>
                </ul>
                <p>Weekly, fortnightly, and monthly people are automatically distributed so you don't have everyone on the same day.</p>
              </>
            )
          },
          {
            id: 'praying',
            title: 'Daily Prayer Time',
            content: (
              <>
                <p>Tap <strong>"Start Praying"</strong> to begin your daily prayer session.</p>
                <ul>
                  <li><strong>Swipe left/right</strong> or use arrow buttons to navigate cards</li>
                  <li><strong>Tap checkboxes</strong> to mark prayers as complete</li>
                  <li>Completed cards are removed from rotation when you swipe away</li>
                  <li>Tap <strong>"List"</strong> to see all today's prayers at once</li>
                  <li>If a card has more content than fits, a <strong>scroll button</strong> (/) appears in the bottom-right corner - tap it to scroll to the bottom or top</li>
                </ul>
                <div className="help-tip">Tip: Your progress is saved automatically - you can close and return anytime!</div>
              </>
            )
          },
          {
            id: 'managing',
            title: 'Managing & History',
            content: (
              <>
                <p>Use the bottom navigation to access:</p>
                <ul>
                  <li><strong>People & Groups:</strong> Edit, delete, or deactivate people and groups. Use the sorting controls to organize by name or date added.</li>
                  <li><strong>Prayer History:</strong> View your prayer history by person or group. Use sorting controls to organize the list.</li>
                </ul>
                <p>Tap any person or group to see details. In History, you can view a calendar showing which days you prayed and what prayer points were used. Tap a date on the calendar to see the prayer points for that day.</p>
                <div className="help-tip">Tip: In landscape mode, sorting controls move to the right side of the screen for easier access.</div>
              </>
            )
          },
          {
            id: 'backup',
            title: 'Backup & Restore',
            content: (
              <>
                <p>Your prayer data is stored on your device. To keep it safe:</p>
                <ul>
                  <li>Tap the <strong> button</strong> at the top of the home screen</li>
                  <li><strong>Download Backup</strong> saves a file to your device</li>
                  <li><strong>Restore from Backup</strong> loads a previously saved file</li>
                </ul>
                <p><strong>When to backup:</strong></p>
                <ul>
                  <li>Before clearing your browser cache or data</li>
                  <li>Before switching devices</li>
                  <li>Periodically, to protect against data loss</li>
                </ul>
                <div className="help-tip">Tip: Store your backup file in cloud storage (iCloud, Google Drive) for extra safety.</div>
              </>
            )
          },
          {
            id: 'install-app',
            title: 'Install to Home Screen',
            content: (
              <>
                <p>Prayer Companion is a Progressive Web App (PWA) that works fully offline and can be installed on your device.</p>
                <ul>
                  <li><strong>Offline access:</strong> Works without internet after first load</li>
                  <li><strong>Home screen icon:</strong> Quick access like a native app</li>
                  <li><strong>Automatic updates:</strong> You'll be notified when updates are available</li>
                </ul>
                
                <div style={{ marginTop: '16px', marginBottom: '12px', fontWeight: '600', color: '#3D352C' }}>
                  Installation:
                </div>
                <ul style={{ paddingLeft: '20px', margin: '0 0 16px 0' }}>
                  <li style={{ marginBottom: '8px' }}><strong>iPhone/iPad:</strong> Safari  Share button ()  "Add to Home Screen"</li>
                  <li style={{ marginBottom: '8px' }}><strong>Android:</strong> Chrome menu ()  "Install app" or "Add to Home screen"</li>
                  <li style={{ marginBottom: '8px' }}><strong>Desktop:</strong> Look for install icon () in address bar, or browser menu  "Install"</li>
                </ul>
                
                <div className="help-tip"><strong>Updates:</strong> When a new version is available, you'll be prompted to download your backup first, then update. This protects your data.</div>
              </>
            )
          }
        ];
        
        return (
          <div className="app-container" style={{ ...styles.container, display: 'flex', flexDirection: 'column', height: '100dvh', maxHeight: '100dvh', overflow: 'hidden', overscrollBehavior: 'none' }}>
            <div className="app-header">
              <button style={styles.btnText} onClick={() => setHelpOpen(false)}><span style={{ display: 'inline-block', transform: 'translateY(-2px)' }}></span> Back</button>
            </div>
            <div className="page-title">How to Use</div>
            <div style={{ flex: 1, overflowY: 'auto', paddingBottom: '100px' }}>
              {/* Restart Tutorial button */}
              <div style={{ padding: '0 0 16px 0', textAlign: 'center' }}>
                <button 
                  style={{ 
                    ...styles.btnSecondary, 
                    padding: '12px 24px', 
                    fontSize: '14px',
                    display: 'inline-flex',
                    alignItems: 'center',
                    gap: '8px'
                  }}
                  onClick={restartTutorial}
                >
                  <span style={{ fontSize: '16px' }}></span> Take the App Tour
                </button>
              </div>
              
              {helpSections.map(section => (
                <div key={section.id} className="help-section">
                  <div className="help-accordion">
                    <div className="help-accordion-header" onClick={() => toggleAccordion(section.id)}>
                      <span className="help-accordion-title">{section.title}</span>
                      <span className={`help-accordion-icon ${openAccordions[section.id] ? 'open' : ''}`}></span>
                    </div>
                    <div className={`help-accordion-content ${openAccordions[section.id] ? 'open' : ''}`}>
                      <div className="help-accordion-body">
                        {section.content}
                      </div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        );
      };

      const renderHome = () => {
        const showContinue = session && !isNewDay();
        const todaysCards = cards.filter(c => {
          if (!c.active || c.archived) return false;
          if (!isCardDueToday(c)) return false;
          // For group cards, check if at least one member is not archived
          const activeMembers = c.peopleIds.filter(pid => {
            const p = people.find(x => x.id === pid);
            return p && !p.archived;
          });
          return activeMembers.length > 0 || c.includeUnnamedChildren;
        });
        const count = todaysCards.length;
          return (
            <div className="app-container" style={{ ...styles.container, position: 'relative', display: 'flex', flexDirection: 'column', height: '100dvh', maxHeight: '100dvh', paddingBottom: '60px', overflow: 'hidden', overscrollBehavior: 'none' }}>
            
            {/* Top row with info, sync, and demo buttons */}
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
              <button id="help-btn" className="home-circle-btn" onClick={() => setHelpOpen(true)} title="How to Use">i</button>
              <button id="backup-btn" className="home-circle-btn symbol" onClick={() => { setDataModalOpen(true); setDataModalStep('main'); }} title="Backup & Restore"></button>
              <button id="demo-btn" className={`home-circle-btn ${demoMode ? 'active' : ''}`} onClick={toggleDemoMode} title="Demo Mode">D</button>
            </div>
            
            {/* Greeting - portrait only */}
            {(() => {
              const greetingText = showContinue ? `Welcome back, ${userName || 'Friend'}` : getGreeting(userName || 'Friend');
              // Use calculated font size or fallback to dynamic calculation
              const greetingLength = greetingText.length;
              const baseFontSize = greetingLength > 24 ? 18 : greetingLength > 20 ? 20 : greetingLength > 16 ? 22 : 24;
              const fallbackFontSize = Math.round(baseFontSize * 1.7);
              // Use calculated size or fallback
              const greetingFontSize = greetingPortraitFontSize 
                ? `${greetingPortraitFontSize}px` 
                : `${fallbackFontSize}px`;
              
              // Callback ref to calculate font size when element mounts
              const setGreetingPortraitRef = (el) => {
                greetingPortraitRef.current = el;
                if (el) {
                  // Use requestAnimationFrame to ensure layout is complete
                  requestAnimationFrame(() => {
                    const container = el.closest('.home-greeting');
                    if (container && container.offsetWidth > 0) {
                      const containerWidth = container.offsetWidth;
                      // Account for padding (10px each side = 20px) and edit button (~30px) and gap (6px)
                      const availableWidth = containerWidth - 20 - 30 - 6;
                      if (availableWidth > 0) {
                        // Lower minimum for very long names
                        const minSize = greetingText.length > 30 ? 14 : greetingText.length > 25 ? 16 : 18;
                        const fontSize = calculateGreetingFontSize(greetingText, availableWidth, 0, minSize, 42);
                        if (fontSize !== greetingPortraitFontSize) {
                          setGreetingPortraitFontSize(fontSize);
                        }
                      }
                    }
                  });
                }
              };
              
              return (
                <div className="home-greeting portrait-only" style={{ textAlign: 'center', marginBottom: '12px', padding: '0 10px', position: 'relative', width: '100%', maxWidth: '100%', overflow: 'hidden' }}>
                  <div ref={setGreetingPortraitRef} className="home-welcome" style={{ ...styles.greeting, fontSize: greetingFontSize, marginTop: 0, marginBottom: '2px', whiteSpace: 'nowrap', fontFamily: '"Oranienbaum", serif', fontWeight: '400', position: 'relative', display: 'inline-flex', alignItems: 'center', gap: '6px', maxWidth: '100%', overflow: 'hidden' }}>
                    <span style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{greetingText}</span>
                    <button className="edit-name-btn" onClick={openEditName} title="Edit name" style={{ marginLeft: '0', verticalAlign: 'middle', flexShrink: 0 }}></button>
                  </div>
                  <div className="home-subtext" style={{ ...styles.subGreeting, fontSize: '16px', marginBottom: '0' }}>{count ? `${count} prayer${count !== 1 ? 's' : ''} for today` : 'No prayers scheduled'}</div>
                </div>
              );
            })()}
            
            {/* Landscape header row - welcome and prayer count */}
            {(() => {
              const greetingText = showContinue ? `Welcome back, ${userName || 'Friend'}` : getGreeting(userName || 'Friend');
              const greetingLength = greetingText.length;
              const baseLandscapeSize = greetingLength > 24 ? 16 : greetingLength > 20 ? 17 : greetingLength > 16 ? 18 : 20;
              const fallbackLandscapeSize = Math.round(baseLandscapeSize * 1.7);
              const landscapeFontSize = greetingLandscapeFontSize ? `${greetingLandscapeFontSize}px` : `${fallbackLandscapeSize}px`;
              
              // Callback ref to calculate font size when element mounts
              const setGreetingLandscapeRef = (el) => {
                greetingLandscapeRef.current = el;
                if (el) {
                  // Use requestAnimationFrame to ensure layout is complete
                  requestAnimationFrame(() => {
                    const container = el.parentElement;
                    if (container && container.offsetWidth > 0) {
                      const containerWidth = container.offsetWidth;
                      // Account for padding (5px each side = 10px) and edit button (~30px) and gap (6px)
                      const availableWidth = containerWidth - 10 - 30 - 6;
                      if (availableWidth > 0) {
                        const fontSize = calculateGreetingFontSize(greetingText, availableWidth, 0, 16, 36);
                        if (fontSize !== greetingLandscapeFontSize) {
                          setGreetingLandscapeFontSize(fontSize);
                        }
                      }
                    }
                  });
                }
              };
              
              return (
                <div className="landscape-only" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%', marginBottom: '20px', padding: '0 10px' }}>
                  <div style={{ flex: '0 0 auto', width: 'calc(50% - 1px)', display: 'flex', justifyContent: 'center', alignItems: 'center', overflow: 'hidden', padding: '0 5px' }}>
                    <div ref={setGreetingLandscapeRef} className="home-welcome" style={{ fontSize: landscapeFontSize, whiteSpace: 'nowrap', fontFamily: '"Oranienbaum", serif', fontWeight: '400', display: 'flex', alignItems: 'center', gap: '6px', maxWidth: '100%', overflow: 'hidden' }}>
                      <span style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{greetingText}</span>
                      <button className="edit-name-btn" onClick={openEditName} title="Edit name" style={{ marginLeft: '0', verticalAlign: 'middle', flexShrink: 0 }}></button>
                    </div>
                  </div>
                  <div style={{ flex: '1', display: 'flex', justifyContent: 'center', alignItems: 'center', paddingLeft: '24px' }}>
                    <div style={{ fontSize: '16px', color: colors.textSecondary }}>{count ? `${count} prayer${count !== 1 ? 's' : ''} for today` : 'No prayers scheduled'}</div>
                  </div>
                </div>
              );
            })()}
            
            {/* Main content - two columns in landscape */}
            <div className="home-content">
              {/* Left column: Start button only in landscape */}
              <div className="home-left">
                {/* Spacer to push content down (portrait only) */}
                <div className="home-spacer-top portrait-only" style={{ flex: '0 0 auto', minHeight: '8px', maxHeight: '20px' }} />
                
{/* Circular Start Praying button */}
                 <div className="home-start-btn-wrapper home-start-wrapper" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', padding: '12px 0', marginBottom: '10px' }}>
                   <button 
                     id="start-praying-btn"
                     className="home-start-btn"
                     style={{
                       width: '160px',
                       height: '160px',
                       borderRadius: '50%',
                       background: colors.primaryGradient,
                       border: 'none',
                       boxShadow: `0 8px 32px rgba(184,122,74,0.4), 0 4px 12px rgba(184,122,74,0.3), inset 0 2px 0 rgba(255,255,255,0.2)`,
                       color: colors.primaryText,
                       fontSize: '19px',
                       fontWeight: '700',
                       cursor: 'pointer',
                       fontFamily: 'inherit',
                       display: 'flex',
                       alignItems: 'center',
                       justifyContent: 'center',
                       textAlign: 'center',
                       lineHeight: '1.2',
                       padding: '18px',
                       transition: 'transform 0.15s ease, box-shadow 0.15s ease'
                     }}
                     onClick={showContinue ? () => setScreen('prayer') : startPraying}
                   >
                     {showContinue ? 'Continue\nPraying' : 'Start\nPraying'}
                   </button>
                 </div>
                 
                 {/* Action buttons stacked (portrait only) */}
                 <div className="home-actions-portrait" style={{ flexDirection: 'column', alignItems: 'center', gap: '10px' }}>
                   <button 
                     id="add-person-btn"
                     className="home-action-btn"
                     style={{ ...styles.btnSecondary, width: '220px', padding: '14px 20px', fontSize: '16px' }} 
                     onClick={() => setEditingPerson({})}
                   >
                     + Add Person
                   </button>
                   <button 
                     id="create-group-btn"
                     className="home-action-btn"
                     style={{ ...styles.btnSecondary, width: '220px', padding: '14px 20px', fontSize: '16px' }} 
                     onClick={() => setScreen('createGroup')}
                   >
                     Create Group
                   </button>
                 </div>
                 
                 {/* Divider line (portrait only) - adjust marginTop and marginBottom here */}
                 <div className="home-portrait-divider" style={{ width: '80%', maxWidth: '280px', height: '1px', background: colors.border, marginTop: '20px', marginBottom: '12px', marginLeft: 'auto', marginRight: 'auto' }} />
                 
                 {/* Spacer (portrait only) */}
                 <div className="home-spacer-bottom" style={{ flex: '1 1 auto', minHeight: '8px', maxHeight: '20px' }} />
              </div>
              
              {/* Separator line (landscape only) */}
              <div className="home-separator"></div>
              
              {/* Right column: Today's prayers only */}
              <div className="home-right">
                <div className="home-right-content">
                  <div className="home-prayers-heading" style={{ fontSize: '13px', fontWeight: '700', color: colors.textTertiary, textTransform: 'uppercase', letterSpacing: '1px', marginBottom: '10px', textAlign: 'center' }}>Today's Prayers</div>
                  {!count ? (
                    <div className="home-prayers-list" style={{ color: colors.textTertiary, fontSize: '15px', textAlign: 'center' }}>No prayers due today</div>
                  ) : (
                    <div className="home-prayers-list" style={{ fontSize: '15px', color: colors.textSecondary, lineHeight: '1.9', textAlign: 'center' }}>
                      {todaysCards.map((card, idx) => {
                        const isComplete = session?.checkedStatus?.[card.id] && isCardFullyChecked(card.id);
                        return (
                          <span key={card.id}>
                            <span style={{ 
                              color: isComplete ? colors.accent : colors.text,
                              textDecoration: isComplete ? 'line-through' : 'none',
                              opacity: isComplete ? 0.6 : 1
                            }}>
                              {getCardDisplayName(card)}
                            </span>
                            {idx < todaysCards.length - 1 && <span style={{ color: colors.textTertiary }}>  </span>}
                          </span>
                        );
                      })}
                    </div>
                  )}
                </div>
              </div>
            </div>
            
{/* Fixed bottom navigation tabs */}
             <div className="bottom-nav" style={{
               position: 'fixed',
               bottom: 0,
               left: 0,
               right: 0,
               background: colors.cardBg,
               borderTop: `1px solid ${colors.border}`,
               display: 'flex',
               margin: '0 auto',
               boxShadow: '0 -4px 20px rgba(0,0,0,0.08)'
             }}>
               <button 
                 id="manage-btn"
                 style={{
                   flex: 1,
                   padding: '12px 10px',
                   paddingBottom: 'max(12px, env(safe-area-inset-bottom))',
                   fontSize: '15px',
                   fontWeight: '600',
                   background: 'transparent',
                   border: 'none',
                   borderRight: `1px solid ${colors.border}`,
                   color: colors.primary,
                   cursor: 'pointer',
                   fontFamily: 'inherit',
                   whiteSpace: 'nowrap',
                   display: 'flex',
                   flexDirection: 'column',
                   alignItems: 'center',
                   gap: '2px'
                 }} 
                 onClick={() => setScreen('manage')}
               >
                 <span className="portrait-only" style={{ fontSize: '24px', lineHeight: '1', fontWeight: 'normal', display: 'inline-flex', alignItems: 'center', justifyContent: 'center', marginTop: '1px' }}>
                   <svg width="25" height="25" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style={{ stroke: colors.primary, strokeWidth: '1.5', strokeLinecap: 'round', strokeLinejoin: 'round' }}>
                     <circle cx="10" cy="7" r="3.5"/>
                     <path d="M 4 16 Q 4 12 10 12 Q 16 12 16 16"/>
                   </svg>
                 </span>
                 <span style={{ marginTop: '-3px' }}>People & Groups</span>
               </button>
               <button 
                 id="history-btn"
                 style={{
                   flex: 1,
                   padding: '12px 10px',
                   paddingBottom: 'max(12px, env(safe-area-inset-bottom))',
                   fontSize: '15px',
                   fontWeight: '600',
                   background: 'transparent',
                   border: 'none',
                   color: colors.primary,
                   cursor: 'pointer',
                   fontFamily: 'inherit',
                   whiteSpace: 'nowrap',
                   display: 'flex',
                   flexDirection: 'column',
                   alignItems: 'center',
                   gap: '4px'
                 }} 
                 onClick={() => setScreen('stats')}
               >
                 <span className="portrait-only" style={{ fontSize: '24px', lineHeight: '1', fontWeight: 'normal' }}></span>
                 <span>Prayer History</span>
               </button>
             </div>
             
             {/* Edit name modal */}
             {editingName && (
               <div className="edit-name-overlay" onClick={() => setEditingName(false)}>
                 <div className="edit-name-modal" onClick={(e) => e.stopPropagation()}>
                   <h3>Edit Your Name</h3>
                   <input
                     className="onboarding-input"
                     type="text"
                     placeholder="Enter your first name"
                     value={editNameInput}
                     onChange={(e) => setEditNameInput(e.target.value)}
                     onKeyDown={(e) => e.key === 'Enter' && saveEditedName()}
                     autoFocus
                   />
                   <div style={{ display: 'flex', gap: '12px' }}>
                     <button 
                       className="onboarding-btn onboarding-btn-secondary"
                       style={{ flex: 1, marginBottom: 0 }}
                       onClick={() => setEditingName(false)}
                     >
                       Cancel
                     </button>
                     <button 
                       className="onboarding-btn onboarding-btn-primary"
                       style={{ flex: 1, marginBottom: 0, opacity: editNameInput.trim() ? 1 : 0.5 }}
                       onClick={saveEditedName}
                       disabled={!editNameInput.trim()}
                     >
                       Save
                     </button>
                   </div>
                 </div>
               </div>
             )}
             
             {/* Data backup/restore modal */}
             {dataModalOpen && (
               <div className="data-modal-overlay" onClick={() => { setDataModalOpen(false); setDataModalStep('main'); setPendingUploadData(null); }}>
                 <div className="data-modal" onClick={(e) => e.stopPropagation()}>
                   {dataModalStep === 'main' ? (
                    <>
                      <h3>Backup & Restore</h3>
                      <div className="data-modal-desc">
                        Download a backup of your prayer list to keep it safe, or restore from a previous backup.
                      </div>
                      {demoMode && (
                        <div style={{ 
                          fontSize: '12px', 
                          color: colors.accent, 
                          background: 'rgba(184, 122, 74, 0.1)', 
                          padding: '8px 12px', 
                          borderRadius: '8px', 
                          marginBottom: '12px',
                          textAlign: 'center'
                        }}>
                           Demo mode is on. This will backup your <strong>real</strong> prayer data, not the demo data.
                        </div>
                      )}
                      <button className="data-modal-btn data-modal-btn-download" onClick={downloadData}>
                        <span></span> Download Backup
                      </button>
                       <label className="data-modal-btn data-modal-btn-upload" style={{ cursor: 'pointer' }}>
                         <span></span> Restore from Backup
                         <input 
                           type="file" 
                           accept=".json"
                           style={{ display: 'none' }}
                           onChange={handleFileUpload}
                         />
                       </label>
                       <button className="data-modal-btn data-modal-btn-cancel" onClick={() => setDataModalOpen(false)}>
                         Cancel
                       </button>
                     </>
                   ) : (
                     <>
                       <h3>Confirm Restore</h3>
                       <div className="data-modal-warning">
                         <strong>Warning:</strong> This will replace all your current prayer data with the backup. Any changes you've made since this backup will be lost.
                       </div>
                       <div className="data-modal-desc" style={{ marginBottom: '16px' }}>
                         Backup from: {pendingUploadData?.exportDate ? new Date(pendingUploadData.exportDate).toLocaleDateString() : 'Unknown date'}
                         <br />
                         Contains: {pendingUploadData?.people?.length || 0} people, {pendingUploadData?.cards?.length || 0} cards
                       </div>
                       <button className="data-modal-btn data-modal-btn-download" onClick={confirmUpload}>
                         Yes, Restore This Backup
                       </button>
                       <button className="data-modal-btn data-modal-btn-cancel" onClick={() => { setDataModalStep('main'); setPendingUploadData(null); }}>
                         Cancel
                       </button>
                     </>
                   )}
                 </div>
               </div>
             )}
             
             {/* PWA Update Modal */}
             {updateModalOpen && (
               <div className="data-modal-overlay" onClick={() => { setUpdateModalOpen(false); setWaitingWorker(null); setUpdateDownloaded(false); }}>
                 <div className="data-modal" onClick={(e) => e.stopPropagation()}>
                   <h3>Update Available</h3>
                   <div className="data-modal-desc">
                     A new version of Prayer Companion is available. {isMobile 
                       ? 'Please download your data backup before updating to ensure your prayer list is safe.'
                       : 'It is highly recommended to download a backup before updating.'}
                   </div>
                   <div style={{ 
                     fontSize: '12px', 
                     color: colors.accent, 
                     background: 'rgba(184, 122, 74, 0.1)', 
                     padding: '8px 12px', 
                     borderRadius: '8px', 
                     marginBottom: '12px',
                     textAlign: 'center'
                   }}>
                     {isMobile 
                       ? ' Important: Download your backup first, then click Update App.'
                       : ' Recommended: Download a backup before updating.'}
                   </div>
                   <button 
                     className="data-modal-btn data-modal-btn-download" 
                     onClick={() => { setUpdateDownloaded(true); downloadData(true); }}
                     style={{ opacity: updateDownloaded ? 0.6 : 1 }}
                   >
                     <span></span> Download Backup
                     {updateDownloaded && <span style={{ marginLeft: '8px', fontSize: '12px' }}></span>}
                   </button>
                   <button 
                     className="data-modal-btn data-modal-btn-download" 
                     onClick={handleUpdateApp}
                     disabled={isMobile && !updateDownloaded}
                     style={{ 
                       opacity: (!isMobile || updateDownloaded) ? 1 : 0.5,
                       cursor: (!isMobile || updateDownloaded) ? 'pointer' : 'not-allowed',
                       background: (!isMobile || updateDownloaded) ? colors.primaryGradient : '#ccc'
                     }}
                   >
                     <span></span> Update App
                   </button>
                   <button 
                     className="data-modal-btn data-modal-btn-cancel" 
                     onClick={() => { setUpdateModalOpen(false); setWaitingWorker(null); setUpdateDownloaded(false); }}
                   >
                     Not Now
                   </button>
                 </div>
               </div>
             )}
          </div>
        );
      };

      const renderPrayer = () => {
        const allCards = getAllCardsInRotation();
        const incompleteCount = getIncompleteCount();
        const allDone = incompleteCount === 0;
        const showList = session?.currentView === 'list' || allDone;
        
        if (showList) return (
          <div className="app-container" style={{ ...styles.container, display: 'flex', flexDirection: 'column', height: '100dvh', maxHeight: '100dvh', overflow: 'hidden' }}>
            <div className="app-header">
              <button style={styles.btnText} onClick={() => setScreen('home')}><span style={{ display: 'inline-block', transform: 'translateY(-2px)' }}></span> Home</button>
              {!allDone && <button style={styles.btnText} onClick={() => setSession(s => ({ ...s, currentView: 'flashcard' }))}>Cards</button>}
            </div>
            <div className="page-title">{allDone ? 'All prayers complete' : "Today's Prayers"}</div>
            <div className="two-column-grid scrollable-list" style={{ flex: 1, overflowY: 'auto', padding: '4px 6px', margin: '0 -6px', minHeight: 0 }}>
              {(session?.cardsInRotation || []).map(cid => <div key={cid}>{renderPrayerCard(cid, false)}</div>)}
            </div>
          </div>
        );
        
        const cid = allCards[currentCardIndex % allCards.length];
        const currentCardComplete = isCardFullyChecked(cid);
        const isLastIncomplete = incompleteCount === 1 && !currentCardComplete;
        const onlyOneCardTotal = allCards.length === 1;
        // Disable navigation when:
        // - No incomplete cards left, OR
        // - Only one card total for the day, OR
        // - Only one incomplete card left (and we're on it)
        const disableNavigation = incompleteCount === 0 || onlyOneCardTotal || isLastIncomplete;
        const disabledBtnStyle = { ...styles.swipeButton, opacity: 0.3, cursor: 'default' };
        
        // Determine hint text
        let hintText;
        if (onlyOneCardTotal) {
          hintText = currentCardComplete ? 'Complete!' : 'Only card for today';
        } else if (currentCardComplete) {
          hintText = 'Complete! Swipe for next';
        } else if (isLastIncomplete) {
          hintText = 'Last card';
        } else {
          hintText = `${incompleteCount} remaining`;
        }
        
        return (
          <div className="prayer-view-container" style={{ fontFamily: "'Open Sans', -apple-system, BlinkMacSystemFont, sans-serif", background: colors.bgGradient, color: colors.text, margin: '0 auto', maxWidth: 'none', width: '100%' }}>
            <div className="app-header" style={{ flexShrink: 0 }}>
              <button style={styles.btnText} onClick={() => setScreen('home')}><span style={{ display: 'inline-block', transform: 'translateY(-2px)' }}></span> Home</button>
              <button style={styles.btnText} onClick={() => setSession(s => ({ ...s, currentView: 'list' }))}>List</button>
            </div>
            <div 
              ref={cardScrollRef}
              className={`prayer-card-area ${slideDirection === 'right' ? 'card-slide-right' : slideDirection === 'left' ? 'card-slide-left' : ''}`}
              onTouchStart={disableNavigation ? undefined : handleTouchStart} 
              onTouchEnd={disableNavigation ? undefined : handleTouchEnd}
              onScroll={checkCardScroll}
              style={{ touchAction: disableNavigation ? 'auto' : 'pan-y', position: 'relative' }}
              key={cid}
            >
              {renderPrayerCard(cid, true)}
              {(cardScrollState.canScrollDown || cardScrollState.canScrollUp) && (
                <div className={`scroll-indicator`} style={{ position: 'sticky', bottom: 0, marginLeft: 'auto', marginTop: '-24px' }}>
                  {cardScrollState.canScrollDown ? '' : ''}
                </div>
              )}
            </div>
            <div className="prayer-nav-area">
              <div style={styles.swipeButtons}>
                <button className="prayer-nav-button" style={disableNavigation ? disabledBtnStyle : styles.swipeButton} onClick={disableNavigation ? undefined : swipePrev} disabled={disableNavigation}></button>
                <button className="prayer-nav-button" style={disableNavigation ? disabledBtnStyle : styles.swipeButton} onClick={disableNavigation ? undefined : swipeNext} disabled={disableNavigation}></button>
              </div>
              <div className="portrait-only" style={styles.swipeHint}>{hintText}{!disableNavigation && '  swipe or use arrows'}</div>
            </div>
          </div>
        );
      };

      const renderManage = () => {
        const renderPeopleList = () => {
          if (!people.length) return <div style={styles.emptyState}>No people yet. Tap + to add.</div>;
          const filtered = getFilteredSortedPeople();
          if (searchTerm && !filtered.length) return <div style={styles.emptyState}>No results for "{searchTerm}"</div>;
          return (() => {
              const sorted = filtered;
              const listItemStyle = { ...styles.listItem, marginBottom: 0 };
              
              if (sortBy !== 'frequency') {
                return (
                  <div className="two-column-grid">
                    {sorted.map(p => { 
                      const c = cards.find(x => x.peopleIds.includes(p.id)); 
                      const isGrouped = c?.isGroup; 
                      const isOrg = !p.firstName && !p.lastName && p.organisation; 
                      const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim(); 
                      const isArchived = p.archived;
                      return (
                        <div key={p.id} style={{ ...listItemStyle, opacity: isArchived ? 0.5 : 1 }} onClick={() => setEditingPerson(p)}>
                          <div style={{ flex: 1 }}>
                            <div style={{ ...styles.listItemName, fontStyle: isOrg ? 'italic' : 'normal' }}>
                              {displayName}
                              {p.organisation && !isOrg && <span style={{ fontSize: '12px', color: colors.textTertiary, fontStyle: 'italic', fontWeight: 'normal' }}>  {p.organisation}</span>}
                              {p.isChild && <span style={{ color: colors.textTertiary, fontSize: '12px' }}> (child)</span>}
                              {isArchived && <span style={{ color: colors.primary, fontSize: '11px', marginLeft: '6px' }}>archived</span>}
                            </div>
                            {isGrouped && !c?.archived && <div style={{ fontSize: '12px', color: colors.primary, marginTop: '2px' }}> {getCardDisplayName(c)}</div>}
                          </div>
                          <div style={{ fontSize: '12px', color: colors.textTertiary, textAlign: 'right', whiteSpace: 'nowrap' }}>{formatFrequency(c?.frequency)}  {getPrayerCountThisMonth(p.id)}</div>
                        </div>
                      ); 
                    })}
                  </div>
                );
              }
              // Frequency grouping
              const groups = {};
              sorted.forEach(p => {
                const freq = getPersonFrequency(p);
                if (!groups[freq]) groups[freq] = [];
                groups[freq].push(p);
              });
              const orderedFreqs = sortReversed ? [...frequencyOrder].reverse() : frequencyOrder;
              return orderedFreqs.map((freq) => {
                if (!groups[freq] || !groups[freq].length) return null;
                return (
                  <div key={freq}>
                    <div style={styles.frequencyHeading}>{formatFrequency(freq)}</div>
                    <div className="two-column-grid">
                      {groups[freq].map(p => {
                        const c = cards.find(x => x.peopleIds.includes(p.id));
                        const isGrouped = c?.isGroup;
                        const isOrg = !p.firstName && !p.lastName && p.organisation;
                        const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim();
                        const isArchived = p.archived;
                        return (
                          <div key={p.id} style={{ ...listItemStyle, opacity: isArchived ? 0.5 : 1 }} onClick={() => setEditingPerson(p)}>
                            <div style={{ flex: 1 }}>
                              <div style={{ ...styles.listItemName, fontStyle: isOrg ? 'italic' : 'normal' }}>
                                {displayName}
                                {p.organisation && !isOrg && <span style={{ fontSize: '12px', color: colors.textTertiary, fontStyle: 'italic', fontWeight: 'normal' }}>  {p.organisation}</span>}
                                {p.isChild && <span style={{ color: colors.textTertiary, fontSize: '12px' }}> (child)</span>}
                                {isArchived && <span style={{ color: colors.primary, fontSize: '11px', marginLeft: '6px' }}>archived</span>}
                              </div>
                              {isGrouped && !c?.archived && <div style={{ fontSize: '12px', color: colors.primary, marginTop: '2px' }}> {getCardDisplayName(c)}</div>}
                            </div>
                            <div style={{ fontSize: '12px', color: colors.textTertiary, textAlign: 'right', whiteSpace: 'nowrap' }}>{getPrayerCountThisMonth(p.id)}</div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              });
            })();
        };
        
        const renderGroupsList = () => {
          if (!getSortedCards().length) return <div style={styles.emptyState}>No groups yet.<br/>Use "Create Group" to combine people.</div>;
          const filteredCards = getFilteredSortedCards();
          if (searchTerm && !filteredCards.length) return <div style={styles.emptyState}>No results for "{searchTerm}"</div>;
          return (() => {
              const sortedCards = filteredCards;
              const listItemStyle = { ...styles.listItem, marginBottom: 0 };
              
              if (cardSortBy !== 'frequency') {
                return (
                  <div className="two-column-grid">
                    {sortedCards.map(c => { 
                      const count = c.peopleIds.length; 
                      const isArchived = c.archived;
                      return (
                        <div key={c.id} style={{ ...listItemStyle, opacity: isArchived ? 0.5 : 1 }} onClick={() => setEditingCard(c)}>
                          <div style={styles.listItemName}>
                            {getCardDisplayName(c)}
                            {isArchived && <span style={{ color: colors.primary, fontSize: '11px', marginLeft: '6px' }}>{c.dissolved ? 'disbanded' : 'archived'}</span>}
                          </div>
                          <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '2px' }}>{count} {count === 1 ? 'person' : 'people'}</div>
                          <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '4px' }}>{formatFrequency(c.frequency)}</div>
                        </div>
                      );
                    })}
                  </div>
                );
              }
              // Frequency grouping
              const groups = {};
              sortedCards.forEach(c => {
                if (!groups[c.frequency]) groups[c.frequency] = [];
                groups[c.frequency].push(c);
              });
              return frequencyOrder.map((freq) => {
                if (!groups[freq] || !groups[freq].length) return null;
                return (
                  <div key={freq}>
                    <div style={styles.frequencyHeading}>{formatFrequency(freq)}</div>
                    <div className="two-column-grid">
                      {groups[freq].map(c => {
                        const count = c.peopleIds.length;
                        const isArchived = c.archived;
                        return (
                          <div key={c.id} style={{ ...listItemStyle, opacity: isArchived ? 0.5 : 1 }} onClick={() => setEditingCard(c)}>
                            <div style={styles.listItemName}>
                              {getCardDisplayName(c)}
                              {isArchived && <span style={{ color: colors.primary, fontSize: '11px', marginLeft: '6px' }}>{c.dissolved ? 'disbanded' : 'archived'}</span>}
                            </div>
                            <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '2px' }}>{count} {count === 1 ? 'person' : 'people'}</div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              });
            })();
        };
        
        const renderSortControls = (isPeople = true) => (
          <div className="sort-row" style={{ ...styles.sortRow, marginBottom: 0 }}>
            <div style={{ ...styles.sortDropdown, marginBottom: 0 }}>
              <button style={styles.sortTrigger} onClick={() => setSortDropdownOpen(o => !o)}>
                {isPeople 
                  ? (sortBy === 'lastName' ? 'Last Name' : sortBy === 'firstName' ? 'First Name' : 'Frequency')
                  : (cardSortBy === 'name' ? 'Name' : 'Frequency')
                }
                <span style={{ marginLeft: 'auto', fontSize: '10px', opacity: 0.6 }}></span>
              </button>
              {sortDropdownOpen && (
                <>
                  <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} onClick={() => setSortDropdownOpen(false)} />
                  <div style={styles.sortMenu}>
                    {(isPeople 
                      ? [{ value: 'lastName', label: 'Last Name' }, { value: 'firstName', label: 'First Name' }, { value: 'frequency', label: 'Frequency' }]
                      : [{ value: 'name', label: 'Name' }, { value: 'frequency', label: 'Frequency' }]
                    ).map(opt => (
                      <div 
                        key={opt.value}
                        style={{ ...styles.sortOption, ...((isPeople ? sortBy : cardSortBy) === opt.value ? styles.sortOptionActive : {}) }}
                        onClick={() => { isPeople ? setSortBy(opt.value) : setCardSortBy(opt.value); setSortDropdownOpen(false); }}
                      >
                        <span style={{ width: '16px' }}>{(isPeople ? sortBy : cardSortBy) === opt.value ? '' : ''}</span>
                        {opt.label}
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
            <button style={styles.reverseBtn} onClick={() => setSortReversed(r => !r)}>{sortReversed ? '' : ''}</button>
          </div>
        );
        
        return (
          <div className="app-container" style={{ ...styles.container, display: 'flex', flexDirection: 'column', height: '100dvh', maxHeight: '100dvh', overflow: 'hidden' }}>
            <div className="app-header">
              <button style={styles.btnText} onClick={() => { setSearchTerm(''); setScreen('home'); }}><span style={{ display: 'inline-block', transform: 'translateY(-2px)' }}></span> Back</button>
              <input 
                style={styles.searchInput} 
                type="text" 
                placeholder="Search..." 
                value={searchTerm} 
                onChange={(e) => setSearchTerm(e.target.value)}
              />
              {manageTab === 'people' && <button style={styles.btnText} onClick={() => setEditingPerson({})}>+ Add</button>}
              {manageTab === 'cards' && <button style={styles.btnText} onClick={() => setScreen('createGroup')}>+ Add</button>}
            </div>
            
            <h2 style={{ fontSize: '18px', fontWeight: '600', color: colors.text, margin: '-8px 0 12px 0', textAlign: 'center' }}>Manage People & Groups</h2>
            
            {/* Portrait: Tabs stacked above sorting */}
            <div className="portrait-only">
              <div style={{ ...styles.tabs, marginBottom: '12px' }}>
                <button style={{ ...styles.tab, ...(manageTab === 'people' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setManageTab('people')}>People</button>
                <button style={{ ...styles.tab, ...(manageTab === 'cards' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setManageTab('cards')}>Groups</button>
              </div>
              <div style={{ marginBottom: '12px' }}>
                {renderSortControls(manageTab === 'people')}
              </div>
            </div>
            
            {/* Landscape: Tabs left, sorting right - same row */}
            <div className="landscape-only">
              <div style={{ display: 'flex', alignItems: 'center', marginBottom: '12px', gap: '12px', width: '100%' }}>
                <div style={{ ...styles.tabs, flex: '0 0 auto', width: '280px', marginBottom: 0 }}>
                  <button style={{ ...styles.tab, ...(manageTab === 'people' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setManageTab('people')}>People</button>
                  <button style={{ ...styles.tab, ...(manageTab === 'cards' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setManageTab('cards')}>Groups</button>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginLeft: 'auto', flex: '0 0 auto' }}>
                  {renderSortControls(manageTab === 'people')}
                </div>
              </div>
            </div>
            
            {/* 2-column grid list */}
            <div className="two-column-list" style={{ flex: 1, overflowY: 'auto', overflowX: 'hidden', padding: '12px 6px 24px 6px', margin: '0 -6px', minHeight: 0, WebkitOverflowScrolling: 'touch', touchAction: 'pan-y' }}>
              {manageTab === 'people' ? renderPeopleList() : renderGroupsList()}
            </div>
          </div>
        );
      };

      const renderEditPerson = () => {
        const isNew = !editingPerson?.id;
        const personCard = isNew ? null : cards.find(c => c.peopleIds.includes(editingPerson.id));
        // Check if name fields have content (for Type toggle - requires first or last name)
        const hasName = Boolean((personForm.firstName || '').trim() || (personForm.lastName || '').trim());
        // Check if any identifier has content (for Individual checkbox toggle - requires name or organisation)
        const hasIdentifier = Boolean((personForm.firstName || '').trim() || (personForm.lastName || '').trim() || (personForm.organisation || '').trim());
        const save = () => { 
          if (!personForm.firstName.trim() && !personForm.lastName.trim() && !personForm.organisation.trim()) { 
            alert('Enter a name or organisation'); 
            return; 
          } 
          if (isNew) addPerson(personForm); 
          else updatePerson(editingPerson.id, personForm); 
          setEditingPerson(null); 
        };
        const del = () => setModal({
          title: 'Delete person?',
          message: `This will remove ${personForm.firstName || personForm.organisation} and their prayer history permanently.`,
          confirmText: 'Delete',
          danger: true,
          onConfirm: () => { deletePerson(editingPerson.id); setEditingPerson(null); }
        });
        return (
          <div className="app-container" style={{ ...styles.container, display: 'flex', flexDirection: 'column', height: '100dvh', maxHeight: '100dvh', overflow: 'hidden' }}>
            <div className="app-header" style={{ flexShrink: 0 }}><button style={styles.btnText} onClick={() => setEditingPerson(null)}>Cancel</button><button style={styles.btnText} onClick={save}>Save</button></div>
            <div style={{ flex: 1, overflowY: 'auto', overflowX: 'hidden', WebkitOverflowScrolling: 'touch', touchAction: 'pan-y', paddingBottom: '20px' }}>
            {!isNew && personCard && (
              <div 
                style={{ ...styles.card, padding: '14px 16px', marginBottom: '20px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', cursor: 'pointer' }}
                onClick={() => { setEditingPerson(null); setEditingCard(personCard); }}
              >
                <div>
                  <div style={{ fontSize: '12px', color: colors.textTertiary, marginBottom: '2px' }}>{personCard.isGroup ? 'PART OF GROUP' : 'PRAYER CARD'}</div>
                  <div style={{ fontSize: '16px', fontWeight: '600', color: colors.primary }}>{getCardDisplayName(personCard)}</div>
                </div>
                <div style={{ fontSize: '20px', color: colors.textTertiary }}></div>
              </div>
            )}
            
            <label style={styles.label}>First Name</label>
            <input 
              ref={firstNameRef}
              style={styles.input} 
              value={personForm.firstName} 
              onChange={e => setPersonForm({ ...personForm, firstName: e.target.value })} 
              onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); lastNameRef.current?.focus(); } }}
              enterKeyHint="next"
              autoCapitalize="words"
              placeholder="First name" 
            />
            <label style={styles.label}>Last Name</label>
            <input 
              ref={lastNameRef}
              style={styles.input} 
              value={personForm.lastName} 
              onChange={e => setPersonForm({ ...personForm, lastName: e.target.value })} 
              onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); organisationRef.current?.focus(); } }}
              enterKeyHint="next"
              autoCapitalize="words"
              placeholder="Last name" 
            />
            <label style={styles.label}>Organisation / Ministry</label>
            <input 
              ref={organisationRef}
              style={styles.input} 
              value={personForm.organisation} 
              onChange={e => setPersonForm({ ...personForm, organisation: e.target.value })} 
              onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); prayerPointsRef.current?.focus(); } }}
              enterKeyHint="next"
              autoCapitalize="words"
              placeholder="Optional - e.g. OMF, City Youth" 
            />
            <label style={styles.label}>Prayer Points</label>
            <textarea 
              ref={prayerPointsRef}
              style={{ ...styles.input, minHeight: '80px', resize: 'vertical' }} 
              value={personForm.prayerPoint} 
              onChange={e => setPersonForm({ ...personForm, prayerPoint: e.target.value })} 
              placeholder="One per line" 
            />
            <label style={styles.label}>Frequency</label>
            <div style={styles.sortDropdown}>
              <button type="button" style={styles.sortTrigger} onClick={() => setFreqDropdownOpen(!freqDropdownOpen)}>
                {{ daily: 'Daily', 'every-2-3-days': 'Every 2-3 Days', weekly: 'Weekly', fortnightly: 'Fortnightly', monthly: 'Monthly' }[personForm.frequency]}
                <span style={{ marginLeft: 'auto', fontSize: '10px', opacity: 0.6 }}></span>
              </button>
              {freqDropdownOpen && (
                <>
                  <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} onClick={() => setFreqDropdownOpen(false)} />
                  <div style={styles.sortMenu}>
                    {[{ value: 'daily', label: 'Daily' }, { value: 'every-2-3-days', label: 'Every 2-3 Days' }, { value: 'weekly', label: 'Weekly' }, { value: 'fortnightly', label: 'Fortnightly' }, { value: 'monthly', label: 'Monthly' }].map(opt => (
                      <div key={opt.value} style={{ ...styles.sortOption, ...(personForm.frequency === opt.value ? styles.sortOptionActive : {}) }} onClick={() => { setPersonForm({ ...personForm, frequency: opt.value }); setFreqDropdownOpen(false); }}>
                        <span style={{ width: '16px' }}>{personForm.frequency === opt.value ? '' : ''}</span>
                        {opt.label}
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
            <label style={styles.label}>Type {!hasName && <span style={{ fontSize: '11px', color: colors.textTertiary, fontWeight: 'normal' }}>(enter a name first)</span>}</label>
            <div style={{ ...styles.toggle, opacity: !hasName ? 0.4 : 1 }}>
              <button 
                type="button"
                disabled={!hasName}
                style={{ 
                  ...styles.toggleOption, 
                  ...(!personForm.isChild ? styles.toggleActive : styles.toggleInactive),
                  cursor: !hasName ? 'not-allowed' : 'pointer',
                  border: 'none',
                  fontFamily: 'inherit'
                }} 
                onClick={() => setPersonForm({ ...personForm, isChild: false })}
              >
                Adult
              </button>
              <button 
                type="button"
                disabled={!hasName}
                style={{ 
                  ...styles.toggleOption, 
                  ...(personForm.isChild ? styles.toggleActive : styles.toggleInactive),
                  cursor: !hasName ? 'not-allowed' : 'pointer',
                  border: 'none',
                  fontFamily: 'inherit'
                }} 
                onClick={() => setPersonForm({ ...personForm, isChild: true })}
              >
                Child
              </button>
            </div>
            <label style={styles.label}>Individual checkbox {!hasIdentifier && <span style={{ fontSize: '11px', color: colors.textTertiary, fontWeight: 'normal' }}>(enter a name or organisation first)</span>}</label>
            <div style={{ ...styles.toggle, opacity: !hasIdentifier ? 0.4 : 1 }}>
              <button 
                type="button"
                disabled={!hasIdentifier}
                style={{ 
                  ...styles.toggleOption, 
                  ...(personForm.individualCheckbox ? styles.toggleActive : styles.toggleInactive),
                  cursor: !hasIdentifier ? 'not-allowed' : 'pointer',
                  border: 'none',
                  fontFamily: 'inherit'
                }} 
                onClick={() => setPersonForm({ ...personForm, individualCheckbox: true })}
              >
                Yes
              </button>
              <button 
                type="button"
                disabled={!hasIdentifier}
                style={{ 
                  ...styles.toggleOption, 
                  ...(!personForm.individualCheckbox ? styles.toggleActive : styles.toggleInactive),
                  cursor: !hasIdentifier ? 'not-allowed' : 'pointer',
                  border: 'none',
                  fontFamily: 'inherit'
                }} 
                onClick={() => setPersonForm({ ...personForm, individualCheckbox: false })}
              >
                No
              </button>
            </div>
            {!isNew && (
              <>
                <button style={{ ...styles.btnSecondary, width: '100%', marginTop: '8px' }} onClick={() => { setViewingStats(editingPerson); setEditingPerson(null); }}>View History</button>
                {editingPerson.archived && (
                  <div style={{ 
                    background: 'rgba(184, 122, 74, 0.1)', 
                    border: `1px solid ${colors.primary}`,
                    borderRadius: '8px', 
                    padding: '12px', 
                    marginTop: '16px',
                    textAlign: 'center'
                  }}>
                    <div style={{ fontSize: '13px', color: colors.primary, fontWeight: '600' }}>This person is archived</div>
                    <div style={{ fontSize: '12px', color: colors.textSecondary, marginTop: '4px' }}>
                      They won't appear in prayer rotation or active groups
                    </div>
                  </div>
                )}
                <div style={{ display: 'flex', gap: '12px', marginTop: '16px' }}>
                  {editingPerson.archived ? (
                    <button 
                      style={{ ...styles.btnSecondary, flex: 1 }} 
                      onClick={() => { unarchivePerson(editingPerson.id); setEditingPerson(null); }}
                    >
                      Unarchive
                    </button>
                  ) : (
                    <button 
                      style={styles.btnArchive} 
                      onClick={() => setModal({
                        title: 'Archive person?',
                        message: `${personForm.firstName || personForm.organisation} will no longer appear in your prayer rotation but their history will be preserved.`,
                        confirmText: 'Archive',
                        danger: false,
                        onConfirm: () => { archivePerson(editingPerson.id); setEditingPerson(null); }
                      })}
                    >
                      Archive
                    </button>
                  )}
                  <button style={{ ...styles.btnDanger, flex: 1, marginTop: 0 }} onClick={del}>Delete</button>
                </div>
              </>
            )}
            </div>
          </div>
        );
      };

      const renderEditCard = () => {
        const cp = editingCard?.peopleIds.map(id => people.find(p => p.id === id)).filter(Boolean) || [];
        const save = () => { if (!cardForm.name.trim()) { alert('Name required'); return; } updateCard(editingCard.id, cardForm); setEditingCard(null); };
        return (
          <div className="app-container" style={{ ...styles.container, display: 'flex', flexDirection: 'column', height: '100dvh', maxHeight: '100dvh', overflow: 'hidden' }}>
            <div className="app-header" style={{ flexShrink: 0 }}><button style={styles.btnText} onClick={() => setEditingCard(null)}>Cancel</button><button style={styles.btnText} onClick={save}>Save</button></div>
            <div style={{ flex: 1, overflowY: 'auto', overflowX: 'hidden', WebkitOverflowScrolling: 'touch', touchAction: 'pan-y', paddingBottom: '20px' }}>
            <label style={styles.label}>Card Name</label><input style={styles.input} value={cardForm.name} onChange={e => setCardForm({ ...cardForm, name: e.target.value })} />
            <label style={styles.label}>Frequency</label>
            <div style={styles.sortDropdown}>
              <button type="button" style={styles.sortTrigger} onClick={() => setFreqDropdownOpen(!freqDropdownOpen)}>
                {{ daily: 'Daily', 'every-2-3-days': 'Every 2-3 Days', weekly: 'Weekly', fortnightly: 'Fortnightly', monthly: 'Monthly' }[cardForm.frequency]}
                <span style={{ marginLeft: 'auto', fontSize: '10px', opacity: 0.6 }}></span>
              </button>
              {freqDropdownOpen && (
                <>
                  <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} onClick={() => setFreqDropdownOpen(false)} />
                  <div style={styles.sortMenu}>
                    {[{ value: 'daily', label: 'Daily' }, { value: 'every-2-3-days', label: 'Every 2-3 Days' }, { value: 'weekly', label: 'Weekly' }, { value: 'fortnightly', label: 'Fortnightly' }, { value: 'monthly', label: 'Monthly' }].map(opt => (
                      <div key={opt.value} style={{ ...styles.sortOption, ...(cardForm.frequency === opt.value ? styles.sortOptionActive : {}) }} onClick={() => { setCardForm({ ...cardForm, frequency: opt.value }); setFreqDropdownOpen(false); }}>
                        <span style={{ width: '16px' }}>{cardForm.frequency === opt.value ? '' : ''}</span>
                        {opt.label}
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
            <label style={styles.label}>Prayer Points</label><textarea style={{ ...styles.input, minHeight: '80px', resize: 'vertical' }} value={cardForm.prayerPoint} onChange={e => setCardForm({ ...cardForm, prayerPoint: e.target.value })} placeholder="One per line" />
            {editingCard?.isGroup && (
              <>
                <label style={styles.label}>Unnamed children</label>
                <div style={styles.toggle}>
                  <div style={{ ...styles.toggleOption, ...(cardForm.includeUnnamedChildren ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setCardForm({ ...cardForm, includeUnnamedChildren: true })}>Yes</div>
                  <div style={{ ...styles.toggleOption, ...(!cardForm.includeUnnamedChildren ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setCardForm({ ...cardForm, includeUnnamedChildren: false })}>No</div>
                </div>
                <label style={styles.label}>People in group</label>
                {cp.map(p => {
                  const isOrg = !p.firstName && !p.lastName && p.organisation;
                  const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim();
                  return (
                    <div key={p.id} style={{ ...styles.listItem, cursor: 'default', display: 'flex', justifyContent: 'space-between', alignItems: 'center', opacity: p.archived ? 0.5 : 1 }}>
                      <div>
                        <span style={{ fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</span>
                        <span style={{ fontSize: '12px', color: colors.textTertiary, marginLeft: '8px' }}>{p.isChild ? 'Child' : 'Adult'}</span>
                        {p.archived && <span style={{ fontSize: '11px', color: colors.primary, marginLeft: '8px' }}>(archived)</span>}
                      </div>
                      {!editingCard.archived && (
                        <button 
                          style={{ background: 'none', border: 'none', color: colors.textTertiary, fontSize: '18px', cursor: 'pointer', padding: '4px 8px' }}
                          onClick={() => setModal({
                            title: 'Remove from group?',
                            message: `${displayName} will be removed from this group and given their own individual prayer card. Their prayer history will be preserved.`,
                            confirmText: 'Remove',
                            onConfirm: () => removeFromGroup(editingCard.id, p.id)
                          })}
                        ></button>
                      )}
                    </div>
                  );
                })}
                {editingCard.archived ? (
                  <>
                    <div style={{ 
                      background: 'rgba(184, 122, 74, 0.1)', 
                      border: `1px solid ${colors.primary}`,
                      borderRadius: '8px', 
                      padding: '12px', 
                      marginTop: '16px',
                      textAlign: 'center'
                    }}>
                      <div style={{ fontSize: '13px', color: colors.primary, fontWeight: '600' }}>
                        {editingCard.dissolved ? 'This group has been disbanded' : 'This group is archived'}
                      </div>
                      <div style={{ fontSize: '12px', color: colors.textSecondary, marginTop: '4px' }}>
                        Prayer history has been preserved
                      </div>
                    </div>
                    <div style={{ display: 'flex', gap: '12px', marginTop: '16px' }}>
                      <button 
                        style={{ ...styles.btnSecondary, flex: 1 }} 
                        onClick={() => { unarchiveCard(editingCard.id); setEditingCard(null); }}
                      >
                        {editingCard.dissolved ? 'Reconstitute' : 'Unarchive'}
                      </button>
                      <button 
                        style={{ ...styles.btnDanger, flex: 1, marginTop: 0 }} 
                        onClick={() => setModal({
                          title: 'Delete group permanently?',
                          message: 'This will permanently delete this group and its prayer history. This cannot be undone.',
                          confirmText: 'Delete',
                          danger: true,
                          onConfirm: () => { setCards(prev => prev.filter(c => c.id !== editingCard.id)); setEditingCard(null); }
                        })}
                      >
                        Delete
                      </button>
                    </div>
                  </>
                ) : (
                  <>
                    <button style={{ ...styles.btnSecondary, width: '100%', marginTop: '15px' }} onClick={() => setModal({
                      title: 'Split group?',
                      message: 'This will archive the group and create individual prayer cards for each non-archived person. Prayer history will be preserved.',
                      confirmText: 'Split',
                      onConfirm: () => { dissolveGroup(editingCard.id); setEditingCard(null); }
                    })}>Split into individuals</button>
                    <div style={{ display: 'flex', gap: '12px', marginTop: '12px' }}>
                      <button 
                        style={styles.btnArchive} 
                        onClick={() => setModal({
                          title: 'Archive group?',
                          message: `This group will no longer appear in your prayer rotation but its history will be preserved.`,
                          confirmText: 'Archive',
                          danger: false,
                          onConfirm: () => { archiveCard(editingCard.id); setEditingCard(null); }
                        })}
                      >
                        Archive
                      </button>
                      <button 
                        style={{ ...styles.btnDanger, flex: 1, marginTop: 0 }} 
                        onClick={() => setModal({
                          title: 'Delete group?',
                          message: 'This will permanently delete this group and its prayer history. This cannot be undone.',
                          confirmText: 'Delete',
                          danger: true,
                          onConfirm: () => { setCards(prev => prev.filter(c => c.id !== editingCard.id)); setEditingCard(null); }
                        })}
                      >
                        Delete
                      </button>
                    </div>
                  </>
                )}
              </>
            )}
            {!editingCard?.isGroup && <button style={styles.btnDanger} onClick={() => setModal({
              title: 'Delete person?',
              message: 'This will remove this person and their prayer history permanently.',
              confirmText: 'Delete',
              danger: true,
              onConfirm: () => { deleteCard(editingCard.id); setEditingCard(null); }
            })}>Delete</button>}
            </div>
          </div>
        );
      };

      const renderCreateGroup = () => {
        const sel = people.filter(p => selectedPeopleForGroup.includes(p.id));
        const create = () => { if (!groupForm.name.trim()) { alert('Name required'); return; } createGroup({ ...groupForm, peopleIds: selectedPeopleForGroup, checkboxOverrides }); setSelectedPeopleForGroup([]); setScreen('home'); };
        if (groupStep === 1) return (
          <div className="app-container" style={{ ...styles.container, display: 'flex', flexDirection: 'column', height: '100dvh', maxHeight: '100dvh', overflow: 'hidden' }}>
            <div className="app-header">
              <button style={styles.btnText} onClick={() => { setSelectedPeopleForGroup([]); setSearchTerm(''); setScreen('home'); }}>Cancel</button>
              <input 
                style={styles.searchInput} 
                type="text" 
                placeholder="Search..." 
                value={searchTerm} 
                onChange={(e) => setSearchTerm(e.target.value)}
              />
              <button style={{ ...styles.btnText, opacity: selectedPeopleForGroup.length < 2 ? 0.4 : 1 }} onClick={() => { if (selectedPeopleForGroup.length >= 2) { setSearchTerm(''); setGroupStep(2); } }}>Next ({selectedPeopleForGroup.length})</button>
            </div>
            <div style={{ fontSize: '20px', fontWeight: '700', marginBottom: '12px' }}>Select people to group</div>
            
            {/* Sorting controls */}
            <div style={{ ...styles.sortRow, marginBottom: '12px' }}>
              <div style={{ ...styles.sortDropdown, marginBottom: 0 }}>
                <button style={styles.sortTrigger} onClick={() => setSortDropdownOpen(o => !o)}>
                  {sortBy === 'lastName' ? 'Last Name' : sortBy === 'firstName' ? 'First Name' : 'Frequency'}
                  <span style={{ marginLeft: 'auto', fontSize: '10px', opacity: 0.6 }}></span>
                </button>
                {sortDropdownOpen && (
                  <>
                    <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} onClick={() => setSortDropdownOpen(false)} />
                    <div style={styles.sortMenu}>
                      {[{ value: 'lastName', label: 'Last Name' }, { value: 'firstName', label: 'First Name' }, { value: 'frequency', label: 'Frequency' }].map(opt => (
                        <div 
                          key={opt.value}
                          style={{ ...styles.sortOption, ...(sortBy === opt.value ? styles.sortOptionActive : {}) }}
                          onClick={() => { setSortBy(opt.value); setSortDropdownOpen(false); }}
                        >
                          <span style={{ width: '16px' }}>{sortBy === opt.value ? '' : ''}</span>
                          {opt.label}
                        </div>
                      ))}
                    </div>
                  </>
                )}
              </div>
              <button style={styles.reverseBtn} onClick={() => setSortReversed(r => !r)}>{sortReversed ? '' : ''}</button>
            </div>
            
            {!people.length ? <div style={styles.emptyState}>Add people first.</div> : (() => {
              // Filter out archived people from group selection
              const filtered = getFilteredSortedPeople().filter(p => !p.archived);
              if (searchTerm && !filtered.length) return <div style={styles.emptyState}>No results for "{searchTerm}"</div>;
              if (!filtered.length) return <div style={styles.emptyState}>No active people available.<br/>Unarchive people to add them to groups.</div>;
              return (
              <div className="two-column-list" style={{ flex: 1, overflowY: 'auto', overflowX: 'hidden', padding: '4px 6px', margin: '0 -6px', minHeight: 0, WebkitOverflowScrolling: 'touch', touchAction: 'pan-y' }}>
                {sortBy !== 'frequency' ? (
                  <div className="two-column-grid">
                    {filtered.map(p => { 
                      const isSel = selectedPeopleForGroup.includes(p.id); 
                      const isOrg = !p.firstName && !p.lastName && p.organisation; 
                      const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim(); 
                      return (
                        <div key={p.id} style={{ ...styles.listItem, background: isSel ? colors.primaryGradient : colors.cardBg, color: isSel ? colors.primaryText : colors.text }} onClick={() => setSelectedPeopleForGroup(prev => isSel ? prev.filter(id => id !== p.id) : [...prev, p.id])}>
                          <span style={{ fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</span>
                          {p.isChild && <span style={{ fontSize: '12px', opacity: 0.7 }}>(child)</span>}
                        </div>
                      ); 
                    })}
                  </div>
                ) : (
                  (() => {
                    const groups = {};
                    filtered.forEach(p => {
                      const freq = getPersonFrequency(p);
                      if (!groups[freq]) groups[freq] = [];
                      groups[freq].push(p);
                    });
                    const orderedFreqs = sortReversed ? [...frequencyOrder].reverse() : frequencyOrder;
                    return orderedFreqs.map((freq) => {
                      if (!groups[freq] || !groups[freq].length) return null;
                      return (
                        <div key={freq}>
                          <div style={styles.frequencyHeading}>{formatFrequency(freq)}</div>
                          <div className="two-column-grid">
                            {groups[freq].map(p => { 
                              const isSel = selectedPeopleForGroup.includes(p.id); 
                              const isOrg = !p.firstName && !p.lastName && p.organisation; 
                              const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim(); 
                              return (
                                <div key={p.id} style={{ ...styles.listItem, background: isSel ? colors.primaryGradient : colors.cardBg, color: isSel ? colors.primaryText : colors.text }} onClick={() => setSelectedPeopleForGroup(prev => isSel ? prev.filter(id => id !== p.id) : [...prev, p.id])}>
                                  <span style={{ fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</span>
                                  {p.isChild && <span style={{ fontSize: '12px', opacity: 0.7 }}>(child)</span>}
                                </div>
                              ); 
                            })}
                          </div>
                        </div>
                      );
                    });
                  })()
                )}
              </div>
              );
            })()}
          </div>
        );
        return (
          <div className="app-container" style={{ ...styles.container, display: 'flex', flexDirection: 'column', height: '100dvh', maxHeight: '100dvh', overflow: 'hidden', overscrollBehavior: 'none' }}>
            <div className="app-header"><button style={styles.btnText} onClick={() => setGroupStep(1)}><span style={{ display: 'inline-block', transform: 'translateY(-2px)' }}></span> Back</button><button style={styles.btnText} onClick={create}>Create</button></div>
            <div style={{ flex: 1, overflowY: 'auto', overflowX: 'hidden', paddingBottom: '20px', WebkitOverflowScrolling: 'touch', touchAction: 'pan-y' }}>
              <label style={styles.label}>Group Name</label>
              <input 
                ref={groupNameRef}
                style={styles.input} 
                value={groupForm.name} 
                onChange={e => setGroupForm({ ...groupForm, name: e.target.value })} 
                onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); groupPrayerPointsRef.current?.focus(); } }}
                enterKeyHint="next"
                autoCapitalize="words"
                placeholder="e.g. Smiths" 
              />
              <label style={styles.label}>Frequency</label>
              <div style={styles.sortDropdown}>
                <button type="button" style={styles.sortTrigger} onClick={() => setFreqDropdownOpen(!freqDropdownOpen)}>
                  {{ daily: 'Daily', 'every-2-3-days': 'Every 2-3 Days', weekly: 'Weekly', fortnightly: 'Fortnightly', monthly: 'Monthly' }[groupForm.frequency]}
                  <span style={{ marginLeft: 'auto', fontSize: '10px', opacity: 0.6 }}></span>
                </button>
                {freqDropdownOpen && (
                  <>
                    <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} onClick={() => setFreqDropdownOpen(false)} />
                    <div style={styles.sortMenu}>
                      {[{ value: 'daily', label: 'Daily' }, { value: 'every-2-3-days', label: 'Every 2-3 Days' }, { value: 'weekly', label: 'Weekly' }, { value: 'fortnightly', label: 'Fortnightly' }, { value: 'monthly', label: 'Monthly' }].map(opt => (
                        <div key={opt.value} style={{ ...styles.sortOption, ...(groupForm.frequency === opt.value ? styles.sortOptionActive : {}) }} onClick={() => { setGroupForm({ ...groupForm, frequency: opt.value }); setFreqDropdownOpen(false); }}>
                          <span style={{ width: '16px' }}>{groupForm.frequency === opt.value ? '' : ''}</span>
                          {opt.label}
                        </div>
                      ))}
                    </div>
                  </>
                )}
              </div>
              <label style={styles.label}>Prayer Points</label>
              <textarea 
                ref={groupPrayerPointsRef}
                style={{ ...styles.input, minHeight: '60px', resize: 'vertical' }} 
                value={groupForm.prayerPoint} 
                onChange={e => setGroupForm({ ...groupForm, prayerPoint: e.target.value })} 
                placeholder="One per line" 
              />
              <label style={styles.label}>Unnamed children</label><div style={styles.toggle}><div style={{ ...styles.toggleOption, ...(groupForm.includeUnnamedChildren ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setGroupForm({ ...groupForm, includeUnnamedChildren: true })}>Yes</div><div style={{ ...styles.toggleOption, ...(!groupForm.includeUnnamedChildren ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setGroupForm({ ...groupForm, includeUnnamedChildren: false })}>No</div></div>
              <label style={styles.label}>Checkboxes</label><div>{sel.map(p => { const isOrg = !p.firstName && !p.lastName && p.organisation; const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim(); return <div key={p.id} style={{ ...styles.listItem, flexDirection: 'column', alignItems: 'stretch' }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}><span style={{ fontWeight: '500', fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</span><span style={{ fontSize: '12px', color: colors.textTertiary }}>{p.isChild ? 'Child' : 'Adult'}</span></div><div style={{ ...styles.toggle, marginBottom: 0 }}><div style={{ ...styles.toggleOption, fontSize: '13px', padding: '8px', ...((checkboxOverrides[p.id] ?? p.individualCheckbox) ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setCheckboxOverrides({ ...checkboxOverrides, [p.id]: true })}>Individual</div><div style={{ ...styles.toggleOption, fontSize: '13px', padding: '8px', ...(!(checkboxOverrides[p.id] ?? p.individualCheckbox) ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setCheckboxOverrides({ ...checkboxOverrides, [p.id]: false })}>Grouped</div></div></div>; })}</div>
            </div>
          </div>
        );
      };

      // Get prayer history for a card (union of all people's histories)
      const getCardPrayerHistory = (card) => {
        const dateMap = new Map(); // date -> first history entry found
        card.peopleIds.forEach(pid => {
          const p = people.find(x => x.id === pid);
          (p?.prayerHistory || []).forEach(h => {
            const date = typeof h === 'string' ? h : h.date;
            if (!dateMap.has(date)) {
              dateMap.set(date, h);
            }
          });
        });
        return [...dateMap.values()].sort((a, b) => {
          const dateA = typeof a === 'string' ? a : a.date;
          const dateB = typeof b === 'string' ? b : b.date;
          return new Date(dateB) - new Date(dateA);
        });
      };
      
      const getCardPrayerCountThisMonth = (card) => {
        const m = new Date().getMonth(), y = new Date().getFullYear();
        const hist = getCardPrayerHistory(card);
        return getHistoryDates(hist).filter(d => {
          const x = new Date(d);
          return x.getMonth() === m && x.getFullYear() === y;
        }).length;
      };

      const renderStats = () => {
        // Individual person or group detail view
        if (viewingStats) {
          const isCard = viewingStats.peopleIds !== undefined;
          const hist = isCard ? getCardPrayerHistory(viewingStats) : (viewingStats.prayerHistory || []);
          const histDates = getHistoryDates(hist);
          const m = statsMonth.getMonth(), y = statsMonth.getFullYear();
          const days = new Date(y, m + 1, 0).getDate(), first = new Date(y, m, 1).getDay();
          const prayed = histDates.filter(d => { const x = new Date(d); return x.getMonth() === m && x.getFullYear() === y; }).map(d => new Date(d).getDate());
          const mName = new Date(y, m).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
          const isOrg = !isCard && !viewingStats.firstName && !viewingStats.lastName && viewingStats.organisation;
          const displayName = isCard ? viewingStats.name : (isOrg ? viewingStats.organisation : `${viewingStats.firstName} ${viewingStats.lastName}`.trim());
          const allDates = [...histDates].sort((a, b) => new Date(b) - new Date(a));
          
          // Check if selected date is in current month view
          const selectedInMonth = selectedHistoryDate && new Date(selectedHistoryDate).getMonth() === m && new Date(selectedHistoryDate).getFullYear() === y;
          const selectedDay = selectedInMonth ? new Date(selectedHistoryDate).getDate() : null;
          
          // Get historical entry for selected date
          const selectedEntry = selectedHistoryDate ? getHistoryForDate(hist, selectedHistoryDate) : null;
          
          // Render historical prayer points
          const renderHistoricalPrayerPoints = (text) => {
            if (!text) return null;
            const points = text.split('\n').filter(p => p.trim());
            if (points.length === 0) return null;
            return (
              <div style={{ fontSize: '14px', color: colors.textSecondary, fontStyle: 'italic', marginTop: '8px' }}>
                {points.map((point, i) => (
                  <div key={i} style={{ display: 'flex', gap: '8px', marginBottom: '2px' }}>
                    <span style={{ color: colors.textTertiary }}></span>
                    <span>{point}</span>
                  </div>
                ))}
              </div>
            );
          };
          
          return (
            <div className="app-container" style={{ ...styles.container, display: 'flex', flexDirection: 'column', height: '100dvh', maxHeight: '100dvh', overflow: 'hidden' }}>
              <div className="app-header" style={{ position: 'relative', flexShrink: 0 }}>
                <button style={styles.btnText} onClick={() => { setViewingStats(null); setSelectedHistoryDate(null); }}><span style={{ display: 'inline-block', transform: 'translateY(-2px)' }}></span> Back</button>
                <div className="landscape-only" style={{ position: 'absolute', left: '50%', top: '50%', transform: 'translate(-50%, -50%)', display: 'flex', alignItems: 'center', gap: '12px' }}>
                  <div style={{ fontSize: '18px', fontWeight: '700', fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</div>
                  <div style={{ color: colors.textSecondary, fontSize: '14px' }}>{prayed.length} times in {mName}</div>
                </div>
              </div>
              <div style={{ flex: 1, overflowY: 'auto', overflowX: 'hidden', WebkitOverflowScrolling: 'touch', touchAction: 'pan-y', paddingBottom: '20px' }}>
              <div className="portrait-only" style={{ fontSize: '22px', fontWeight: '700', marginBottom: '4px', fontStyle: isOrg ? 'italic' : 'normal' }}>{displayName}</div>
              <div className="portrait-only" style={{ color: colors.textSecondary, marginBottom: '24px', fontSize: '16px' }}>{prayed.length} times in {mName}</div>
              
              {/* Portrait: stacked layout */}
              <div className="portrait-only">
                <div className="calendar" style={{ ...styles.calendar, padding: '22px' }}>
                  <div className="calendar-header" style={{ ...styles.calendarHeader, marginBottom: '12px' }}><button className="nav-button" style={{ ...styles.navButton, fontSize: '16px', padding: '4px 8px' }} onClick={() => setStatsMonth(new Date(y, m - 1))}></button><span style={{ fontWeight: '600', fontSize: '15px' }}>{mName}</span><button className="nav-button" style={{ ...styles.navButton, fontSize: '16px', padding: '4px 8px' }} onClick={() => setStatsMonth(new Date(y, m + 1))}></button></div>
                  <div className="calendar-grid" style={{ ...styles.calendarGrid, gap: '4px' }}>
                    {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((d, i) => <div key={i} className="calendar-day-header" style={{ ...styles.calendarDayHeader, fontSize: '11px', padding: '4px 2px' }}>{d}</div>)}
                    {Array(first).fill(null).map((_, i) => <div key={`e${i}`} className="calendar-day" style={{ ...styles.calendarDay, padding: '6px 2px', fontSize: '13px', borderRadius: '6px' }}></div>)}
                    {Array(days).fill(null).map((_, i) => { 
                      const day = i + 1;
                      const isPrayed = prayed.includes(day);
                      const isSelected = day === selectedDay;
                      return (
                        <div 
                          key={day} 
                          className="calendar-day"
                          style={{ 
                            ...styles.calendarDay, 
                            ...(isPrayed ? styles.prayedDay : {}),
                            ...(isSelected ? { boxShadow: `inset 0 0 0 3px ${colors.primary}` } : {}),
                            cursor: isPrayed ? 'pointer' : 'default',
                            transition: 'all 0.15s ease',
                            padding: '6px 2px',
                            fontSize: '13px',
                            borderRadius: '6px'
                          }}
                          onClick={() => isPrayed && setSelectedHistoryDate(formatDate(new Date(y, m, day)))}
                        >
                          {day}
                        </div>
                      );
                    })}
                  </div>
                </div>
                
                {/* Historical Prayer Card - below calendar */}
                {selectedHistoryDate && (() => {
                // For cards, gather all individual prayer points from that date
                const individualPoints = [];
                if (isCard) {
                  viewingStats.peopleIds.forEach(pid => {
                    const person = people.find(p => p.id === pid);
                    if (person) {
                      const personEntry = getHistoryForDate(person.prayerHistory, selectedHistoryDate);
                      if (personEntry?.personPrayerPoint) {
                        const displayName = person.firstName || person.organisation || 'Unknown';
                        individualPoints.push({ name: displayName, points: personEntry.personPrayerPoint });
                      }
                    }
                  });
                }
                
                const hasCardPoints = selectedEntry?.cardPrayerPoint;
                const hasPersonalPoints = !isCard && selectedEntry?.personPrayerPoint;
                const hasIndividualPoints = individualPoints.length > 0;
                const hasAnyPoints = hasCardPoints || hasPersonalPoints || hasIndividualPoints;
                
                if (!hasAnyPoints) {
                  return (
                    <div style={{ ...styles.card, marginTop: '16px', background: colors.secondaryGradient, textAlign: 'center', padding: '12px 14px' }}>
                      <div style={{ fontSize: '13px', color: colors.textSecondary }}>
                        No prayer points recorded for {new Date(selectedHistoryDate).toLocaleDateString('en-US', { day: 'numeric', month: 'short', year: 'numeric' })}
                      </div>
                      <div style={{ fontSize: '11px', color: colors.textTertiary, marginTop: '4px' }}>
                        (Prayer points are saved from new prayers going forward)
                      </div>
                    </div>
                  );
                }
                
                return (
                  <div style={{ ...styles.card, marginTop: '16px', padding: '12px 14px', background: colors.primaryGradient + '15', border: `2px solid ${colors.primary}` }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                      <div style={{ fontSize: '12px', fontWeight: '600', color: colors.primary, textTransform: 'uppercase', letterSpacing: '0.5px' }}>
                        Prayer on {new Date(selectedHistoryDate).toLocaleDateString('en-US', { weekday: 'short', day: 'numeric', month: 'short', year: 'numeric' })}
                      </div>
                      <button 
                        style={{ background: 'none', border: 'none', color: colors.textTertiary, fontSize: '16px', cursor: 'pointer', padding: '2px' }}
                        onClick={() => setSelectedHistoryDate(null)}
                      ></button>
                    </div>
                    {hasCardPoints && (
                      <div style={{ marginBottom: (hasPersonalPoints || hasIndividualPoints) ? '10px' : '0' }}>
                        <div style={{ fontSize: '11px', color: colors.textTertiary, marginBottom: '2px' }}>Card</div>
                        {renderHistoricalPrayerPoints(selectedEntry.cardPrayerPoint)}
                      </div>
                    )}
                    {hasPersonalPoints && (
                      <div>
                        <div style={{ fontSize: '11px', color: colors.textTertiary, marginBottom: '2px' }}>Personal</div>
                        {renderHistoricalPrayerPoints(selectedEntry.personPrayerPoint)}
                      </div>
                    )}
                    {hasIndividualPoints && (
                      <div>
                        <div style={{ fontSize: '11px', color: colors.textTertiary, marginBottom: '4px' }}>Individual Prayer Points</div>
                        {individualPoints.map((item, idx) => (
                          <div key={idx} style={{ marginBottom: idx < individualPoints.length - 1 ? '8px' : '0' }}>
                            <div style={{ fontSize: '13px', fontWeight: '600', color: colors.text, marginBottom: '2px' }}>{item.name}</div>
                            {renderHistoricalPrayerPoints(item.points)}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                );
              })()}
              
                {allDates.length > 0 && (
                  <div style={{ marginTop: '24px' }}>
                    <div style={{ fontSize: '13px', fontWeight: '600', color: colors.textSecondary, textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '12px' }}>All Prayer Dates</div>
                    {(() => {
                      // Group dates by month
                      const monthGroups = {};
                      allDates.forEach(date => {
                        const d = new Date(date);
                        const key = `${d.getFullYear()}-${String(d.getMonth()).padStart(2, '0')}`;
                        if (!monthGroups[key]) {
                          monthGroups[key] = { year: d.getFullYear(), month: d.getMonth(), dates: [] };
                        }
                        monthGroups[key].dates.push({ date, day: d.getDate() });
                      });
                      // Sort month keys descending
                      const sortedKeys = Object.keys(monthGroups).sort((a, b) => b.localeCompare(a));
                      return sortedKeys.map(key => {
                        const group = monthGroups[key];
                        const monthLabel = new Date(group.year, group.month).toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        // Sort dates within month ascending
                        group.dates.sort((a, b) => a.day - b.day);
                        return (
                          <div key={key} style={{ marginBottom: '12px' }}>
                            <div style={{ display: 'flex', alignItems: 'flex-start', gap: '12px' }}>
                              <div style={{ fontSize: '13px', fontWeight: '600', color: colors.textTertiary, minWidth: '70px', paddingTop: '6px' }}>{monthLabel}</div>
                              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px', flex: 1 }}>
                                {group.dates.map(({ date, day }) => {
                                  const isSelected = date === selectedHistoryDate;
                                  return (
                                    <button
                                      key={date}
                                      onClick={() => { setStatsMonth(new Date(group.year, group.month)); setSelectedHistoryDate(date); }}
                                      style={{
                                        width: '32px',
                                        height: '32px',
                                        borderRadius: '50%',
                                        fontSize: '13px',
                                        fontWeight: isSelected ? '700' : '500',
                                        background: isSelected ? colors.primaryGradient : colors.accentGradient,
                                        border: isSelected ? `2px solid ${colors.primary}` : 'none',
                                        boxShadow: isSelected ? `0 0 0 2px ${colors.cardBg}` : 'none',
                                        color: '#FFF',
                                        cursor: 'pointer',
                                        fontFamily: 'inherit',
                                        outline: 'none',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        padding: 0
                                      }}
                                    >
                                      {day}
                                    </button>
                                  );
                                })}
                              </div>
                            </div>
                          </div>
                        );
                      });
                    })()}
                  </div>
                )}
              </div>
              
              {/* Landscape: 2-column layout */}
              <div className="landscape-only" style={{ display: 'flex', gap: '0', alignItems: 'flex-start' }}>
                <div className="landscape-left" style={{ paddingRight: '24px', overflowY: 'visible' }}>
                  <div className="calendar" style={{ ...styles.calendar, padding: '22px' }}>
                    <div className="calendar-header" style={{ ...styles.calendarHeader, marginBottom: '12px' }}><button className="nav-button" style={{ ...styles.navButton, fontSize: '16px', padding: '4px 8px' }} onClick={() => setStatsMonth(new Date(y, m - 1))}></button><span style={{ fontWeight: '600', fontSize: '15px' }}>{mName}</span><button className="nav-button" style={{ ...styles.navButton, fontSize: '16px', padding: '4px 8px' }} onClick={() => setStatsMonth(new Date(y, m + 1))}></button></div>
                    <div className="calendar-grid" style={{ ...styles.calendarGrid, gap: '4px' }}>
                      {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((d, i) => <div key={i} className="calendar-day-header" style={{ ...styles.calendarDayHeader, fontSize: '11px', padding: '4px 2px' }}>{d}</div>)}
                      {Array(first).fill(null).map((_, i) => <div key={`e${i}`} className="calendar-day" style={{ ...styles.calendarDay, padding: '6px 2px', fontSize: '13px', borderRadius: '6px' }}></div>)}
                      {Array(days).fill(null).map((_, i) => { 
                        const day = i + 1;
                        const isPrayed = prayed.includes(day);
                        const isSelected = day === selectedDay;
                        return (
                          <div 
                            key={day} 
                            className="calendar-day"
                            style={{ 
                              ...styles.calendarDay, 
                              ...(isPrayed ? styles.prayedDay : {}),
                              ...(isSelected ? { boxShadow: `inset 0 0 0 3px ${colors.primary}` } : {}),
                              cursor: isPrayed ? 'pointer' : 'default',
                              transition: 'all 0.15s ease',
                              padding: '6px 2px',
                              fontSize: '13px',
                              borderRadius: '6px'
                            }}
                            onClick={() => isPrayed && setSelectedHistoryDate(formatDate(new Date(y, m, day)))}
                          >
                            {day}
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>
                
                <div className="landscape-separator"></div>
                
                <div className="landscape-right" style={{ paddingLeft: '24px' }}>
                  {/* Historical Prayer Card */}
                  {selectedHistoryDate && (() => {
                    // For cards, gather all individual prayer points from that date
                    const individualPoints = [];
                    if (isCard) {
                      viewingStats.peopleIds.forEach(pid => {
                        const person = people.find(p => p.id === pid);
                        if (person) {
                          const personEntry = getHistoryForDate(person.prayerHistory, selectedHistoryDate);
                          if (personEntry?.personPrayerPoint) {
                            const displayName = person.firstName || person.organisation || 'Unknown';
                            individualPoints.push({ name: displayName, points: personEntry.personPrayerPoint });
                          }
                        }
                      });
                    }
                    
                    const hasCardPoints = selectedEntry?.cardPrayerPoint;
                    const hasPersonalPoints = !isCard && selectedEntry?.personPrayerPoint;
                    const hasIndividualPoints = individualPoints.length > 0;
                    const hasAnyPoints = hasCardPoints || hasPersonalPoints || hasIndividualPoints;
                    
                    if (!hasAnyPoints) {
                      return (
                        <div style={{ ...styles.card, marginTop: '0', marginBottom: '24px', background: colors.secondaryGradient, textAlign: 'center', padding: '12px 14px' }}>
                          <div style={{ fontSize: '13px', color: colors.textSecondary }}>
                            No prayer points recorded for {new Date(selectedHistoryDate).toLocaleDateString('en-US', { day: 'numeric', month: 'short', year: 'numeric' })}
                          </div>
                          <div style={{ fontSize: '11px', color: colors.textTertiary, marginTop: '4px' }}>
                            (Prayer points are saved from new prayers going forward)
                          </div>
                        </div>
                      );
                    }
                    
                    return (
                      <div style={{ ...styles.card, marginTop: '0', marginBottom: '24px', padding: '12px 14px', background: colors.primaryGradient + '15', border: `2px solid ${colors.primary}` }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                          <div style={{ fontSize: '12px', fontWeight: '600', color: colors.primary, textTransform: 'uppercase', letterSpacing: '0.5px' }}>
                            Prayer on {new Date(selectedHistoryDate).toLocaleDateString('en-US', { weekday: 'short', day: 'numeric', month: 'short', year: 'numeric' })}
                          </div>
                          <button 
                            style={{ background: 'none', border: 'none', color: colors.textTertiary, fontSize: '16px', cursor: 'pointer', padding: '2px' }}
                            onClick={() => setSelectedHistoryDate(null)}
                          ></button>
                        </div>
                        {hasCardPoints && (
                          <div style={{ marginBottom: (hasPersonalPoints || hasIndividualPoints) ? '10px' : '0' }}>
                            <div style={{ fontSize: '11px', color: colors.textTertiary, marginBottom: '2px' }}>Card</div>
                            {renderHistoricalPrayerPoints(selectedEntry.cardPrayerPoint)}
                          </div>
                        )}
                        {hasPersonalPoints && (
                          <div>
                            <div style={{ fontSize: '11px', color: colors.textTertiary, marginBottom: '2px' }}>Personal</div>
                            {renderHistoricalPrayerPoints(selectedEntry.personPrayerPoint)}
                          </div>
                        )}
                        {hasIndividualPoints && (
                          <div>
                            <div style={{ fontSize: '11px', color: colors.textTertiary, marginBottom: '4px' }}>Individual Prayer Points</div>
                            {individualPoints.map((item, idx) => (
                              <div key={idx} style={{ marginBottom: idx < individualPoints.length - 1 ? '8px' : '0' }}>
                                <div style={{ fontSize: '13px', fontWeight: '600', color: colors.text, marginBottom: '2px' }}>{item.name}</div>
                                {renderHistoricalPrayerPoints(item.points)}
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                    );
                  })()}
                  
                  {allDates.length > 0 && (
                    <div style={{ marginTop: selectedHistoryDate ? '0' : '0' }}>
                      <div style={{ fontSize: '13px', fontWeight: '600', color: colors.textSecondary, textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '12px' }}>All Prayer Dates</div>
                      {(() => {
                        // Group dates by month
                        const monthGroups = {};
                        allDates.forEach(date => {
                          const d = new Date(date);
                          const key = `${d.getFullYear()}-${String(d.getMonth()).padStart(2, '0')}`;
                          if (!monthGroups[key]) {
                            monthGroups[key] = { year: d.getFullYear(), month: d.getMonth(), dates: [] };
                          }
                          monthGroups[key].dates.push({ date, day: d.getDate() });
                        });
                        // Sort month keys descending
                        const sortedKeys = Object.keys(monthGroups).sort((a, b) => b.localeCompare(a));
                        return sortedKeys.map(key => {
                          const group = monthGroups[key];
                          const monthLabel = new Date(group.year, group.month).toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                          // Sort dates within month ascending
                          group.dates.sort((a, b) => a.day - b.day);
                          return (
                            <div key={key} style={{ marginBottom: '12px' }}>
                              <div style={{ display: 'flex', alignItems: 'flex-start', gap: '12px' }}>
                                <div style={{ fontSize: '13px', fontWeight: '600', color: colors.textTertiary, minWidth: '70px', paddingTop: '6px' }}>{monthLabel}</div>
                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px', flex: 1 }}>
                                  {group.dates.map(({ date, day }) => {
                                    const isSelected = date === selectedHistoryDate;
                                    return (
                                      <button
                                        key={date}
                                        onClick={() => { setStatsMonth(new Date(group.year, group.month)); setSelectedHistoryDate(date); }}
                                        style={{
                                          width: '32px',
                                          height: '32px',
                                          borderRadius: '50%',
                                          fontSize: '13px',
                                          fontWeight: isSelected ? '700' : '500',
                                          background: isSelected ? colors.primaryGradient : colors.accentGradient,
                                          border: isSelected ? `2px solid ${colors.primary}` : 'none',
                                          boxShadow: isSelected ? `0 0 0 2px ${colors.cardBg}` : 'none',
                                          color: '#FFF',
                                          cursor: 'pointer',
                                          fontFamily: 'inherit',
                                          outline: 'none',
                                          display: 'flex',
                                          alignItems: 'center',
                                          justifyContent: 'center',
                                          padding: 0
                                        }}
                                      >
                                        {day}
                                      </button>
                                    );
                                  })}
                                </div>
                              </div>
                            </div>
                          );
                        });
                      })()}
                    </div>
                  )}
                </div>
              </div>
              </div>
            </div>
          );
        }
        
        // Main history list view with tabs
        const renderHistorySortControls = (isPeople = true) => (
          <div className="sort-row" style={{ ...styles.sortRow, marginBottom: 0 }}>
            <div style={{ ...styles.sortDropdown, marginBottom: 0 }}>
              <button style={styles.sortTrigger} onClick={() => setSortDropdownOpen(o => !o)}>
                {isPeople 
                  ? (sortBy === 'lastName' ? 'Last Name' : sortBy === 'firstName' ? 'First Name' : 'Frequency')
                  : (cardSortBy === 'name' ? 'Name' : 'Frequency')
                }
                <span style={{ marginLeft: 'auto', fontSize: '10px', opacity: 0.6 }}></span>
              </button>
              {sortDropdownOpen && (
                <>
                  <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} onClick={() => setSortDropdownOpen(false)} />
                  <div style={styles.sortMenu}>
                    {(isPeople 
                      ? [{ value: 'lastName', label: 'Last Name' }, { value: 'firstName', label: 'First Name' }, { value: 'frequency', label: 'Frequency' }]
                      : [{ value: 'name', label: 'Name' }, { value: 'frequency', label: 'Frequency' }]
                    ).map(opt => (
                      <div 
                        key={opt.value}
                        style={{ ...styles.sortOption, ...((isPeople ? sortBy : cardSortBy) === opt.value ? styles.sortOptionActive : {}) }}
                        onClick={() => { isPeople ? setSortBy(opt.value) : setCardSortBy(opt.value); setSortDropdownOpen(false); }}
                      >
                        <span style={{ width: '16px' }}>{(isPeople ? sortBy : cardSortBy) === opt.value ? '' : ''}</span>
                        {opt.label}
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
            <button style={styles.reverseBtn} onClick={() => setSortReversed(r => !r)}>{sortReversed ? '' : ''}</button>
          </div>
        );
        
        const renderHistoryPeopleList = () => {
          if (!people.length) return <div style={styles.emptyState}>No history yet.</div>;
          const filtered = getFilteredSortedPeople();
          if (searchTerm && !filtered.length) return <div style={styles.emptyState}>No results for "{searchTerm}"</div>;
          return (() => {
                const sorted = filtered;
                const listItemStyle = { ...styles.listItem, marginBottom: 0 };
                
                if (sortBy !== 'frequency') {
                  return (
                    <div className="two-column-grid">
                      {sorted.map(p => { 
                        const c = cards.find(x => x.peopleIds.includes(p.id)); 
                        const isOrg = !p.firstName && !p.lastName && p.organisation; 
                        const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim();
                        const isArchived = p.archived;
                        return (
                          <div key={p.id} style={{ ...listItemStyle, opacity: isArchived ? 0.5 : 1 }} onClick={() => { setViewingStats(p); setStatsMonth(new Date()); setSelectedHistoryDate(null); }}>
                            <div style={{ ...styles.listItemName, fontStyle: isOrg ? 'italic' : 'normal' }}>
                              {displayName}
                              {p.organisation && !isOrg && <span style={{ fontSize: '12px', color: colors.textTertiary, fontStyle: 'italic', fontWeight: 'normal' }}>  {p.organisation}</span>}
                              {isArchived && <span style={{ color: colors.primary, fontSize: '11px', marginLeft: '6px' }}>archived</span>}
                            </div>
                            <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '4px' }}>{formatFrequency(c?.frequency)}  {getPrayerCountThisMonth(p.id)}</div>
                          </div>
                        ); 
                      })}
                    </div>
                  );
                }
                // Frequency grouping
                const groups = {};
                sorted.forEach(p => {
                  const freq = getPersonFrequency(p);
                  if (!groups[freq]) groups[freq] = [];
                  groups[freq].push(p);
                });
                const orderedFreqs = sortReversed ? [...frequencyOrder].reverse() : frequencyOrder;
                return orderedFreqs.map((freq) => {
                  if (!groups[freq] || !groups[freq].length) return null;
                  return (
                    <div key={freq}>
                      <div style={styles.frequencyHeading}>{formatFrequency(freq)}</div>
                      <div className="two-column-grid">
                        {groups[freq].map(p => {
                          const c = cards.find(x => x.peopleIds.includes(p.id));
                          const isOrg = !p.firstName && !p.lastName && p.organisation;
                          const displayName = isOrg ? p.organisation : `${p.firstName} ${p.lastName}`.trim();
                          const isArchived = p.archived;
                          return (
                            <div key={p.id} style={{ ...listItemStyle, opacity: isArchived ? 0.5 : 1 }} onClick={() => { setViewingStats(p); setStatsMonth(new Date()); setSelectedHistoryDate(null); }}>
                              <div style={{ ...styles.listItemName, fontStyle: isOrg ? 'italic' : 'normal' }}>
                                {displayName}
                                {p.organisation && !isOrg && <span style={{ fontSize: '12px', color: colors.textTertiary, fontStyle: 'italic', fontWeight: 'normal' }}>  {p.organisation}</span>}
                                {isArchived && <span style={{ color: colors.primary, fontSize: '11px', marginLeft: '6px' }}>archived</span>}
                              </div>
                              <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '4px' }}>{getPrayerCountThisMonth(p.id)}</div>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  );
                });
              })();
        };
        
        const renderHistoryGroupsList = () => {
          if (!getSortedCards().length) return <div style={styles.emptyState}>No groups yet.</div>;
          const filteredCards = getFilteredSortedCards();
          if (searchTerm && !filteredCards.length) return <div style={styles.emptyState}>No results for "{searchTerm}"</div>;
          return (() => {
                const sortedCards = filteredCards;
                const listItemStyle = { ...styles.listItem, marginBottom: 0 };
                
                if (cardSortBy !== 'frequency') {
                  return (
                    <div className="two-column-grid">
                      {sortedCards.map(c => { 
                        const count = c.peopleIds.length;
                        const isArchived = c.archived;
                        return (
                          <div key={c.id} style={{ ...listItemStyle, opacity: isArchived ? 0.5 : 1 }} onClick={() => { setViewingStats(c); setStatsMonth(new Date()); setSelectedHistoryDate(null); }}>
                            <div style={styles.listItemName}>
                              {getCardDisplayName(c)}
                              {isArchived && <span style={{ color: colors.primary, fontSize: '11px', marginLeft: '6px' }}>{c.dissolved ? 'disbanded' : 'archived'}</span>}
                            </div>
                            <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '2px' }}>{count} {count === 1 ? 'person' : 'people'}</div>
                            <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '4px' }}>{formatFrequency(c.frequency)}  {getCardPrayerCountThisMonth(c)}</div>
                          </div>
                        );
                      })}
                    </div>
                  );
                }
                // Frequency grouping
                const groups = {};
                sortedCards.forEach(c => {
                  if (!groups[c.frequency]) groups[c.frequency] = [];
                  groups[c.frequency].push(c);
                });
                return frequencyOrder.map((freq) => {
                  if (!groups[freq] || !groups[freq].length) return null;
                  return (
                    <div key={freq}>
                      <div style={styles.frequencyHeading}>{formatFrequency(freq)}</div>
                      <div className="two-column-grid">
                        {groups[freq].map(c => {
                          const count = c.peopleIds.length;
                          const isArchived = c.archived;
                          return (
                            <div key={c.id} style={{ ...listItemStyle, opacity: isArchived ? 0.5 : 1 }} onClick={() => { setViewingStats(c); setStatsMonth(new Date()); setSelectedHistoryDate(null); }}>
                              <div style={styles.listItemName}>
                                {getCardDisplayName(c)}
                                {isArchived && <span style={{ color: colors.primary, fontSize: '11px', marginLeft: '6px' }}>{c.dissolved ? 'disbanded' : 'archived'}</span>}
                              </div>
                              <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '2px' }}>{count} {count === 1 ? 'person' : 'people'}</div>
                              <div style={{ fontSize: '12px', color: colors.textTertiary, marginTop: '4px' }}>{getCardPrayerCountThisMonth(c)}</div>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  );
                });
              })();
        };
        
        return (
          <div className="app-container" style={{ ...styles.container, display: 'flex', flexDirection: 'column', height: '100dvh', maxHeight: '100dvh', overflow: 'hidden' }}>
            <div className="app-header">
              <button style={styles.btnText} onClick={() => { setSearchTerm(''); setScreen('home'); }}><span style={{ display: 'inline-block', transform: 'translateY(-2px)' }}></span> Back</button>
              <input 
                style={styles.searchInput} 
                type="text" 
                placeholder="Search..." 
                value={searchTerm} 
                onChange={(e) => setSearchTerm(e.target.value)}
              />
              <div style={{ width: '50px' }}></div>
            </div>
            
            <h2 style={{ fontSize: '18px', fontWeight: '600', color: colors.text, margin: '-8px 0 12px 0', textAlign: 'center' }}>Prayer History</h2>
            
            {/* Portrait: Tabs stacked above sorting */}
            <div className="portrait-only">
              <div style={{ ...styles.tabs, marginBottom: '12px' }}>
                <button style={{ ...styles.tab, ...(historyTab === 'people' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setHistoryTab('people')}>People</button>
                <button style={{ ...styles.tab, ...(historyTab === 'groups' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setHistoryTab('groups')}>Groups</button>
              </div>
              <div style={{ marginBottom: '12px' }}>
                {renderHistorySortControls(historyTab === 'people')}
              </div>
            </div>
            
            {/* Landscape: Tabs left, sorting right - same row */}
            <div className="landscape-only">
              <div style={{ display: 'flex', alignItems: 'center', marginBottom: '12px', gap: '12px', width: '100%' }}>
                <div style={{ ...styles.tabs, flex: '0 0 auto', width: '280px', marginBottom: 0 }}>
                  <button style={{ ...styles.tab, ...(historyTab === 'people' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setHistoryTab('people')}>People</button>
                  <button style={{ ...styles.tab, ...(historyTab === 'groups' ? styles.toggleActive : styles.toggleInactive) }} onClick={() => setHistoryTab('groups')}>Groups</button>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginLeft: 'auto', flex: '0 0 auto' }}>
                  {renderHistorySortControls(historyTab === 'people')}
                </div>
              </div>
            </div>
            
            {/* 2-column grid list */}
            <div className="two-column-list" style={{ flex: 1, overflowY: 'auto', overflowX: 'hidden', padding: '12px 6px 24px 6px', margin: '0 -6px', minHeight: 0, WebkitOverflowScrolling: 'touch', touchAction: 'pan-y' }}>
              {historyTab === 'people' ? renderHistoryPeopleList() : renderHistoryGroupsList()}
            </div>
          </div>
        );
      };

      const renderContent = () => {
        // Onboarding takes highest priority
        if (!onboardingComplete) return renderOnboarding();
        
        // Help screen takes priority
        if (helpOpen) return renderHelp();
        
        if (editingPerson) return <>{renderEditPerson()}{renderModal()}</>;
        if (editingCard) return <>{renderEditCard()}{renderModal()}</>;
        if (viewingStats) return renderStats();
        
        switch (screen) {
          case 'home': return renderHome();
          case 'prayer': return renderPrayer();
          case 'manage': return renderManage();
          case 'stats': return renderStats();
          case 'createGroup': return renderCreateGroup();
          default: return renderHome();
        }
      };

      return (
        <div className="desktop-wrapper">
          {renderContent()}
          {tutorialActive && screen === 'home' && renderTutorial()}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<PrayerCompanion />);
    
    // ============================================
    // PWA Service Worker Registration & Update Detection
    // ============================================
    if ('serviceWorker' in navigator) {
      let refreshing = false;
      let swRegistration = null;
      
      // Function to check for updates and show modal if needed
      const checkForUpdates = (registration) => {
        if (!registration) return;
        // Force check for updates - bypass cache
        registration.update().then(() => {
          // Check if there's a waiting worker
          if (registration.waiting) {
            console.log('[SW] Waiting worker found, showing update modal');
            window.dispatchEvent(new CustomEvent('sw-waiting', { detail: registration.waiting }));
          }
        }).catch(err => {
          console.error('[SW] Error checking for updates:', err);
        });
      };
      
      // Register service worker with cache-busting for iOS
      navigator.serviceWorker.register('./service-worker.js', { updateViaCache: 'none' })
        .then(registration => {
          swRegistration = registration;
          console.log('[SW] Service Worker registered:', registration);
          
          // Check if there's already a waiting worker on page load
          if (registration.waiting) {
            console.log('[SW] Waiting worker found on load');
            window.dispatchEvent(new CustomEvent('sw-waiting', { detail: registration.waiting }));
          }
          
          // Force an immediate update check on registration
          checkForUpdates(registration);
          
          // Check for updates periodically (every 30 seconds for faster detection)
          setInterval(() => {
            checkForUpdates(registration);
          }, 30000);
          
          // Listen for updates
          registration.addEventListener('updatefound', () => {
            console.log('[SW] Update found, new worker installing...');
            const newWorker = registration.installing;
            
            if (newWorker) {
              newWorker.addEventListener('statechange', () => {
                console.log('[SW] New worker state:', newWorker.state);
                if (newWorker.state === 'installed') {
                  if (navigator.serviceWorker.controller) {
                    // There's a new service worker available
                    console.log('[SW] New service worker installed and waiting');
                    window.dispatchEvent(new CustomEvent('sw-waiting', { detail: registration.waiting || newWorker }));
                  } else {
                    // First time installation
                    console.log('[SW] Service worker installed for the first time');
                  }
                }
              });
            }
          });
        })
        .catch(error => {
          console.error('[SW] Service Worker registration failed:', error);
        });
      
      // Listen for controller change (when new SW takes control)
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (!refreshing) {
          console.log('[SW] New service worker activated, reloading page...');
          refreshing = true;
          window.location.reload();
        }
      });
      
      // Check for updates when app comes to foreground (important for iOS PWAs)
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible' && swRegistration) {
          console.log('[SW] App became visible, checking for updates...');
          checkForUpdates(swRegistration);
        }
      });
      
      // Also check on focus (backup for visibility change)
      window.addEventListener('focus', () => {
        if (swRegistration) {
          console.log('[SW] Window focused, checking for updates...');
          checkForUpdates(swRegistration);
        }
      });
    }
  </script>
</body>
</html>

